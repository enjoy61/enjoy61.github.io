<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>健康系统 on </title>
    <link>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 健康系统 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 11 Jun 2023 05:36:57 +0000</lastBuildDate><atom:link href="https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>实时显示游戏角色生命值</title>
      <link>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%94%9F%E5%91%BD%E5%80%BC/</link>
      <pubDate>Sun, 11 Jun 2023 05:31:13 +0000</pubDate>
      
      <guid>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%94%9F%E5%91%BD%E5%80%BC/</guid>
      <description>概览 # - 健康组件 ActorComponent 自定义，纯逻辑 文本组件 TextRenderComponent 显示生命值 创建健康组件 # 创建Component/STUHealthComponent # 虚幻编辑器 ActorComponent 公有类 调整健康组件框架 # C++ ShootThemUp: Components/STUHealthComponent.h ShootThemUp: Components/STUHealthComponent.cpp - 默认构造函数 将每帧调用TickComponent函数标志置为false BeginPlay TickComponent 屏蔽，使用基类实现 实现 # 添加生命值上限 # protected ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = &amp;quot;0.0&amp;quot;, ClampMax = &amp;quot;1000.0&amp;quot;)) float MaxHealth = 100.0f;	添加生命值 # private ShootThemUp: Components/STUHealthComponent.h float Health = 0.0f; 初始化生命值 # ShootThemUp: Components/STUHealthComponent.cpp // BeginPlay Health = MaxHealth; 添加接口，返回生命值 # public ShootThemUp: Components/STUHealthComponent.</description>
    </item>
    
    <item>
      <title>对游戏角色造成伤害</title>
      <link>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AF%B9%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E9%80%A0%E6%88%90%E4%BC%A4%E5%AE%B3/</link>
      <pubDate>Sun, 11 Jun 2023 05:49:08 +0000</pubDate>
      
      <guid>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AF%B9%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E9%80%A0%E6%88%90%E4%BC%A4%E5%AE%B3/</guid>
      <description>概览 # C++ 对游戏角色造成伤害 # 虚幻引擎提供一组函数，用来对Actor造成伤害 若有注册伤害处理服务, Actor受到伤害时触发处理函数 本节在Tick函数中持续对游戏角色造成伤害 伤害处理服务 # 我们在Actor提供的数据成员处注册伤害处理函数, 在处理函数中减少游戏角色生命值 持续对游戏角色造成伤害 # C++ 伤害来源是自己 ShootThemUp: Player/STUBaseCharacter.cpp // Tick TakeDamage(0.1f, FDamageEvent{}, GetController(), this); 伤害处理服务 # AActor定义了委托类型FTakeAnyDamageSignature，并有该类型数据成员AActor::OnTakeAnyDamage 我们通过数据成员注册伤害处理服务 处理函数签名 void handler(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 该委托类型支持蓝图 触发伤害处理函数时，会传入UDamageType 注册伤害机制的委托服务 # C++ 搭建框架 # 添加空函数 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) {} 注册伤害处理函数 ShootThemUp: Components/STUHealthComponent.</description>
    </item>
    
    <item>
      <title>模拟榴弹爆炸</title>
      <link>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E6%8B%9F%E6%A6%B4%E5%BC%B9%E7%88%86%E7%82%B8/</link>
      <pubDate>Sun, 11 Jun 2023 05:50:27 +0000</pubDate>
      
      <guid>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E6%8B%9F%E6%A6%B4%E5%BC%B9%E7%88%86%E7%82%B8/</guid>
      <description>建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 创建伤害源 # 创建Dev/STUDevDamageActor # 虚幻编辑器 Actor 公有类 设置头文件搜索路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { &amp;quot;ShootThemUp/Public/Player&amp;quot;, &amp;quot;ShootThemUp/Public/Components&amp;quot;, &amp;quot;ShootThemUp/Public/Dev&amp;quot; }); 添加可视化组件，使得伤害源可变换 # 添加SceneComponent protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent; 初始化组件 ShootThemUp: Dev/STUDevDamageActor.cpp // 构造函数 SceneComponent = CreateDefaultSubobject&amp;lt;USceneComponent&amp;gt;(&amp;quot;SceneComponent&amp;quot;); SetRootComponent(SceneComponent); 绘制球体，使得爆炸范围可视化 # 添加球体参数 protected ShootThemUp: Dev/STUDevDamageActor.h - 颜色 SphereColor 半径 Radius UPROPERTY(EditAnywhere) float Radius = 300.0f; UPROPERTY(EditAnywhere) FColor SphereColor = FColor::Red; 每帧绘制球体 ShootThemUp: Dev/STUDevDamageActor.cpp #include &amp;quot;DrawDebugHelpers.h&amp;quot; // Tick DrawDebugSphere(GetWorld(), GetActorLocation(), Radius, 24, SphereColor); 使用了GetWorld，其声明和UWorld的定义在一处，而DrawDebugSphere的第一个参数类型为UWorld，不用包含Engine/World.</description>
    </item>
    
    <item>
      <title>使用伤害类型</title>
      <link>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E4%BC%A4%E5%AE%B3%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 11 Jun 2023 05:50:41 +0000</pubDate>
      
      <guid>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E4%BC%A4%E5%AE%B3%E7%B1%BB%E5%9E%8B/</guid>
      <description>创建伤害类型 # 虚幻编辑器 创建Dev/STUFireDamageType # UDamageType 公有类 创建Dev/STUIceDamageType # UDamageType 公有类 为伤害来源添加伤害类型属性 # C++ 添加伤害类型参数 protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(EditAnywhere) TSubclassOf&amp;lt;UDamageType&amp;gt; DamageType; 造成伤害时，传入伤害类型 ShootThemUp: Dev/STUDevDamageActor.cpp // Tick // UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); 在伤害处理函数中输出伤害来源信息 # C++ ShootThemUp: Components/STUHealthComponent.cpp #include &amp;quot;Dev/STUFireDamageType.h&amp;quot; #include &amp;quot;Dev/STUIceDamageType.h&amp;quot; // OnTakeAnyDamage if (DamageType) { if (DamageType-&amp;gt;IsA&amp;lt;USTUFireDamageType&amp;gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(&amp;quot;So Hooooooot !!!&amp;quot;)); } else if (DamageType-&amp;gt;IsA&amp;lt;USTUIceDamageType&amp;gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(&amp;quot;So Cooooooooold !</description>
    </item>
    
    <item>
      <title>添加游戏角色死亡逻辑</title>
      <link>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%AD%BB%E4%BA%A1%E9%80%BB%E8%BE%91/</link>
      <pubDate>Sun, 11 Jun 2023 05:51:15 +0000</pubDate>
      
      <guid>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%AD%BB%E4%BA%A1%E9%80%BB%E8%BE%91/</guid>
      <description>说明 # 生命值修改时, 同步到HealthTextComponent组件 # 生命值为0，销毁游戏角色 # 死亡时, 播放死亡动画 # 动画剪辑 # Animation Montage 可以将多个动画组合播放。把希望连续播放的动画添加到时间线 timeline ，在代码或蓝图中播放动画剪辑 命名：以AM_打头 Slot # 若此时播放动画剪辑，输出输入动画和动画剪辑的拼接；若无动画剪辑在播放，输出输入动画 添加委托：当生命值更改时，同步到HealthTextComponent文本 # C++ 屏蔽当前HealthTextComponent文本的设置 # ShootThemUp: Player/STUBaseCharacter.cpp 屏蔽Tick函数中的文本更新 初始化HealthTextComponent文本 # ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthTextComponent-&amp;gt;SetText(FText::FromString(FString::Printf(TEXT(&amp;quot;%.0f&amp;quot;), HealthComponent-&amp;gt;GetHealth()))); HealthComponent提供委托服务: 生命值修改通知 # - 多播 仅C++ 在HealthComponent定义委托类型FChangeHealthSignature # ShootThemUp: Components/STUHealthComponent.h DECLARE_MULTICAST_DELEGATE(FChangeHealthSignature); 添加数据成员OnChangeHealth，提供委托服务 # public ShootThemUp: Components/STUHealthComponent.h FChangeHealthSignature OnChangeHealth; 封装修改Health逻辑，调用时通知客户端 # 只能通过SetHealth接口修改生命值 函数定义 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::SetHealth(float NewHealth) { Health = NewHealth; OnChangeHealth.Broadcast(); } 函数声明 private ShootThemUp: Components/STUHealthComponent.</description>
    </item>
    
    <item>
      <title>添加观察视角</title>
      <link>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E8%A7%82%E5%AF%9F%E8%A7%86%E8%A7%92/</link>
      <pubDate>Sun, 11 Jun 2023 05:51:30 +0000</pubDate>
      
      <guid>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E8%A7%82%E5%AF%9F%E8%A7%86%E8%A7%92/</guid>
      <description>说明 # 当游戏角色生命值为0，我们尝试剥夺玩家对游戏角色的控制，此时仍能旋转Camera; 左右旋转视角时, Character身体也会旋转 我们可以在游戏角色死亡时，切换玩家控制的Pawn：一方面，彻底剥夺玩家对游戏角色的控制，另一方面，允许玩家做合理的操作 观察视角 # 对应一个APawn派生类，ASpectatorPawn 关卡的默认类型里，观察者类使用ASpectatorPawn 玩家死亡后，使其操控SpectatorPawn，仍能继续观看游戏 场景中的SpectatorPawn # 漂浮的Camera，除了可以前后左右移动，还可以上下移动，亦支持旋转，由鼠标控制 本小节使用默认的观察者类 # 游戏角色死亡后，切换到观察视角 # C++ 先前我们已设置STUGameModeBase使用STUPlayerController类。 APawn::Controller和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STUPlayerController的。 游戏角色死亡时，切换到观察视角 ShootThemUp: Player/STUBaseCharacter.cpp #include &amp;quot;GameFramework/Controller.h&amp;quot; // OnDeath if (Controller) { Controller-&amp;gt;ChangeState(NAME_Spectating); } 查看 # 虚幻编辑器 查看SpectatorPawn # WorldSetting中，GameMode默认选择SpectatorPawn作为Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 # Character死亡后，世界大纲新增SpectatorPawn1 </description>
    </item>
    
    <item>
      <title>自动治疗</title>
      <link>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%8A%A8%E6%B2%BB%E7%96%97/</link>
      <pubDate>Sun, 11 Jun 2023 05:51:47 +0000</pubDate>
      
      <guid>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%8A%A8%E6%B2%BB%E7%96%97/</guid>
      <description>说明 # C++ 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现 获取定时器管理对象 UActorComponent::GetOwner &amp;gt; AActor::GetWorldTimerManager UActorComponent::GetWorld &amp;gt; UWorld::GetTimerManager 实现自动治疗 # 添加治疗参数 # protected 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = &amp;quot;AutoHeal&amp;quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = &amp;quot;AutoHeal&amp;quot;)) float HealDelay = 3.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = &amp;quot;AutoHeal&amp;quot;)) float HealModifier = 5.0f; 添加定时器 # 添加数据成员 # private ShootThemUp: Components/STUHealthComponent.</description>
    </item>
    
    <item>
      <title>坠落伤害</title>
      <link>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%9D%A0%E8%90%BD%E4%BC%A4%E5%AE%B3/</link>
      <pubDate>Sun, 11 Jun 2023 05:52:09 +0000</pubDate>
      
      <guid>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%9D%A0%E8%90%BD%E4%BC%A4%E5%AE%B3/</guid>
      <description>说明 # C++ 落地速度Z方向的分量和坠落高度有关；速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落机制 # Character定义了坠落委托类型FLandedSignature，并有该类型成员ACharacter::LandedDelegate 委托类型的处理函数签名 void handler(const FHitResult&amp;amp; Hit); 该委托类型支持蓝图 Character在ACharacter::Landed通知客户端 思路 # 我们可以注册LandedDelegate的委托服务，也可以覆写ACharacter::Landed，添加相应处理 选择注册委托服务 坠落伤害计算 # 参数 - 坠落伤害范围 LandedDamageRange [c, d] 落地速度范围 LandedDamageVelocityRange [a, b] 落地速度和对应的伤害 速度 伤害 &amp;lt; a 无伤 [a, b] [c, d] c + (Velocity - a) (d - c) / (b - a) &amp;gt; b d 获取Character速度 APawn::GetVelocity ACharacter:: GetCharacterMovement &amp;gt; UCharacterMovementComponent::Velocity 添加坠落伤害参数 # protected ShootThemUp: Player/STUBaseCharacter.</description>
    </item>
    
    <item>
      <title>阶段性总结</title>
      <link>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 11 Jun 2023 05:52:33 +0000</pubDate>
      
      <guid>https://enjoy61.com/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</guid>
      <description>项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D AM_Death BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent STUHealthComponent Player STUBaseCharacter STUPlayerController Dev STUDevDamageActor STUFireDamageType STUIceDamageType STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D Player/Animations/AM_Death STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 轴映射 左右移动 APawn::AddMovementInput；AActor::GetActorRightVector MoveForward 轴映射 前后移动 APawn::AddMovementInput；AActor::GetActorForwardVector 轴映射 左右旋转 ACharacter::AddControllerYawInput 轴映射 上下旋转 ACharacter::AddControllerPitchInput 动作映射 跳跃 ACharacter::Jump RunEnable，RunDisable 动作映射 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 委托 处理函数 作用 委托成员 操作 OnChangeHealth 修改显示生命值 HealthComponent::OnChangeHealth 修改HealthTextComponent文本 OnDeath 游戏角色死亡处理 HealthComponent::OnDeath 播放死亡动画剪辑；禁止操作Character；定时销毁；切换到观察视角 OnGroundLanded 计算落地伤害 ACharacter::LandedDelegate 计算落地伤害；对Character调用TakeDamage 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 HealthComponent 生命值系统 HealthTextComponent 显示生命值 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 游戏角色死亡逻辑 说明 DeathAnimMontage 死亡动画剪辑 LifeSpanOnDeath 销毁角色定时间隔 落地伤害逻辑 说明 LandedDamageRange 伤害范围 LandedDamageVelocityRange 造成伤害的速度范围 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh &amp;gt; Skeletal Mesh Asset HeroTPP Materials &amp;gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true HealthComponent # HealthTextComponent # 说明 Horizontal Alignment Center Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机</description>
    </item>
    
  </channel>
</rss>
