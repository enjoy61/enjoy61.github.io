<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>武器 on </title>
    <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/</link>
    <description>Recent content in 武器 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 11 Jun 2023 05:37:09 +0000</lastBuildDate><atom:link href="https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>给游戏角色装载武器</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%BB%99%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A3%85%E8%BD%BD%E6%AD%A6%E5%99%A8/</link>
      <pubDate>Sun, 11 Jun 2023 07:24:08 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%BB%99%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A3%85%E8%BD%BD%E6%AD%A6%E5%99%A8/</guid>
      <description>概览 # 导入武器相关资产 创建武器类STUBaseWeapon和BP_STUBaseWeapon 为STUBaseWeapon添加骨骼网格体, 绑定武器模型 武器模型 说明 Launcher 发射导弹 Rifle 发射子弹 Shoot Regular Cartridges 为游戏角色骨骼网格体添加挂载点, 动态创建武器对象并挂载到游戏角色 导入武器相关资产 # 虚幻编辑器 之前将资产导入到Content/ExternalContent/Animation，有两点需注意 资产之前存在相互引用，这个在Migrate过程中，不一定会全无问题 我们选择Migrate ShooterGame/Content/Animations/TTP_Animations ，而实际导出有多个文件夹，里面的内容都和TTP_Animations有关 本节需要Migrate的武器资产，其相关内容与之前的内容有重叠; 和之前一样, 在ExternalContent下单独创建一个文件夹，存放本次导入资产 从ShooterGame导出 # 选中Content/Weapons &amp;gt; Migrate 相关文件存放在Characters，Environment和Weapons中 保存到ShootThemUp/Content 导入到ShootThemUp # 创建ExternalContent/Weapon，并设置文件夹颜色 将资产移动到ExternalContent/Weapon 创建武器类 # 初始化C++类: STUBaseWeapon # 创建C++类: Weapon/STUBaseWeapon # 虚幻编辑器 Actor 公有类 设置头文件路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { &amp;quot;ShootThemUp/Public/Player&amp;quot;, &amp;quot;ShootThemUp/Public/Components&amp;quot;, &amp;quot;ShootThemUp/Public/Dev&amp;quot;, &amp;quot;ShootThemUp/Public/Weapon&amp;quot; }); 调整框架 # C++ - 构造函数 每帧调用置为false Tick 屏蔽 BeginPlay - ShootThemUp: Weapon/STUBaseWeapon.</description>
    </item>
    
    <item>
      <title>绘制瞄准十字</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%BB%98%E5%88%B6%E7%9E%84%E5%87%86%E5%8D%81%E5%AD%97/</link>
      <pubDate>Wed, 21 Jun 2023 19:03:08 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%BB%98%E5%88%B6%E7%9E%84%E5%87%86%E5%8D%81%E5%AD%97/</guid>
      <description>概览 # 瞄准十字：垂直的两条线，处于屏幕正中间 创建抬头显示类STUGameHUD 设置关卡使用STUGameHUD, 绘制瞄准十字 调整SpringArm组件的Camera偏移, 使得游戏角色在瞄准十字左侧 调整HealthText组件, 生命值对敌人可见, 对自己不可见 在代码中设置SpringArm组件Socket偏移和TextRender组件渲染标志位的方法 HUD # Head-Up Display 抬头显示, 包含一些常用信息 用得不多, 很多功能使用Widget完成 AHUD 创建抬头显示类 # 创建C++类: UI/STUGameHUD # 虚幻编辑器 Actor &amp;gt; AHUD 公有类 更新头文件搜索路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { &amp;quot;ShootThemUp/Public/Player&amp;quot;, &amp;quot;ShootThemUp/Public/Components&amp;quot;, &amp;quot;ShootThemUp/Public/Dev&amp;quot;, &amp;quot;ShootThemUp/Public/Weapon&amp;quot;, &amp;quot;ShootThemUp/Public/UI&amp;quot; }); 绘制瞄准十字 # 虚幻C++ 设置关卡使用STUGameHUD # AGameModeBase::HUDClass ShootThemUp: STUGameModeBase.cpp #include &amp;quot;UI/STUGameHUD.h&amp;quot; // ASTUGameModeBase HUDClass = ASTUGameHUD::StaticClass(); 获取屏幕中心位置 # 通过AHUD::Canvas获取屏幕长和宽，中心点保存到TInterval类型变量 AHUD::Canvas UCanvas UCanvas::SizeX 和 UCanvas::SizeY TInterval #include &amp;quot;Engine/Canvas.</description>
    </item>
    
    <item>
      <title>武器组件</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E6%AD%A6%E5%99%A8%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Sun, 25 Jun 2023 16:42:52 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E6%AD%A6%E5%99%A8%E7%BB%84%E4%BB%B6/</guid>
      <description>概览 # 创建武器组件类 STUWeaponComponent 武器组件负责武器相关逻辑: 将SpawnWeapon移到武器组件 为游戏角色添加武器组件 为武器类添加 Fire 接口, 对应扣动扳机逻辑 为游戏角色绑定鼠标左键, 武器组件提供回调函数 Fire , 调用武器类 Fire 接口 初始化武器组件类 # 创建C++类: Components/STUWeaponComponent # 虚幻编辑器 - ActorComponent Public Components 调整框架 # C++ - 构造函数 每帧调用置false TickComponent 屏蔽 ShootThemUp: Components/STUWeaponComponent.h ShootThemUp: Components/STUWeaponComponent.cpp 将SpawnWeapon逻辑移动到武器组件 # C++ 在STUWeaponComponent中实现SpawnWeapon # 添加武器类型属性, 动态创建Actor时使用
ShootThemUp: Components/STUWeaponComponent.h protected class ASTUBaseWeapon; UPROPERTY(EditDefaultsOnly) TSubclassOf&amp;lt;ASTUBaseWeapon&amp;gt; WeaponClass; ShootThemUp: Components/STUWeaponComponent.cpp #include &amp;quot;Weapon/STUBaseWeapon.h&amp;quot; 添加变量: 存放挂载点名称
protected ShootThemUp: Components/STUWeaponComponent.h UPROPERTY(EditDefaultsOnly) FName WeaponAttachPointName = &amp;quot;WeaponSocket&amp;quot;; 添加变量: 存放武器指针</description>
    </item>
    
    <item>
      <title>初识碰撞</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%88%9D%E8%AF%86%E7%A2%B0%E6%92%9E/</link>
      <pubDate>Sun, 25 Jun 2023 16:56:18 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%88%9D%E8%AF%86%E7%A2%B0%E6%92%9E/</guid>
      <description>概览 # 虚幻编辑器 在虚幻编辑器使用控制台 Console 碰撞选项 设置对其他类型物体的反馈 设置对通道的反馈 碰撞时产生重叠事件 碰撞时产生碰撞事件 自定义物体类型 碰撞 # 物体之间的交互，会发生以下情形 - Ignore 不会发生碰撞 Overlap 重叠: 可以发生碰撞, 允许通过, 可以产生重叠事件 Block 阻挡：可以发生碰撞, 形成阻碍, 可以产生碰撞事件 游戏角色拥有Capsule组件, 用以处理碰撞相关逻辑: 如游戏角色跳起后会落到地面, 而不是穿过地板; 可以操控其上楼梯; 和另一个游戏角色碰撞, 而不是穿过他 轨迹计算 # Logical Trace 给定轨迹的端点, 计算场景中与轨迹相交的物体 通过轨迹计算得到射击击中的目标 在虚幻编辑器使用控制台 # 打开控制台 运行时, 按下 ` Apostrophe Sign , 在视口下方会出现命令行, 可以输入调试命令 设置打开控制台的快捷键 项目设置 &amp;gt; Engine &amp;gt; Input &amp;gt; Console &amp;gt; Console Keys 输出每秒帧数 # stat fps 在右上方显示 1秒将近40帧 1s / 25ms = 1000ms / 25ms = 40 输出GPU统计数据 # stat GPU 隐藏Debug信息 # 输入相同命令, 或 stat none 显示场景中的碰撞 # show collision 可以看到Character的Capsule组件；碰撞组件纯逻辑, 在游戏中默认不可见 再次输入隐藏 碰撞选项 # 碰撞选项 设置游戏角色穿过物体 # 在场景中添加Sphere和Cube Place Actors &amp;gt; Shapes 设置游戏角色Capsule组件的碰撞选项 # BP_STUBaseCharacter &amp;gt; Capsule Component &amp;gt; Details &amp;gt; Collision 碰撞预设默认为Pawn 将碰撞预设置为Custom 设置Sphere的碰撞选项 # 将碰撞预设设置为Custom 允许游戏角色穿过 对物体类型的碰撞反馈中, 设置对Pawn执行Overlap Collision Responses &amp;gt; Object Responses &amp;gt; Pawn, 勾选Overlap 设置Cube的碰撞选项 # 设置 Collision Preset 为Custom 允许Pawn穿过 查看 # 游戏角色可以穿过Sphere和Cube # 游戏角色与物体碰撞时, 镜头会放大, 这是Camera通道对于Block设置给出的碰撞反馈 # 可以在SpringArm组件设置碰撞探测通道, 默认使用Camera通道 Camera组件作为SpringArm组件的下级组件, 是游戏角色的一部分, 此时也与物体碰撞 之所以会放大镜头, 在于发生碰撞时要表示阻挡; 我们不应该看到已经穿过物体那部分 设置Camera通道忽略物体 # 查看SpringArm组件 # BP_STUBaseCharacter &amp;gt; 选中SpringArmComponent &amp;gt; Details &amp;gt; Camera Collision &amp;gt; Probe Channel SpringArm组件如何进行碰撞探测, 默认为Camera通道 Probe Channel Camera 设置Camera通道忽略Sphere # Collision Responses &amp;gt; Trace Responses &amp;gt; Camera, 选择Ignore 查看: 游戏角色穿过Sphere时, 感官上正常 # 产生重叠事件: 输出Actor信息 # 在蓝图中处理事件 # 打开 BP_STUBaseCharacter &amp;gt; Event Graph Event ActorBeginOverlap 之后, 在屏幕打印 PrintString OtherActor作为PrintString输入, 实际输出产生碰撞的物体名称 为物体勾选发生碰撞时产生重叠事件 # Sphere Details &amp;gt; 勾选 Generate Overlap Events Cube Details &amp;gt; 勾选 Generate Overlap Events 查看日志 # 产生碰撞事件: 获取碰撞信息 # 为物体勾选发生碰撞时产生碰撞事件 # 选择Cube, 去到Details面板, 勾选 Simulation Generates Hit Events 在蓝图中添加事件 # BP_STUBaseCharacter &amp;gt; EventGraph, 添加EventHit 补充： 要求物体与Cube的碰撞反馈互为Block，发生碰撞时，才会产生碰撞事件 # 自定义物体类型 # 项目设置 &amp;gt; Engine &amp;gt; Collision 创建物体类型Enemy # New Object Channel 设置 - Name Enemy Default Response Block 其他类型物体对Enemy采取Block 创建物体类型Geometry # New Object Channel 设置 - Name Geometry Default Response Ignore 其他类型物体对Geometry采取Ignore 查看游戏角色的碰撞选项 # - Enemy Block Geometry Ignore 设置Cube # 物体类型为Geometry 忽略Pawn 设置Sphere # 物体类型为Enemy 阻挡Pawn </description>
    </item>
    
    <item>
      <title>轨迹</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E8%BD%A8%E8%BF%B9/</link>
      <pubDate>Fri, 11 Aug 2023 18:01:42 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E8%BD%A8%E8%BF%B9/</guid>
      <description>概览 # Line Trace 本节介绍如何使用武器进行射击 Socket # 之前我们使用socket作为锚来附加武器 现在我们使用它来标记枪口 添加Muzzle Socket # 虚幻编辑器 之后会在代码中访问Socket, 以及从枪口发射子弹 双击打开 Content &amp;gt; ExternalContent &amp;gt; Weapon &amp;gt; Weapons &amp;gt; Rifle 选中 Skeleton Tree &amp;gt; RifleRoot , 右键, 选择Add Socket, 命名为MuzzleSocket 在细节面板设置Relative Location 默认在武器坐标系的0坐标, 调整到枪口位置, 和各个轴对齐 可以更换观察视角, 调整枪口变换 Top视角 沿着武器发射子弹的方向绘制线段 # C++ 添加MakeShot # 包含发射子弹的所有逻辑 把Fire和Shot分开 如温切斯特连发步枪, 扣一下扳机, 连发数枚子弹 timer for shooting 声明 # protected ShootThemUp: Weapon/STUBaseWeapon.h 空函数 # ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::MakeShot() {} 在Fire中调用 # 检查WeaponMeshComponent # 使用时不必检查 ShootThemUp: Weapon/STUBaseWeapon.</description>
    </item>
    
    <item>
      <title>重构MakeShot</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E9%87%8D%E6%9E%84makeshot/</link>
      <pubDate>Fri, 11 Aug 2023 18:23:16 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E9%87%8D%E6%9E%84makeshot/</guid>
      <description>说明 # 本节使用的重构被称作提取 The Extract Method , 将函数切分, 使得代码可读性更高 对武器类的MakeShot重构 纯理论逻辑放在protected, 供派生类调用 调整逻辑 # void ASTUBaseWeapon::MakeShot() { if(!GetWorld()) return; // 获取PlayerController const auto Player = Cast&amp;lt;ACharacter&amp;gt;(GetOwner()); if (!Player) return; const auto Controller = Player-&amp;gt;GetController&amp;lt;APlayerController&amp;gt;(); if (!Controller) return; // 通过Controller获取CameraComponent的位置和方向 FVector ViewLocation; FRotator ViewRotation; Controller-&amp;gt;GetPlayerViewPoint(ViewLocation, ViewRotation); // 通过CameraComponent的位置和方向计算轨迹信息 const FVector TraceStart = ViewLocation; const FVector ShootDirection = ViewRotation.Vector(); const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; // 提供轨迹获取碰撞信息 FHitResult HitResult; FCollisionQueryParams CollisionParams; CollisionParams.</description>
    </item>
    
    <item>
      <title>射击伤害</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%B0%84%E5%87%BB%E4%BC%A4%E5%AE%B3/</link>
      <pubDate>Fri, 11 Aug 2023 18:23:26 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%B0%84%E5%87%BB%E4%BC%A4%E5%AE%B3/</guid>
      <description>说明 # 从交点获取击中的Actor信息 创建MakeDamage, 击中目标时调用, 传入相交信息 # C++ 搭建框架 # 声明 preotected ShootThemUp: Weapon/STUBaseWeapon.h void MakeDamage(const FHitResult&amp;amp; HitResult); 空定义 ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::MakeDamage(const FHitResult&amp;amp; HitResult) {} MakeShot中调用 ShootThemUp: Weapon/STUBaseWeapon.cpp 实现MakeDamage # 获取击中的Actor ShootThemUp: Weapon/STUBaseWeapon.cpp const auto DamagedActor = HitResult.GetActor(); if (!DamagedActor) return; 添加数据成员: 伤害值 protected ShootThemUp: Weapon/STUBaseWeapon.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float DamageAmount = 10.0f; 对Actor造成伤害, 直接对其调用TakeDamage DamagedActor-&amp;gt;TakeDamage(DamageAmount, FDamageEvent(), GetPlayerController(), this); 查看 # 虚幻编辑器 对游戏角色造成射击伤害 游戏角色死亡 角色死亡播放死亡动画倒地, CapsuleComponent成为障碍物 # 虚幻编辑器 运行时显示CapsuleComponent show collision 游戏角色死亡, CapsuleComponent成为障碍物 死亡处理函数中, 禁止CapsuleComponent的碰撞 # C++ ShootThemUp: Player/STUBaseCharacter.</description>
    </item>
    
    <item>
      <title>瞄准偏移</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%9E%84%E5%87%86%E5%81%8F%E7%A7%BB/</link>
      <pubDate>Wed, 16 Aug 2023 13:59:48 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%9E%84%E5%87%86%E5%81%8F%E7%A7%BB/</guid>
      <description>概览 # Aim Offset 瞄准偏移资产 # Aim Offset 专门用于瞄准 有常规和1D两种, 和混合空间一样 常规AimOffset有两个轴, 覆盖瞄准在水平和垂直方向的偏移 需要绑定骨骼网格体 命名前缀为AO_ 本节会创建瞄准偏移资产, 支持水平和垂直方向的偏移, 但只使用垂直方向的偏移 # 射击瞄准相较之前自然一些 使用到的动画资产 # - AimOffsetFwd AimOffsetUp AimOffsetDown AimOffsetLeft AimOfsetLeftDown AimOffsetLeftUp AimOffsetRight AimOfsetRightDown AimOffsetRightUp 垂直方向的偏移来自CameraComponent前进向量在垂直方向的分量 # 通过游戏角色控制器旋转CameraComponent实现游戏角色的视角旋转 水平旋转游戏角色时, 身体跟随 绘制CameraComponent的前进向量 # 获取CameraComponent的旋转分量, 通过旋转分量获取前进向量 在动画蓝图EventGraph计算CameraComponent旋转分量 # ABP_BaseCharacter &amp;gt; EventGraph 获取CameraComponent的旋转分量 # - 输入 Pawn 函数 GetBaseAimRotation: 通过Pawn的Controller返回游戏角色CameraComponent的旋转分量 保存旋转分量到变量, AnimGraph中会用到
Promote to Variable 变量列表出现新变量, 命名为AimRotation 完整实现
根据旋转分量获取CameraComponent的前进分量, 使用DrawDebugLine绘制 # - 起点 游戏角色位置 Pawn &amp;gt; GetActorLocation 偏移 放大的CameraComponent前进向量 Pawn &amp;gt; GetBaseAimRotation &amp;gt; GetForwardVector 终点 起点 + 偏移 乘法输入转为float: 右键另一个输入 DrawDebugLine参数 - Duration 0.</description>
    </item>
    
  </channel>
</rss>
