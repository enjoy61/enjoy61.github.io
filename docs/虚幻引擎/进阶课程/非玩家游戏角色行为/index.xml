<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>非玩家游戏角色行为 on </title>
    <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/</link>
    <description>Recent content in 非玩家游戏角色行为 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 19 Oct 2023 21:26:29 +0000</lastBuildDate><atom:link href="https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用EQS寻找生命补给</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E4%BD%BF%E7%94%A8eqs%E5%AF%BB%E6%89%BE%E7%94%9F%E5%91%BD%E8%A1%A5%E7%BB%99/</link>
      <pubDate>Tue, 07 Nov 2023 21:14:10 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E4%BD%BF%E7%94%A8eqs%E5%AF%BB%E6%89%BE%E7%94%9F%E5%91%BD%E8%A1%A5%E7%BB%99/</guid>
      <description>说明 # AI / EQS / Find Health Pickup 概览 # EQS生成器 生成器限制条件 使用C++实现Decorator 暂时修改生命补给外观 # EQS标记也是亮色 Content &amp;gt; Materials 目录下选中 M_BaseColor 选择关卡中的BP_STUHealthPickup, 通过Details面板在蓝图编辑器中打开 BP_STUHealthPickup 选中 Static Mesh , 应用材质 回到关卡编辑器, 按住 Option 拖动BP_STUHealthPickup进行复制, 共三个 在场景中添加墙 Place Actors &amp;gt; Geometry &amp;gt; Box 设置墙; 将一个生命补给放在墙后 Details &amp;gt; Brush Settings , 设置X = 50, Y = 500, Z = 500 创建EQS资产 # Content/AI/EQS 目录下, 新建EQS资产, 命名为EQS_FindHealthPickup 添加生成器, 寻找场景中指定类型的Actor # Generators &amp;gt; Actors Of Class - Searched Actor Class 指定Actor类型 STUHealthPickup Search Radius 搜索半径 1500 设置场景中EQS_TestPawn使用的EQS模板 # Details &amp;gt; EQS &amp;gt; Query Template , 选择EQS_FindHealthPickup 移动EQS_TestPawn到合适位置, 三个生命补给均被标记为亮蓝色, 此时无视阻挡, 以搜索半径为准 为生成器添加限制条件: 要求视线可见 # Add Test &amp;gt; Trace 在Visibility通道计算Pawn到Actor之间是否存在其他物体阻挡视线 使用默认设置 - Trace &amp;gt; Trace Data &amp;gt; Trace Channel Visibility Trace &amp;gt; Trace Data &amp;gt; Trace Shape Line 勾选则要求阻挡 取消勾选则要求无阻挡 设置为无阻挡 - Filter &amp;gt; Bool Match 取消勾选 通道存在阻挡则Actor被标记为蓝色; 无阻挡被标记为绿色 为生成器添加限制条件: 寻找距离最近的生命补给 # Add Test &amp;gt; Distance - Filter &amp;gt; Filter Type Minimum Filter &amp;gt; Float Value Min 0 Score &amp;gt; Scoring Factor -1 距离越近, 权重越大 为生成器添加限制条件: 存在获取生命补给的有效路径 # Add Test &amp;gt; Path Finding 过滤掉无法去到的生命补给 使用默认设置 - Pathfinding &amp;gt; Test Mode Path Exists 在行为树中使用EQS_FindHealthPickup # 暂时停止当前逻辑 添加节点: Selector NPC寻找生命补给, 或等待 添加节点: Wait 设置时长为2s 添加序列 为序列添加任务: RunEQSQuery 设置EQS Details &amp;gt; EQS &amp;gt; EQSRequest &amp;gt; Query Template , 设置为EQS_FindHealthPickup Details &amp;gt; Blackboard &amp;gt; Blackboard Key , 设置为AimLocation 为序列添加任务: MoveTo Details &amp;gt; Blackboard &amp;gt; Blackboard Key , 设置为AimLocation 查看 # 在选中窗口运行 按下 F8 或者点击 Eject 拖动距离NPC最近的生命补给: NPC寻找并去到此时距离最近的生命补给位置 点击 Pause simulation , 将所有生命补给移动到墙后, 点击 Resume play-in-editor session 序列停止, NPC循环执行Wait任务 使用C++实现Decorator # 检查NPC生命值, 低于给定百分比NPC才会拾取生命补给 学习BTDecorator类 # 在CalculateRawConditionValue中计算条件布尔值 protected // calculates raw, core value of decorator&#39;s condition.</description>
    </item>
    
    <item>
      <title>让NPC移动到指定位置</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E8%AE%A9npc%E7%A7%BB%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Thu, 19 Oct 2023 19:05:23 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E8%AE%A9npc%E7%A7%BB%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/</guid>
      <description>说明 # AI Character / Controller / Navmesh 创建类 # NPC游戏角色 - 基类 STUBaseCharacter Public 路径 AI/ STUAICharacter 相应控制器 - 基类 AIController Public 路径 AI/ STUAIController 添加到头文件搜索路径 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { &amp;quot;ShootThemUp/Public/Player&amp;quot;, &amp;quot;ShootThemUp/Public/Components&amp;quot;, &amp;quot;ShootThemUp/Public/Dev&amp;quot;, &amp;quot;ShootThemUp/Public/Weapon&amp;quot;, &amp;quot;ShootThemUp/Public/UI&amp;quot;, &amp;quot;ShootThemUp/Public/Animations&amp;quot;, &amp;quot;ShootThemUp/Public/Pickups&amp;quot;, &amp;quot;ShootThemUp/Public/Weapon/Components&amp;quot;, &amp;quot;ShootThemUp/Public/AI&amp;quot; }); 创建文件夹 Content/AI 创建基于STUAICharacter和STUAIController的蓝图类, 添加前缀BP_ 配置BP_STUAICharacter # 参照BP_STUBaseCharacter 显示修改过的属性 设置属性时善用复制粘贴 对BP_AIBaseCharacter进行修改 生命值文本 网格体 设置动画蓝图类 健康组件 武器组件 为NPC使能AI # BP_STUAICharacter 允许该游戏角色直接添加到场景中或动态生成; 设置控制器类型 移除添加到场景中的BP_STUBaseCharacter, 添加BP_AIBaseCharacter 运行游戏, 正常生成NPC和AI控制器 让NPC移动到指定位置 # 设置地板大小 添加Actor到场景一角 Place Actors &amp;gt; Basic &amp;gt; Actor 双击打开BP_STUAIController 添加节点AIMoveTo, 在BeginPlay之后执行: 将控制器当前控制的游戏角色移动到目的地, 通过给出目的地座标或指示Actor 添加NavMeshBoundsVolume: 覆盖NPC移动区域 Place Actors &amp;gt; Volumes &amp;gt; NavMeshBoundsVolume 设置NavMeshBoundsVolume大小: 高度管控层级; 与场景中的其他网格体有交互 Details &amp;gt; Brush Settings 绿色高亮显示导航网格体的覆盖区域, 按下 P 显示 / 隐藏 Unreal Editor &amp;gt; Preference &amp;gt; General &amp;gt; Keyboard Shortcuts 优化榴弹爆炸特效 # Content/VFX/Projectile 烟雾和火球无法扩散, 将烟雾效果扩大, 火球效果缩小 NE_Burst NE_Fireball NE_Flash NE_Smoke Properties使能Local Space NE_Fireball # 分布半径 NE_Smoke # 粒子数 分布半径 NS_ProjectileExplosion # 优化步枪击中特效 # NE_CoreFast # NE_ShortBurst1 # NE_ShortBurst2 # </description>
    </item>
    
    <item>
      <title>初识行为树和黑板</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%88%9D%E8%AF%86%E8%A1%8C%E4%B8%BA%E6%A0%91%E5%92%8C%E9%BB%91%E6%9D%BF/</link>
      <pubDate>Thu, 19 Oct 2023 23:16:00 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%88%9D%E8%AF%86%E8%A1%8C%E4%B8%BA%E6%A0%91%E5%92%8C%E9%BB%91%E6%9D%BF/</guid>
      <description>说明 # Behavior Tree / Blackboard 在控制器对游戏角色行为逻辑进行描述 数学建模, 直接 非循环 图表, 可能的行为作为节点 虚幻引擎提供行为树编辑器使数学模型可视化 行为树是游戏角色的大脑: 设置了一系列的规则, 迁移条件 Transition , 和NPC状态 黑板作为数据库: 一系列变量, 当我们在代码中将其设置为不同值, 行为树会作出对应反应 创建行为树资产和黑板资产 # Content/AI 右键, Artificial Intelligence &amp;gt; Behavior Tree , 命名为BT_STUCharacter 右键, Artificial Intelligence &amp;gt; Blackboard , 命名为BB_STUCharacter 介绍行为树资产 # 双击打开BT_STUCharacter, 对游戏角色行为逻辑进行配置 行为树由控制节点组成, 任务作为叶子节点; 任务即游戏角色的直接动作 初始只有一个根节点, 作为行为树的入口 第二层有三个选项 - Sequence 按次序执行的多个任务序列 Selector Simple Parallel 第三层可以选任务 - MoveTo 找到路径去到指定位置; MoveAITo的另一种表示 Wait 游戏角色暂停指定秒数 MoveTo任务 # 在细节面板进行配置 Blackboard &amp;gt; Blackboard Key : 决定世界座标系的某个位置, 或者游戏角色将要移动到的Actor 使用黑板资产 # 通过 New Key 按钮添加各种类型变量 添加两个 Vector 类型变量: Location1和Location2; 将在这两点间移动 配置行为树资产 # 点击图表的空白处会显示细节面板, 设置黑板资产 添加节点: Sequence 添加任务: MoveTo 选中 MoveTo 节点, 可以在 Details &amp;gt; Blackboard &amp;gt; Blackboard Key 看到刚刚添加的变量, 选择Location1作为目的地 添加任务: Wait; 设置秒数为2 添加任务: MoveTo; 选择Location2作为目的地 添加任务: Wait; 设置秒数为2 当前NPC逻辑: &amp;gt; 去到Location1 &amp;gt; 等待2s &amp;gt; 去到Location2 &amp;gt; 等待2s; 循环 行为树从上到下、从左到右顺序执行; 左边的优先级更高 任务具有执行状态: 是否成功完成; 成功则运行下一个任务, 否则中止 设置AIController # 运行行为树 # 移除BP_STUAIController蓝图中的逻辑 添加节点: RunBehaviorTree; 在BeginPlay之后执行; 设置行为树资产 设置黑板中变量的位置值 # 在场景另一角添加Actor, 指示Location2 设置变量值: 对Location1和Location2进行设置 添加节点: GetBlackboard; 获取黑板指针 添加节点: SetValueAsVector; 对黑板中的变量进行设置 添加节点: MakeLiteralName; 给出变量名 根据两个指示Actor的座标, 填写到Location1和Location2 查看 # 保持行为树资产打开, 可以看见行为树逻辑执行的过程 按下 &#39; 显示调试信息; 按下小写键盘的数字关闭 / 打开AI该类别调试信息 切换到NPC # Shift-F1 释放鼠标 在世界大纲选中BP_STUAICharacter 按下 &#39; Active Task : NPC当前执行的任务 设置AI调试信息相关热键 # Hotkey 显示 / 关闭AI调试窗口 : Project Settings &amp;gt; Engine &amp;gt; Gameplay Debugger &amp;gt; Input &amp;gt; Activation Key ; 可以更换为F10 显示 / 关闭调试信息: Project Settings &amp;gt; Engine &amp;gt; Gameplay Debugger &amp;gt; Extensions &amp;gt; ToggleMessages ; 设置为Ctrl + Z; 原先和切换应用快捷键重复, 因而无法生效 释放鼠标 # 当运行模式为视口和新建编辑器窗口时, 可按下F8释放鼠标控制 </description>
    </item>
    
    <item>
      <title>在C&#43;&#43;中创建任务类型</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%9C%A8c&#43;&#43;%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 20 Oct 2023 20:45:42 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%9C%A8c&#43;&#43;%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E7%B1%BB%E5%9E%8B/</guid>
      <description>说明 # AI Task 在C++中生成随机点, 让NPC移动到随机生成位置 创建任务类型 # 创建蓝图任务类型的方法 BT_STUCharacter 点击 New Task C++ - 基类 BTTaskNode 路径 AI/Tasks/ Public STUNextLocationTask ShootThemUp: ShootThemUp.Build.cs 修改头文件搜索路径 PublicIncludePaths.AddRange(new string[] { &amp;quot;ShootThemUp/Public/Player&amp;quot;, &amp;quot;ShootThemUp/Public/Components&amp;quot;, &amp;quot;ShootThemUp/Public/Dev&amp;quot;, &amp;quot;ShootThemUp/Public/Weapon&amp;quot;, &amp;quot;ShootThemUp/Public/UI&amp;quot;, &amp;quot;ShootThemUp/Public/Animations&amp;quot;, &amp;quot;ShootThemUp/Public/Pickups&amp;quot;, &amp;quot;ShootThemUp/Public/Weapon/Components&amp;quot;, &amp;quot;ShootThemUp/Public/AI&amp;quot;, &amp;quot;ShootThemUp/Public/AI/Tasks&amp;quot; }); 添加依赖模块GameplayTasks和NavigationSystem PublicDependencyModuleNames.AddRange(new string[] { &amp;quot;Core&amp;quot;, &amp;quot;CoreUObject&amp;quot;, &amp;quot;Engine&amp;quot;, &amp;quot;InputCore&amp;quot;, &amp;quot;Niagara&amp;quot;, &amp;quot;PhysicsCore&amp;quot;, &amp;quot;GameplayCameras&amp;quot;, &amp;quot;GameplayTasks&amp;quot;, &amp;quot;NavigationSystem&amp;quot; }); 实现任务: 在给定半径圆形范围内生成随机点并设置变量 # 添加构造函数 ShootThemUp: AI/Tasks/STUNextLocationTask.h public USTUNextLocationTask(); 执行任务时调用ExecuteTask 覆写 ShootThemUp: AI/Tasks/STUNextLocationTask.h public virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent &amp;amp;OwnerComp, uint8 *NodeMemory) override; 添加属性 半径和黑板变量 ShootThemUp: AI/Tasks/STUNextLocationTask.</description>
    </item>
    
    <item>
      <title>在C&#43;&#43;中运行行为树和为NPC转向添加过渡</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%9C%A8c&#43;&#43;%E4%B8%AD%E8%BF%90%E8%A1%8C%E8%A1%8C%E4%B8%BA%E6%A0%91%E5%92%8C%E4%B8%BAnpc%E8%BD%AC%E5%90%91%E6%B7%BB%E5%8A%A0%E8%BF%87%E6%B8%A1/</link>
      <pubDate>Sat, 21 Oct 2023 20:42:48 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%9C%A8c&#43;&#43;%E4%B8%AD%E8%BF%90%E8%A1%8C%E8%A1%8C%E4%B8%BA%E6%A0%91%E5%92%8C%E4%B8%BAnpc%E8%BD%AC%E5%90%91%E6%B7%BB%E5%8A%A0%E8%BF%87%E6%B8%A1/</guid>
      <description>说明 # Smooth Character Rotation 在C++中运行行为树; NPC转向时有过渡 补充遗漏 # 让NPC移动到指定位置 那一节: 提供了允许游戏角色同时在场景中添加和代码中生成的方法; 以及在代码中设置AI控制器类的方法 添加构造函数 public ShootThemUp: AI/STUAICharacter.h ASTUAICharacter(const FObjectInitializer &amp;amp;ObjInit); ShootThemUp: AI/STUAICharacter.cpp #include &amp;quot;AI/STUAIController.h&amp;quot; ASTUAICharacter::ASTUAICharacter(const FObjectInitializer &amp;amp;ObjInit) : Super(ObjInit) { AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned; AIControllerClass = ASTUAIController::StaticClass(); } 在C++中运行行为树 # 添加属性: 保存行为树资产 可以作为控制器的逻辑, 也可以作为游戏角色的逻辑; 由于控制器控制多个游戏角色, 其有自己的行为树逻辑, 所以, 更适合放在游戏角色 public ShootThemUp: AI/STUAICharacter.h class UBehaviorTree; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) UBehaviorTree *BehaviorTreeAsset; 运行行为树 在OnPossess函数中; 在游戏中会被多次调用; 控制器每次切换游戏角色时调用 protected ShootThemUp: AI/STUAIController.h virtual void OnPossess(APawn *InPawn) override; ShootThemUp: AI/STUAIController.cpp #include &amp;quot;AI/STUAICharacter.</description>
    </item>
    
    <item>
      <title>视觉感知</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/</link>
      <pubDate>Thu, 26 Oct 2023 20:18:25 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/</guid>
      <description>说明 # AI Perception Component 允许NPC游戏角色感知给定范围内的世界中的其他Actor, 通过视觉和听觉感知敌人, 对伤害作出反应 本节为NPC添加视觉感知, 寻找与之最近的敌人, 使NPC面向该敌人 创建C++类 # - 基类 AIPerceptionComponent Components Public STUAIPerceptionComponent 为AIController添加感知组件 # 添加构造函数 ShootThemUp: AI/STUAIController.h public ASTUAIController(); 添加组件 ShootThemUp: AI/STUAIController.h protected class USTUAIPerceptionComponent; UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USTUAIPerceptionComponent *STUAIPerceptionComponent; 初始化组件 ShootThemUp: AI/STUAIController.cpp #include &amp;quot;Components/STUAIPerceptionComponent.h&amp;quot; ASTUAIController::ASTUAIController() { STUAIPerceptionComponent = CreateDefaultSubobject&amp;lt;USTUAIPerceptionComponent&amp;gt;(&amp;quot;STUPerceptionComponent&amp;quot;); SetPerceptionComponent(*STUAIPerceptionComponent); } 设置感知组件 # BP_STUAIController &amp;gt; STUAIPerceptionComponent &amp;gt; Details AI Perception &amp;gt; Senses Config : 对游戏角色的感官进行配置, 可以感知的有伤害, 听觉, 视觉等 添加AI视觉 # 选择 AI Sight config 设置捕捉可视半径为1000 Sense &amp;gt; Sight Radius 设置监控释放半径为1500 Sense &amp;gt; Lose Sight Radius 设置可视半角为60 Sense &amp;gt; PeripheralVisionHalfAngleDegrees 设置调试颜色为蓝色 Sense &amp;gt; Debug Color Sense &amp;gt; Detection by Affiliation , 勾选 Detect Enemies , Detect Neutrals , Detect Friendlies ; 当前没有分队别 设置MaxAge为1: Actor从视野中消失多久后不再保存相关信息 设置感官优先级 # 可以将 Sense &amp;gt; DominantSense 设置为None或 AISense_Sight 查看 # 关闭行为树 BP_STUCharactr 按下 Option , 左键点击箭头 UE4.</description>
    </item>
    
    <item>
      <title>自定义行为树服务</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Tue, 31 Oct 2023 18:43:41 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%9C%8D%E5%8A%A1/</guid>
      <description>说明 # AI Service / AIDecorator BTService # 添加到行为树节点的特殊类. 自带Tick函数, 在其中实现游戏逻辑. 在给定条件, 可以修改黑板中的变量值. 本节将通过服务重写定位敌人逻辑, 当敌人出现在NPC的捕捉范围内, 计算得到敌人附近一点, 使NPC跑去该位置. 可以添加到行为树的任意节点 添加黑板变量 # BB_STUCharacter 添加类型为Object的变量, 命名为EnemyActor; 存放选中敌人 创建行为树服务类 # - AI/Services 基类 BTService Public 名称 STUFindEnemyService 每秒搜索距离NPC最近的敌人 修改头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { &amp;quot;ShootThemUp/Public/Player&amp;quot;, &amp;quot;ShootThemUp/Public/Components&amp;quot;, &amp;quot;ShootThemUp/Public/Dev&amp;quot;, &amp;quot;ShootThemUp/Public/Weapon&amp;quot;, &amp;quot;ShootThemUp/Public/UI&amp;quot;, &amp;quot;ShootThemUp/Public/Animations&amp;quot;, &amp;quot;ShootThemUp/Public/Pickups&amp;quot;, &amp;quot;ShootThemUp/Public/Weapon/Components&amp;quot;, &amp;quot;ShootThemUp/Public/AI&amp;quot;, &amp;quot;ShootThemUp/Public/AI/Tasks&amp;quot;, &amp;quot;ShootThemUp/Public/AI/Services&amp;quot; }); 添加构造函数 # public ShootThemUp: AI/Services/STUFindEnemyService.h USTUFindEnemyService(); 设置服务名称 ShootThemUp: AI/Services/STUFindEnemyService.cpp USTUFindEnemyService::USTUFindEnemyService() { NodeName = &amp;quot;Find Enemy&amp;quot;; } 添加属性: 存放黑板变量信息 # protected ShootThemUp: AI/Services/STUFindEnemyService.</description>
    </item>
    
    <item>
      <title>射击服务</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%B0%84%E5%87%BB%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Tue, 31 Oct 2023 19:23:24 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%B0%84%E5%87%BB%E6%9C%8D%E5%8A%A1/</guid>
      <description>说明 # 自定义服务: 对距离最近敌人射击 创建服务类 # - base BTService Public AI/Services STUFireService 添加构造函数: 设置名称 # public ShootThemUp: AI/Services/STUFireService.h USTUFireService(); ShootThemUp: AI/Services/STUFireService.cpp USTUFireService::USTUFireService() { NodeName = &amp;quot;Fire&amp;quot;; } 添加属性: 存放敌人信息 # protected ShootThemUp: AI/Services/STUFireService.h UPROPERTY(EditAnywhere, BlueprintReadWrite) FBlackboardKeySelector EnemyActorKey; 服务逻辑: 实现TickNode # protected ShootThemUp: AI/Services/STUFireService.h virtual void TickNode(UBehaviorTreeComponent &amp;amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) override; 不需要检查EnemyActor的设置情况, 上节的Decorator提供检查; 还是推荐一个自给自足的逻辑闭环 ShootThemUp: AI/Services/STUFireService.cpp #include &amp;quot;BehaviorTree/BlackboardComponent.h&amp;quot; #include &amp;quot;AIController.h&amp;quot; #include &amp;quot;Components/STUWeaponComponent.h&amp;quot; #include &amp;quot;STUUtils.h&amp;quot; void USTUFireService::TickNode(UBehaviorTreeComponent &amp;amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) { const auto Controller = OwnerComp.</description>
    </item>
    
    <item>
      <title>NPC自行更换武器</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/npc%E8%87%AA%E8%A1%8C%E6%9B%B4%E6%8D%A2%E6%AD%A6%E5%99%A8/</link>
      <pubDate>Wed, 01 Nov 2023 17:25:14 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/npc%E8%87%AA%E8%A1%8C%E6%9B%B4%E6%8D%A2%E6%AD%A6%E5%99%A8/</guid>
      <description>说明 # AI Weapon Component 当前武器子弹耗尽时, 更换为仍有弹药的武器 查看当前NPC更换武器需求 # 调整武器顺序: 第一个为发射器 BP_STUAICharacter &amp;gt; WeaponComponent 拖动Index[1]到最上 修改发射器默认子弹数 BP_STULauncherWeapon &amp;gt; Details &amp;gt; Default Ammo 设置Clips = 2, Bullets = 1 修改步枪弹药库和伤害 BP_STURifleWeapon &amp;gt; Details Default Ammo 取消勾选 Infinite, 设置Clips = 3 设置DamageAmount = 0.0 查看: 射击完发射器榴弹后, 停止射击 NPC射击榴弹特效异常 # 在枪口处爆炸, 无移动 调试思路 # NPC和玩家游戏角色的区别, 刚好在上节子弹轨迹的修改; 上层控制器类型 GetPlayerViewPoint由 GetTraceData 调用: 能获取到ViewLocation和ViewRotation值 发射器MakeShot调用GetTraceData后, 调用 MakeHit 打印碰撞信息: 永远发生碰撞; 怀疑MuzzleSocket变换 输出碰撞点: 和枪口位置一致 将轨迹终点改为根据射程计算得到的终点: 轨迹和射击方向近乎垂直 原因 # MuzzleSocket变换配置存在失误; 已在 武器 &amp;gt; 榴弹类 更正 创建C++类 # - 基类 STUWeaponComponent 路径 Components Public 类名 STUAIWeaponComponent 调整武器基类接口的访问属性 # ShootThemUp: Weapon/STUBaseWeapon.</description>
    </item>
    
    <item>
      <title>随机更换武器服务</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E9%9A%8F%E6%9C%BA%E6%9B%B4%E6%8D%A2%E6%AD%A6%E5%99%A8%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Thu, 02 Nov 2023 21:48:43 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E9%9A%8F%E6%9C%BA%E6%9B%B4%E6%8D%A2%E6%AD%A6%E5%99%A8%E6%9C%8D%E5%8A%A1/</guid>
      <description>说明 # Homework - Change Weapon Service 和弹药耗尽更换武器性质不同; 使用当时实现的NextWeapon接口 NPC攻击时执行: 加入到Attack序列 设置参数, 生成随机数大于该值时不作操作 补充 # 应该在TickNode最后调用基类TickNode ShootThemUp: AI/Services/STUFireService.cpp // TickNode Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds); 创建服务类 # - 基类 BTService 路径 AI/Services 属性 Public 类名 STUChangeWeaponService 基本函数声明 # ShootThemUp: AI/Services/STUChangeWeaponService.h // public USTUChangeWeaponService(); // protected void TickNode(UBehaviorTreeComponent &amp;amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds); 构造函数实现: 设置服务名称 # ShootThemUp: AI/Services/STUChangeWeaponService.cpp USTUChangeWeaponService::USTUChangeWeaponService() { NodeName = &amp;quot;Change Weapon&amp;quot;; } TickNode框架 # ShootThemUp: AI/Services/STUChangeWeaponService.cpp void USTUChangeWeaponService::TickNode(UBehaviorTreeComponent &amp;amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) { // .</description>
    </item>
    
  </channel>
</rss>
