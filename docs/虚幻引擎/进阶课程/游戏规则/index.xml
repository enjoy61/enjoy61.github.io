<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>游戏规则 on </title>
    <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99/</link>
    <description>Recent content in 游戏规则 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 09 Nov 2023 20:47:53 +0000</lastBuildDate><atom:link href="https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>介绍游戏模式</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99/%E4%BB%8B%E7%BB%8D%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Nov 2023 20:42:45 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99/%E4%BB%8B%E7%BB%8D%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F/</guid>
      <description>Game Mode Overview 注意 # 当前运行游戏, 在地板中心位置会有火花特效, 不知什么原因 说明 # GameModeBase 对游戏进行设置和管理 游戏模式 Game Mode 根据游戏规则计算游戏分数, 调整游戏设置 Gameplay Setting , 玩家个数, AI玩家参与情况, 一个回合的时长, 回合总数, 如何判定游戏结束, 并计算各种游戏统计数据 BP_STUGameModeBase 对关卡各种基础类类型进行设置, 使用基类或覆写后的派生类, 游戏开始运行, 动态创建指定类对象 - Pawn HUD Player Controller Game State Player State Spectator GameMode的应用对象为给关卡 到目前为止, 我们都在使用默认关卡 本节会添加测试关卡 创建关卡 # File &amp;gt; New Level , 选择Basic, 命名为TestLevel, 保存到 Content/Levels 查看世界设置 World Settings , 可以看到各项都是默认设置, 即使用虚幻引擎提供的基类 运行, 世界大纲 World Outliner 中可以看到Actor列表和对应类型 - GameMode GameModeBase Pawn DefaultPawn 将游戏模式 Game Mode 设置为BP_STUGameModeBase, 则出现我们熟悉的游戏角色和HUD等 每个关卡都可以拥有自己的游戏模式, 而基本的游戏逻辑依旧存在 GameMode # GameMode派生自GameModeBase, 并扩展了额外功能 多玩家在游戏中匹配 Match State 逻辑 本课程会创建自己的匹配逻辑, 而不使用 GameModeBase GameModeBase # 会讲解该类的许多函数, 它们如何工作, 以何种顺序调用, 我们可以从游戏状态中获得何种信息, 如何暂停、重启游戏等 </description>
    </item>
    
    <item>
      <title>动态创建NPC</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAnpc/</link>
      <pubDate>Fri, 10 Nov 2023 16:59:54 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAnpc/</guid>
      <description>NPC Spawn 说明 # 在GameModeBase中动态创建NPC 添加数据结构: 存放游戏规则 # STUCoreTypes.h - 玩家个数 PlayersNum 包含玩家操控的游戏角色和NPC // game mode USTRUCT(BlueprintType) struct FGameData { GENERATED_USTRUCT_BODY() UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta = (ClampMin = &amp;quot;1&amp;quot;, ClampMax = &amp;quot;100&amp;quot;)) int32 PlayersNum = 2; }; 本章会逐步补充游戏规则 学习GameModeBase # StartPlay # 先于GameMode::BeginPlay和所有Actor::BeginPlay之前调用 在这里动态创建NPC // Transitions to calls BeginPlay on actors UFUNCTION(BlueprintCallable, Category=Game) virtual void StartPlay(); RestartPlayer # 通过控制器创建游戏角色, 游戏角色类型由游戏模式的默认Pawn类型决定, 游戏角色初始变换信息由场景中的PlayerStart决定 // Tries to spawn the player&#39;s pawn, at the location returned by FindPlayerStart UFUNCTION(BlueprintCallable, Category=Game) virtual void RestartPlayer(AController* NewPlayer); void AGameModeBase::RestartPlayer(AController* NewPlayer) { if (NewPlayer == nullptr || NewPlayer-&amp;gt;IsPendingKillPending()) { return; } AActor* StartSpot = FindPlayerStart(NewPlayer); // If a start spot wasn&#39;t found, if (StartSpot == nullptr) { // Check for a previously assigned spot if (NewPlayer-&amp;gt;StartSpot !</description>
    </item>
    
    <item>
      <title>游戏回合</title>
      <link>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99/%E6%B8%B8%E6%88%8F%E5%9B%9E%E5%90%88/</link>
      <pubDate>Wed, 15 Nov 2023 18:28:05 +0000</pubDate>
      
      <guid>https://enjoy61.github.io/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99/%E6%B8%B8%E6%88%8F%E5%9B%9E%E5%90%88/</guid>
      <description>Round Time / Rounds Num 说明 # 在StartPlay开启回合 使用定时器更新回合剩余时间, 开启下一回合, 通告游戏结束 修改游戏规则 # 设置回合数, 为回合指定时长. 目前设定的值是为了快速测试, 回合时长3s-5min STUCoreTypes.h UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta = (ClampMin = &amp;quot;1&amp;quot;, ClampMax = &amp;quot;10&amp;quot;)) int32 RoundsNum = 4; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta = (ClampMin = &amp;quot;3&amp;quot;, ClampMax = &amp;quot;300&amp;quot;)) int32 RoundTime = 10; // in seconds 在关卡中添加相关参数和接口 # private ShootThemUp: STUGameModeBase.h 当前回合 # int32 CurrentRound = 1; 当前回合剩余时间 # int32 RoundCountDown = 0; 定时器 # FTimerHandle GameRoundTimerHandle; 接口: 回合开始时调用 # void StartRound(); 接口: 定时器回调函数 # void GameTimerUpdate(); 实现接口 # ShootThemUp: STUGameModeBase.</description>
    </item>
    
  </channel>
</rss>
