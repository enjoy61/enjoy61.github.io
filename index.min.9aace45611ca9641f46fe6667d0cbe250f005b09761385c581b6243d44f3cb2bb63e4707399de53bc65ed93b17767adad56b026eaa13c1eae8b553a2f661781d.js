var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BB%E7%BC%96%E8%BE%91%E5%99%A8/%E4%B8%BA%E9%AA%A8%E9%AA%BC%E7%BD%91%E6%A0%BC%E4%BD%93%E6%B7%BB%E5%8A%A0%E6%8C%82%E8%BD%BD%E7%82%B9/",title:"为骨骼网格体添加挂载点",description:"说明 # - 骨骼网格体 HeroTPP: Content/ExternalContent/Animation/Characters/HeroTPP/HeroTPP.uasset 挂载点上级骨骼 b_Right_Weapon 挂载点名称 WeaponSocket Socket # 骨骼网格体中的特殊物体 Object ，可以为任何骨骼添加Socket Socket的实质是骨骼网格体中的命名变换，可以在蓝图和C++中获取 骨骼的Socket有多种用途，我们可以在Socket附加武器，用作集火点, 也可以通过Socket名称获取变换信息 在骨骼网格体上添加挂载点 # 打开HeroTPP # 方法一: 双击打开 方法二: 打开BP_STUBaseCharacter, 选择SkeletalMesh组件, 去到细节面板双击HeroTPP 查看骨骼网格体 # 左侧骨骼树面板，选中骨骼，可以在右侧细节面板查看骨骼的相对变换 可以是虚拟骨骼，无图形表示，具有变换属性: 如b_RightWeapon 为骨骼添加挂载点 # 选中b_RightWeapon，右键 \u0026gt; Add Socket 设置挂载点参数 # Details 选中Socket，在右侧细节面板设置参数 - Socket Name WeaponSocket Relative Rotation X: -90 为挂载点添加预览模型 # WeaponSocket \u0026gt; Add Preview Asset \u0026gt; Rifle 在多种资产中预览挂载效果 # 举例 - HeroTPP_Skeleton 骨骼 HeroTPP 骨骼网格体 BS_Locomotion_Run 动画资产 ABP_BaseCharacter 动画蓝图 HeroTPP_Physics 通过编辑器的选项卡, 选择资产类型 动画资产 动画蓝图 ",content:"说明 # - 骨骼网格体 HeroTPP: Content/ExternalContent/Animation/Characters/HeroTPP/HeroTPP.uasset 挂载点上级骨骼 b_Right_Weapon 挂载点名称 WeaponSocket Socket # 骨骼网格体中的特殊物体 Object ，可以为任何骨骼添加Socket Socket的实质是骨骼网格体中的命名变换，可以在蓝图和C++中获取 骨骼的Socket有多种用途，我们可以在Socket附加武器，用作集火点, 也可以通过Socket名称获取变换信息 在骨骼网格体上添加挂载点 # 打开HeroTPP # 方法一: 双击打开 方法二: 打开BP_STUBaseCharacter, 选择SkeletalMesh组件, 去到细节面板双击HeroTPP 查看骨骼网格体 # 左侧骨骼树面板，选中骨骼，可以在右侧细节面板查看骨骼的相对变换 可以是虚拟骨骼，无图形表示，具有变换属性: 如b_RightWeapon 为骨骼添加挂载点 # 选中b_RightWeapon，右键 \u0026gt; Add Socket 设置挂载点参数 # Details 选中Socket，在右侧细节面板设置参数 - Socket Name WeaponSocket Relative Rotation X: -90 为挂载点添加预览模型 # WeaponSocket \u0026gt; Add Preview Asset \u0026gt; Rifle 在多种资产中预览挂载效果 # 举例 - HeroTPP_Skeleton 骨骼 HeroTPP 骨骼网格体 BS_Locomotion_Run 动画资产 ABP_BaseCharacter 动画蓝图 HeroTPP_Physics 通过编辑器的选项卡, 选择资产类型 动画资产 动画蓝图 "}),e.add({id:1,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/interval%E6%A8%A1%E6%9D%BF%E7%B1%BB/",title:"Interval模板类",description:"TInterval # 模板类型，由两个元素组成，通常用来存放区间，端点Min和Max。 UE_5.1/Engine/Source/Runtime/Core/Public/Math/Interval.h TInterval::Min 和 TInterval::Max # 存放区间 ",content:"TInterval # 模板类型，由两个元素组成，通常用来存放区间，端点Min和Max。 UE_5.1/Engine/Source/Runtime/Core/Public/Math/Interval.h TInterval::Min 和 TInterval::Max # 存放区间 "}),e.add({id:2,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E5%85%B3%E5%8D%A1%E8%AE%BE%E7%BD%AE/hud%E7%B1%BB/",title:"HUD类",description:"AHUD # Head Up Display 在世界设置中，可设置关卡使用HUD类 负责渲染接口，使之始终显示在游戏的最上方, 属于UI范畴 其功能很多都可被widget代替 UE_5.1/Engine/Source/Runtime/Engine/Classes/GameFramework/HUD.h AHUD::DrawHUD # HUD类主要循环函数，负责渲染，每帧调用 我们在其中绘制所需元素，线，长方形，显示纹理和文本，等等 AHUD::DrawLine # 在屏幕上绘制线条 参数 # - StartScreenX, StartScreenY 起点在屏幕的X和Y坐标 EndScreenX，EndScreenY 终点在屏幕的X和Y坐标 LineColor 线条颜色 LineThickness 线条粗细 AHUD::Canvas # 指针，指向可绘制HUD的画布（当前屏幕） 获取屏幕相关信息，或直接通过Canvas绘制图元 ",content:"AHUD # Head Up Display 在世界设置中，可设置关卡使用HUD类 负责渲染接口，使之始终显示在游戏的最上方, 属于UI范畴 其功能很多都可被widget代替 UE_5.1/Engine/Source/Runtime/Engine/Classes/GameFramework/HUD.h AHUD::DrawHUD # HUD类主要循环函数，负责渲染，每帧调用 我们在其中绘制所需元素，线，长方形，显示纹理和文本，等等 AHUD::DrawLine # 在屏幕上绘制线条 参数 # - StartScreenX, StartScreenY 起点在屏幕的X和Y坐标 EndScreenX，EndScreenY 终点在屏幕的X和Y坐标 LineColor 线条颜色 LineThickness 线条粗细 AHUD::Canvas # 指针，指向可绘制HUD的画布（当前屏幕） 获取屏幕相关信息，或直接通过Canvas绘制图元 "}),e.add({id:3,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E5%85%B3%E5%8D%A1%E8%AE%BE%E7%BD%AE/gamemodebase%E7%B1%BB/",title:"GameModeBase类",description:"AGameModeBase # 关卡类 AGameModeBase::HUDClass # 设置关卡使用HUD类 ",content:"AGameModeBase # 关卡类 AGameModeBase::HUDClass # 设置关卡使用HUD类 "}),e.add({id:4,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/engine/canvas%E7%B1%BB/",title:"Canvas类",description:"UCanvas # 画布 UE_5.1/Engine/Source/Runtime/Engine/Classes/Engine/Canvas.h 头文件 #include \u0026quot;Engine/Canvas.h\u0026quot; UCanvas::SizeX 和 UCanvas::SizeY # 画布长宽 ",content:"UCanvas # 画布 UE_5.1/Engine/Source/Runtime/Engine/Classes/Engine/Canvas.h 头文件 #include \u0026quot;Engine/Canvas.h\u0026quot; UCanvas::SizeX 和 UCanvas::SizeY # 画布长宽 "}),e.add({id:5,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E8%BF%90%E8%A1%8Cshootergame%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE/",title:"运行ShooterGame示例项目",description:"下载ShooterGame # Epic Games Launcher \u0026gt; Samples \u0026gt; Shooter Game 支持引擎版本 4.0 - 4.27 ，当前使用引擎版本 5.1.1 修改源码 # 退化类 # UMatineeCameraShake 已被 ULegacyCameraShake 替代 不再支持的宏 # PLATFORM_PS4 改法一: 定义该宏 # 在引擎代码中，紧接着 SWITCH 定义该宏 改法二: 屏蔽该宏的出现 # 条件运算符第二个和第三个操作数类型不一致, 且可以互相转换 # 参考 AController * 和 AActor * 可以相互转换，此处有歧义 Source/ShooterGame/Private/Player/ShooterCharacter.cpp:322 运行效果 # ",content:"下载ShooterGame # Epic Games Launcher \u0026gt; Samples \u0026gt; Shooter Game 支持引擎版本 4.0 - 4.27 ，当前使用引擎版本 5.1.1 修改源码 # 退化类 # UMatineeCameraShake 已被 ULegacyCameraShake 替代 不再支持的宏 # PLATFORM_PS4 改法一: 定义该宏 # 在引擎代码中，紧接着 SWITCH 定义该宏 改法二: 屏蔽该宏的出现 # 条件运算符第二个和第三个操作数类型不一致, 且可以互相转换 # 参考 AController * 和 AActor * 可以相互转换，此处有歧义 Source/ShooterGame/Private/Player/ShooterCharacter.cpp:322 运行效果 # "}),e.add({id:6,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%94%9F%E5%91%BD%E5%80%BC/",title:"实时显示游戏角色生命值",description:"概览 # - 健康组件 ActorComponent 自定义，纯逻辑 文本组件 TextRenderComponent 显示生命值 创建健康组件 # 创建Component/STUHealthComponent # 虚幻编辑器 ActorComponent 公有类 调整健康组件框架 # C++ ShootThemUp: Components/STUHealthComponent.h ShootThemUp: Components/STUHealthComponent.cpp - 默认构造函数 将每帧调用TickComponent函数标志置为false BeginPlay TickComponent 屏蔽，使用基类实现 实现 # 添加生命值上限 # protected ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1000.0\u0026quot;)) float MaxHealth = 100.0f;	添加生命值 # private ShootThemUp: Components/STUHealthComponent.h float Health = 0.0f; 初始化生命值 # ShootThemUp: Components/STUHealthComponent.cpp // BeginPlay Health = MaxHealth; 添加接口，返回生命值 # public ShootThemUp: Components/STUHealthComponent.",content:"概览 # - 健康组件 ActorComponent 自定义，纯逻辑 文本组件 TextRenderComponent 显示生命值 创建健康组件 # 创建Component/STUHealthComponent # 虚幻编辑器 ActorComponent 公有类 调整健康组件框架 # C++ ShootThemUp: Components/STUHealthComponent.h ShootThemUp: Components/STUHealthComponent.cpp - 默认构造函数 将每帧调用TickComponent函数标志置为false BeginPlay TickComponent 屏蔽，使用基类实现 实现 # 添加生命值上限 # protected ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1000.0\u0026quot;)) float MaxHealth = 100.0f;	添加生命值 # private ShootThemUp: Components/STUHealthComponent.h float Health = 0.0f; 初始化生命值 # ShootThemUp: Components/STUHealthComponent.cpp // BeginPlay Health = MaxHealth; 添加接口，返回生命值 # public ShootThemUp: Components/STUHealthComponent.h UFUNCTION(BlueprintCallable) float GetHealth() const { return Health; } 为游戏角色添加健康组件 # C++ 添加STUHealthComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h class USTUHealthComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USTUHealthComponent *HealthComponent; 初始化组件: STUHealthComponent无表示，不用设置上级组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/STUHealthComponent.h\u0026quot; // 构造函数 HealthComponent = CreateDefaultSubobject\u0026lt;USTUHealthComponent\u0026gt;(\u0026quot;HealthComponent\u0026quot;); 为游戏角色添加文本组件 # C++ 添加UTextRenderComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h class UTextRenderComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UTextRenderComponent *HealthTextComponent;	初始化组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/TextRenderComponent.h\u0026quot; // 构造函数 HealthTextComponent = CreateDefaultSubobject\u0026lt;UTextRenderComponent\u0026gt;(\u0026quot;HealthTextComponent\u0026quot;); HealthTextComponent-\u0026gt;SetupAttachment(GetRootComponent()); 每帧更新HealthTextComponent文本 ShootThemUp: Player/STUBaseCharacter.cpp // Tick HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); 检查组件是否成功初始化 # 使用IDE编译时，若运行游戏崩溃，可在IDE中查看断点 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay check(HealthComponent); check(HealthTextComponent); 调整文本组件 # 虚幻编辑器 BP_STUBaseCharacter 查看组件 # HealthComponent和CharacterMovement无层级：二者均无表示，纯逻辑；创建后无需挂在其他组件下面 查看HealthComponent # 调整TextRender组件 # - Tranform Z: 100 Yaw: 180 第三视角：运行时摄像机对着 Character 背面 Text 0 默认值 Horizontal Alignment Center 水平对齐 Text Render Color 深蓝色 文本颜色 效果图 # "}),e.add({id:7,href:"/docs/%E5%88%86%E4%BA%AB/macos%E5%BA%94%E7%94%A8/%E7%BB%88%E7%AB%AF/",title:"终端",description:"iTerm2 # 官网下载 窗口管理 # 快捷键 操作 Command-W 关闭窗口 分屏 # 快捷键 操作 Command-D 左右分屏 Command-Shift-D 上下分屏 Command-[ 切换 Command-] Option-Command-UP 根据方向键切换 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 # 快捷键 操作 Command-T 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right 状态栏 # Status Bar 使能 # Preferences \u0026gt; Profiles \u0026gt; Session 勾选 Status bar enabled 点击 Configure Status Bar , 选择显示组件 设置状态栏位置 # Preferences \u0026gt; Appearence \u0026gt; General \u0026gt; Status bar location 选择 Bottom 配色 # 下载配色 # - 官方提供的配色 : lovelace Afterglow Dracula 导入配色 # Preferences \u0026gt; Profiles \u0026gt; Color \u0026gt; Color Presets \u0026gt; Import 设置窗口大小 # Preferences \u0026gt; Profiles \u0026gt; Window 设置 Columns 和 Rows 透明度 # Preferences \u0026gt; Profiles \u0026gt; Window \u0026gt; Transparency 选择 3 字体 # 下载字体 # - Consolas Victor Mono 配置 # Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Font 选择 Victor Mono 字号选择 14 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 安装Homebrew # /bin/bash -c \u0026quot;$(curl -fsSL https://mirrors.",content:"iTerm2 # 官网下载 窗口管理 # 快捷键 操作 Command-W 关闭窗口 分屏 # 快捷键 操作 Command-D 左右分屏 Command-Shift-D 上下分屏 Command-[ 切换 Command-] Option-Command-UP 根据方向键切换 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 # 快捷键 操作 Command-T 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right 状态栏 # Status Bar 使能 # Preferences \u0026gt; Profiles \u0026gt; Session 勾选 Status bar enabled 点击 Configure Status Bar , 选择显示组件 设置状态栏位置 # Preferences \u0026gt; Appearence \u0026gt; General \u0026gt; Status bar location 选择 Bottom 配色 # 下载配色 # - 官方提供的配色 : lovelace Afterglow Dracula 导入配色 # Preferences \u0026gt; Profiles \u0026gt; Color \u0026gt; Color Presets \u0026gt; Import 设置窗口大小 # Preferences \u0026gt; Profiles \u0026gt; Window 设置 Columns 和 Rows 透明度 # Preferences \u0026gt; Profiles \u0026gt; Window \u0026gt; Transparency 选择 3 字体 # 下载字体 # - Consolas Victor Mono 配置 # Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Font 选择 Victor Mono 字号选择 14 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 安装Homebrew # /bin/bash -c \u0026quot;$(curl -fsSL https://mirrors.ustc.edu.cn/misc/brew-install.sh)\u0026quot; 设置源 # 源代码仓库 export HOMEBREW_BREW_GIT_REMOTE=\u0026quot;https://mirrors.ustc.edu.cn/brew.git\u0026quot; 预编译二进制软件包与软件包元数据文件 export HOMEBREW_BOTTLE_DOMAIN=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-bottles\u0026quot; export HOMEBREW_API_DOMAIN=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-bottles/api\u0026quot; 核心软件仓库 export HOMEBREW_CORE_GIT_REMOTE=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026quot; 写入配置文件, 重新导入 vi ～/.zshrc source ～/.zshrc 管理软件 # 默认下载源码在本地编译安装，通常是不带界面的命令行工具和第三方库; 使用cask选项则安装编译好的软件包，通常是一些带界面的软件 安装/卸载 # brew install --cask emacs # 安装 brew uninstall --cask emacs # 卸载 brew install \u0026lt;package\u0026gt; brew uninstall \u0026lt;package\u0026gt; brew autoremove # 卸载未使用依赖 查看 # brew list # 当前管理的程序 brew search \u0026lt;package\u0026gt; # 查找 brew info \u0026lt;package\u0026gt; # 查看包 代理 # Privoxy 安装Privoxy # 依赖pcre brew install privoxy 配置Privoxy # Privoxy使用端口号8118 vi /usr/local/etc/privoxy/config # 在文件末尾添加以下代码 listen-address 0.0.0.0:8118 forward-socks5 / localhost:1080 . 手动启动Privoxy sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config 查看端口是否被监听 netstat -na | grep 8118 为终端配置代理 # 查询本地代理使用端口 系统偏好设置 \u0026gt; 网络 \u0026gt; Wi-Fi \u0026gt; 高级 \u0026gt; 代理 \u0026gt; 网页代理 / 安全网页代理 配置环境变量 vi ~/.zshrc # 添加以下内容 # 使用本地代理使用端口替换1949 export http_proxy='http://localhost:1949' export https_proxy=$http_proxy # 重载配置文件 source ~/.zshrc oh-my-zsh # 官网 安装oh-my-zsh # sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; 设置主题 # 第三方主题 # 下载Dracula主题 ln -s Dracula/zsh/dracula.zsh-theme ~/.oh-my-zsh/themes/ 设置主题 vi ~/.zshrc # 屏蔽默认主题, 添加以下内容 # ZSH_THEME=\u0026quot;robbyrussell\u0026quot; ZSH_THEME=\u0026quot;dracula\u0026quot; # 载入配置 source ~/.zshrc 官方主题 # 下载时已存放在本地 官方主题展示 使用随机主题 ZSH_THEME=\u0026quot;random\u0026quot; # 随机 "}),e.add({id:8,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/bash/",title:"Shell脚本",description:"花括号的使用 # 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这样使用，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 tr命令 # runoob 去除引号 # tr -d '\u0026quot;' 使用sed sed 's/\\\u0026quot;//g' sed命令 # macOS runoob 安装gsed # brew install gsed 匹配行打印 # p gsed -n \u0026quot;/abc/p\u0026quot; file 修改源文件 # -i gsed -i \u0026quot;/abc/d\u0026quot; file # 匹配行删除 匹配行删除 # d gsed \u0026quot;/abc/d\u0026quot; file 匹配行文本替换 # s 首个匹配项 gsed \u0026quot;s/abc/edf/\u0026quot; file 所有匹配项 g gsed \u0026quot;s/abc/edf/g\u0026quot; file awk命令 # 指定分隔符，打印第3个参数 # awk -F ',' '{print $3}' file命令 # 查看文件编码 # file FILE echo命令 # 输出单行 # var=\u0026quot;hello world!",content:"花括号的使用 # 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这样使用，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 tr命令 # runoob 去除引号 # tr -d '\u0026quot;' 使用sed sed 's/\\\u0026quot;//g' sed命令 # macOS runoob 安装gsed # brew install gsed 匹配行打印 # p gsed -n \u0026quot;/abc/p\u0026quot; file 修改源文件 # -i gsed -i \u0026quot;/abc/d\u0026quot; file # 匹配行删除 匹配行删除 # d gsed \u0026quot;/abc/d\u0026quot; file 匹配行文本替换 # s 首个匹配项 gsed \u0026quot;s/abc/edf/\u0026quot; file 所有匹配项 g gsed \u0026quot;s/abc/edf/g\u0026quot; file awk命令 # 指定分隔符，打印第3个参数 # awk -F ',' '{print $3}' file命令 # 查看文件编码 # file FILE echo命令 # 输出单行 # var=\u0026quot;hello world!\u0026quot; echo $var 输出多行 # echo -e \u0026quot;\\nhello world!\\n\u0026quot; head命令 # 安装coreutils # brew install coreutils 输出文件去掉末尾4行的文本 # ghead -n -4 xx.txt "}),e.add({id:9,href:"/docs/brick/%E7%BB%88%E7%AB%AF/",title:"终端",description:"便签 # 介绍CLI，Terminal，Shell和Prompt视频 shell概念 # 接口 shell，和core相区分，是操作系统的外层。通过Shell程序，可以使用系统服务或其他程序提供的功能。 根据操作系统类别和操作类型，shell可以分为图形shell（图形用户界面）和命令行shell（命令行界面）。 CLI Command-Line Interface 命令行界面 通过文本命令和计算机交互 GUI Graphical User Interface 图形用户界面 通过鼠标操作 早期的操作系统并没有图形用户接口，我们通常说的shell，指的是命令行shel。 终端程序 # Terminal Wrapper Program 在终端输入文本命令 终端程序 说明 iTerm MacOS Windows Terminal Windows Gnome Terminal 使用Gnome作为桌面的Linux自带的终端程序 Hyper Warp 目前MacOS；自动补全，鼠标交互，内置工作流，AI功能 Alacrity 命令解释器 # Shell 程序 终端中运行的程序。接受命令，然后解释并执行。 Shell启动时自动读取配置文件。 Shell 说明 sh Bourne Shell UNIX上的标准shell bash Bourne-Again Shell GNU开发；Linux默认 不完全兼容sh shell，对一些命令和参数进行了扩展 配置文件 ~/.bash_profile zsh 19年之前MacOS默认Bash；之后使用zsh 配置文件 ~/zshrc 第三方框架oh-my-zsh提供其他功能 phish 脚本语言 # 需要解释器，每次运行时都需要解释。 - JavaScript PHP Lua Python C# Shell脚本 # 开发语言 Shell Script 由一连串Shell命令组成，可以指定解释脚本的Shell程序。 命令提示符 # Prompt 命令解释器提供并在终端显示，如当前路径和git信息。 类别 第三方提示 Powerline Starship Power Level 10K Spaceship 第三方框架 oh-my-zsh 提供各种promots，configuration options，aliases，plugins。支持自定义prompt，调整Shell行为 查看Shell信息 # 命令解释器 当前使用的Shell echo $SHELL echo $0 已安装Shell cat /etc/shells Shell操作 # 切换Shell程序 重新打开终端生效 chsh -s /bin/bash 不修改SHELL环境变量 zsh 手动读取配置文件 zsh source ~/.",content:"便签 # 介绍CLI，Terminal，Shell和Prompt视频 shell概念 # 接口 shell，和core相区分，是操作系统的外层。通过Shell程序，可以使用系统服务或其他程序提供的功能。 根据操作系统类别和操作类型，shell可以分为图形shell（图形用户界面）和命令行shell（命令行界面）。 CLI Command-Line Interface 命令行界面 通过文本命令和计算机交互 GUI Graphical User Interface 图形用户界面 通过鼠标操作 早期的操作系统并没有图形用户接口，我们通常说的shell，指的是命令行shel。 终端程序 # Terminal Wrapper Program 在终端输入文本命令 终端程序 说明 iTerm MacOS Windows Terminal Windows Gnome Terminal 使用Gnome作为桌面的Linux自带的终端程序 Hyper Warp 目前MacOS；自动补全，鼠标交互，内置工作流，AI功能 Alacrity 命令解释器 # Shell 程序 终端中运行的程序。接受命令，然后解释并执行。 Shell启动时自动读取配置文件。 Shell 说明 sh Bourne Shell UNIX上的标准shell bash Bourne-Again Shell GNU开发；Linux默认 不完全兼容sh shell，对一些命令和参数进行了扩展 配置文件 ~/.bash_profile zsh 19年之前MacOS默认Bash；之后使用zsh 配置文件 ~/zshrc 第三方框架oh-my-zsh提供其他功能 phish 脚本语言 # 需要解释器，每次运行时都需要解释。 - JavaScript PHP Lua Python C# Shell脚本 # 开发语言 Shell Script 由一连串Shell命令组成，可以指定解释脚本的Shell程序。 命令提示符 # Prompt 命令解释器提供并在终端显示，如当前路径和git信息。 类别 第三方提示 Powerline Starship Power Level 10K Spaceship 第三方框架 oh-my-zsh 提供各种promots，configuration options，aliases，plugins。支持自定义prompt，调整Shell行为 查看Shell信息 # 命令解释器 当前使用的Shell echo $SHELL echo $0 已安装Shell cat /etc/shells Shell操作 # 切换Shell程序 重新打开终端生效 chsh -s /bin/bash 不修改SHELL环境变量 zsh 手动读取配置文件 zsh source ~/.zshrc 指定Shell脚本的命令解释器 #!/bin/bash "}),e.add({id:10,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BB%E7%BC%96%E8%BE%91%E5%99%A8/%E7%A2%B0%E6%92%9E%E9%80%89%E9%A1%B9/",title:"碰撞选项",description:"概览 # Details \u0026gt; Collision API 碰撞预设 碰撞使能选项 物体类型 碰撞反馈 产生重叠事件 产生碰撞事件 碰撞预设 # Collision Presets 专注自定义选项 Custom 提供多种选项 # 默认面板 # Default 自定义面板 # Custom 查看碰撞预设定义 # 项目设置 \u0026gt; Engine \u0026gt; Collision 支持自定义预设, 对碰撞使能选项, 物体类型, 碰撞反馈进行设置; 可以对已有预设进行修改 碰撞使能选项 # Collision Enabled - No Collision 不产生碰撞 Query Only (No Physics Collision) 只参与轨迹计算 Logical Trace : 参与给定线段与物体相交计算 Physics Only (No Query Collision) 只用于物理仿真 Physical Simulation : 穿过或被阻挡 Collision Enabled (Query and Physics) 轨迹计算 + 物理仿真 物体类型 # Object Type 对该物体的物体类型进行设置, 其他物体依据该属性作出反馈 碰撞反馈 # Collision Responses 产生碰撞时, 如何给出反馈; 通过交互矩阵 Interaction Matrix 实现 反馈类型 # - Ignore 不会发生碰撞 Overlap 重叠: 可以发生碰撞, 允许通过, 可以产生重叠事件 Block 阻碍: 可以发生碰撞, 形成阻碍, 可以产生碰撞事件 对通道的反馈 # Trace Responses 是否参与该通道的轨迹计算 - Visibility 给定线段起点和终点 Camera Camera组件 对其他物体类型的反馈 # Object Responses 对其他物体类型作出何种反馈 - WorldStatic WorldDynamic Pawn \u0026hellip; 发生碰撞时产生重叠事件 # Generate Overlap Events 出于优化考虑, 默认false 勾选后, 发生碰撞会产生重叠事件, 可以在蓝图中对该类型事件进行处理 发生碰撞时产生碰撞事件 # Simulation Generates Hit Events 出于优化考虑, 默认false 勾选后, 发生碰撞会产生碰撞事件, 可以获取碰撞信息 ",content:"概览 # Details \u0026gt; Collision API 碰撞预设 碰撞使能选项 物体类型 碰撞反馈 产生重叠事件 产生碰撞事件 碰撞预设 # Collision Presets 专注自定义选项 Custom 提供多种选项 # 默认面板 # Default 自定义面板 # Custom 查看碰撞预设定义 # 项目设置 \u0026gt; Engine \u0026gt; Collision 支持自定义预设, 对碰撞使能选项, 物体类型, 碰撞反馈进行设置; 可以对已有预设进行修改 碰撞使能选项 # Collision Enabled - No Collision 不产生碰撞 Query Only (No Physics Collision) 只参与轨迹计算 Logical Trace : 参与给定线段与物体相交计算 Physics Only (No Query Collision) 只用于物理仿真 Physical Simulation : 穿过或被阻挡 Collision Enabled (Query and Physics) 轨迹计算 + 物理仿真 物体类型 # Object Type 对该物体的物体类型进行设置, 其他物体依据该属性作出反馈 碰撞反馈 # Collision Responses 产生碰撞时, 如何给出反馈; 通过交互矩阵 Interaction Matrix 实现 反馈类型 # - Ignore 不会发生碰撞 Overlap 重叠: 可以发生碰撞, 允许通过, 可以产生重叠事件 Block 阻碍: 可以发生碰撞, 形成阻碍, 可以产生碰撞事件 对通道的反馈 # Trace Responses 是否参与该通道的轨迹计算 - Visibility 给定线段起点和终点 Camera Camera组件 对其他物体类型的反馈 # Object Responses 对其他物体类型作出何种反馈 - WorldStatic WorldDynamic Pawn \u0026hellip; 发生碰撞时产生重叠事件 # Generate Overlap Events 出于优化考虑, 默认false 勾选后, 发生碰撞会产生重叠事件, 可以在蓝图中对该类型事件进行处理 发生碰撞时产生碰撞事件 # Simulation Generates Hit Events 出于优化考虑, 默认false 勾选后, 发生碰撞会产生碰撞事件, 可以获取碰撞信息 "}),e.add({id:11,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%BB%99%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A3%85%E8%BD%BD%E6%AD%A6%E5%99%A8/",title:"给游戏角色装载武器",description:"概览 # 导入武器相关资产 创建武器类STUBaseWeapon和BP_STUBaseWeapon 为STUBaseWeapon添加骨骼网格体, 绑定武器模型 武器模型 说明 Launcher 发射导弹 Rifle 发射子弹 Shoot Regular Cartridges 为游戏角色骨骼网格体添加挂载点, 动态创建武器对象并挂载到游戏角色 导入武器相关资产 # 虚幻编辑器 之前将资产导入到Content/ExternalContent/Animation，有两点需注意 资产之前存在相互引用，这个在Migrate过程中，不一定会全无问题 我们选择Migrate ShooterGame/Content/Animations/TTP_Animations ，而实际导出有多个文件夹，里面的内容都和TTP_Animations有关 本节需要Migrate的武器资产，其相关内容与之前的内容有重叠; 和之前一样, 在ExternalContent下单独创建一个文件夹，存放本次导入资产 从ShooterGame导出 # 选中Content/Weapons \u0026gt; Migrate 相关文件存放在Characters，Environment和Weapons中 保存到ShootThemUp/Content 导入到ShootThemUp # 创建ExternalContent/Weapon，并设置文件夹颜色 将资产移动到ExternalContent/Weapon 创建武器类 # 初始化C++类: STUBaseWeapon # 创建C++类: Weapon/STUBaseWeapon # 虚幻编辑器 Actor 公有类 设置头文件路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot; }); 调整框架 # C++ - 构造函数 每帧调用置为false Tick 屏蔽 BeginPlay - ShootThemUp: Weapon/STUBaseWeapon.",content:"概览 # 导入武器相关资产 创建武器类STUBaseWeapon和BP_STUBaseWeapon 为STUBaseWeapon添加骨骼网格体, 绑定武器模型 武器模型 说明 Launcher 发射导弹 Rifle 发射子弹 Shoot Regular Cartridges 为游戏角色骨骼网格体添加挂载点, 动态创建武器对象并挂载到游戏角色 导入武器相关资产 # 虚幻编辑器 之前将资产导入到Content/ExternalContent/Animation，有两点需注意 资产之前存在相互引用，这个在Migrate过程中，不一定会全无问题 我们选择Migrate ShooterGame/Content/Animations/TTP_Animations ，而实际导出有多个文件夹，里面的内容都和TTP_Animations有关 本节需要Migrate的武器资产，其相关内容与之前的内容有重叠; 和之前一样, 在ExternalContent下单独创建一个文件夹，存放本次导入资产 从ShooterGame导出 # 选中Content/Weapons \u0026gt; Migrate 相关文件存放在Characters，Environment和Weapons中 保存到ShootThemUp/Content 导入到ShootThemUp # 创建ExternalContent/Weapon，并设置文件夹颜色 将资产移动到ExternalContent/Weapon 创建武器类 # 初始化C++类: STUBaseWeapon # 创建C++类: Weapon/STUBaseWeapon # 虚幻编辑器 Actor 公有类 设置头文件路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot; }); 调整框架 # C++ - 构造函数 每帧调用置为false Tick 屏蔽 BeginPlay - ShootThemUp: Weapon/STUBaseWeapon.h ShootThemUp: Weapon/STUBaseWeapon.cpp 添加骨骼网格体组件, 用来绑定武器模型 # C++ USkeletalMeshComponent 添加组件 protected ShootThemUp: Weapon/STUBaseWeapon.h class USkeletalMeshComponent; UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USkeletalMeshComponent *WeaponMeshComponent; 初始化组件 ShootThemUp: Weapon/STUBaseWeapon.cpp // 构造函数 WeaponMeshComponent = CreateDefaultSubobject\u0026lt;USkeletalMeshComponent\u0026gt;(\u0026quot;WeaponMeshComponent\u0026quot;); SetRootComponent(WeaponMeshComponent); 创建BP_STUBaseWeapon并绑定武器模型 # 虚幻编辑器 创建文件夹: Content/Weapon 创建BP_STUBaseWeapon，保存到Content/Weapon 为WeaponMeshComponent绑定Rifle 因为武器很小，设置Camera Speed为1 为游戏角色的骨骼网格体添加武器挂载点 # 虚幻编辑器 为骨骼网格体添加挂载点 动态创建武器，并附加到游戏角色骨骼网格体的挂载点 # C++ 添加武器类型属性, 动态创建Actor时使用 # ShootThemUp: Player/STUBaseCharacter.h protected class ASTUBaseWeapon; UPROPERTY(EditDefaultsOnly) TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponClass; ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Weapon/STUBaseWeapon.h\u0026quot; 动态创建武器Actor # 使用了UWorld::SpawnActor，所以我认为应该包含；但没包含编译通过了 #include \u0026quot;Engine/World.h\u0026quot; if (!GetWorld()) return; const auto Weapon = GetWorld()-\u0026gt;SpawnActor\u0026lt;ASTUBaseWeapon\u0026gt;(WeaponClass); 将武器附加到骨骼网格体挂载点 # 获取骨骼网格体: ACharacter::GetMesh 将Actor附加到可变换组件的挂载点 AttachToComponent的第一个参数是USenceComponent类型，而我们传入其派生类USkeletalMeshComponent类型, 所以需要包含Components/SkeletalMeshComponent.h FAttachmentTransformRules AttachmentRules(EAttachmentRule::SnapToTarget, false); Weapon-\u0026gt;AttachToComponent(GetMesh(), AttachmentRules, \u0026quot;WeaponSocket\u0026quot;); 完整实现: SpawnWeapon # ShootThemUp: Player/STUBaseCharacter.h private void SpawnWeapon(); ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;Components/SkeletalMeshComponent.h\u0026quot; void ASTUBaseCharacter::SpawnWeapon() { if (!GetWorld()) return; const auto Weapon = GetWorld()-\u0026gt;SpawnActor\u0026lt;ASTUBaseWeapon\u0026gt;(WeaponClass); if (!Weapon) return; FAttachmentTransformRules AttachmentRules(EAttachmentRule::SnapToTarget, false); Weapon-\u0026gt;AttachToComponent(GetMesh(), AttachmentRules, \u0026quot;WeaponSocket\u0026quot;); } 游戏角色出现在场景中时, 创建并装载武器: 在BeginPlay中调用SpawnWeapon 查看 # 虚幻编辑器 设置武器类型: 将BP_STUBaseCharacter的WeaponClass设置为BP_STUBaseWeapon 效果图 "}),e.add({id:12,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%88%9D%E5%A7%8B%E5%8C%96shootthemup%E9%A1%B9%E7%9B%AE/",title:"初始化ShootThemUp项目",description:"说明 # 虚幻编辑器 将 ShooterGame 作为内容包，基于此开发 ShootThemUp 。好比室内设计师提供游戏资料，我们在此之上开发游戏。 创建ShootThemUp项目 # Blank Blueprint 配置ShootThemUp # 添加版权信息 # 项目设置 \u0026gt; Project \u0026gt; Description \u0026gt; Legal \u0026gt; Copyright Notice Shoot Them Up Game, All Rights Reserved. 关卡设置 # 添加关卡文件夹 Content/Levels 创建关卡 新建关卡 选择 Basic 保存到Content/Levels/，命名为DefaultMap 设置 EditorStartupMap 和 GameDefaultMap 使用 DefaultMap 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 从ShooterGame导入资产 # ShooterGame导出 # 打开ShooterGame项目 \u0026gt; 在内容浏览器选中Content/Animations/TTP_Animations，右键 \u0026gt; Migrate 取消Sounds勾选 默认勾选的文件夹里的内容都与 TTP_Animations 相关 保存到 ShootThemUp/Content 目录下 不能直接迁移到 5.",content:"说明 # 虚幻编辑器 将 ShooterGame 作为内容包，基于此开发 ShootThemUp 。好比室内设计师提供游戏资料，我们在此之上开发游戏。 创建ShootThemUp项目 # Blank Blueprint 配置ShootThemUp # 添加版权信息 # 项目设置 \u0026gt; Project \u0026gt; Description \u0026gt; Legal \u0026gt; Copyright Notice Shoot Them Up Game, All Rights Reserved. 关卡设置 # 添加关卡文件夹 Content/Levels 创建关卡 新建关卡 选择 Basic 保存到Content/Levels/，命名为DefaultMap 设置 EditorStartupMap 和 GameDefaultMap 使用 DefaultMap 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 从ShooterGame导入资产 # ShooterGame导出 # 打开ShooterGame项目 \u0026gt; 在内容浏览器选中Content/Animations/TTP_Animations，右键 \u0026gt; Migrate 取消Sounds勾选 默认勾选的文件夹里的内容都与 TTP_Animations 相关 保存到 ShootThemUp/Content 目录下 不能直接迁移到 5.1.1/ShootThemUp/Content/ExternalContent ，虚幻引擎会检查目录，要求这些资产的上级目录是 Content ，即使根目录是 Content 也无法通过检查 ShootThemUp导入 # 添加外部资产文件夹和本章资产文件夹 Content/ExternalContent Content/ExternalContent/Animation 通过虚幻编辑器，将 Content 目录下的 Animations Characters Environment 移动到 ExternalContent/Animation 目录下 不能在外部直接将三个文件夹移动到目的文件夹中，会导致资产之间的相互引用路径出错 为 ExternalContent 设置文件夹颜色 选中Content/ExternalContent，右键 \u0026gt; Set Color 为 ExternalContent/Animation 设置文件夹颜色 效果图 基于蓝图创建C++项目 # 添加C++类即可 创建蓝图项目的时间开销明显小于创建C++项目的时间开销 创建GameModeBase类 # Tools \u0026gt; New C++ Class.. STUGameModeBase 不设置类类型 Content同级目录出现C++ Classes文件夹 设置关卡使用STUGameModeBase # 查看项目源码中的版权信息 # 不使用预编译头文件 # ShootThemUp: ShootThemUp.Build.cs // PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PCHUsage = PCHUsageMode.NoPCHs; 脚本 # 编译项目 # Build.sh #!/bin/bash Project=\u0026quot;Projects/5.1.1/ShootThemUp/ShootThemUp.uproject\u0026quot; BuildScript=\u0026quot;EpicGames/UE_5.1/Engine/Build/BatchFiles/Mac/Build.sh\u0026quot; Target=\u0026quot;ShootThemUpEditor\u0026quot; $BuildScript $Target Mac Development $Project -waitmutex -NoHotReload 打开虚幻编辑器 # Editor.sh #!/bin/bash Project=\u0026quot;Projects/5.1.1/ShootThemUp/ShootThemUp.uproject\u0026quot; UnrealEditor=\u0026quot;EpicGames/UE_5.1/Engine/Binaries/Mac/UnrealEditor.app\u0026quot; open -a $UnrealEditor $Project 生成项目文件 # ProjectFiles.sh #!/bin/bash Project=\u0026quot;Projects/5.1.1/ShootThemUp/ShootThemUp.uproject\u0026quot; GenerateProjectFilesScript=\u0026quot;EpicGames/UE_5.1/Engine/Build/BatchFiles/Mac/GenerateProjectFiles.sh\u0026quot; EngineCCDst=\u0026quot;EpicGames/UE_5.1/compile_commands.json\u0026quot; EngineCCSrc=\u0026quot;EpicGames/UE_5.1/.vscode/compileCommands_Default.json\u0026quot; ProjectCCDst=\u0026quot;Projects/5.1.1/ShootThemUp/compile_commands.json\u0026quot; ProjectCCSrc=\u0026quot;Projects/5.1.1/ShootThemUp/.vscode/compileCommands_ShootThemUp.json\u0026quot; GenerateXCode() { $GenerateProjectFilesScript -projectfiles -project=$Project -game -rocket -progress -XCodeProjectFiles } GenerateVSCode() { $GenerateProjectFilesScript -projectfiles -project=$Project -game -rocket -progress -VSCode cp $EngineCCSrc $EngineCCDst cp $ProjectCCSrc $ProjectCCDst } # GenerateXCode GenerateVSCode "}),e.add({id:13,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AF%B9%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E9%80%A0%E6%88%90%E4%BC%A4%E5%AE%B3/",title:"对游戏角色造成伤害",description:"概览 # C++ 对游戏角色造成伤害 # 虚幻引擎提供一组函数，用来对Actor造成伤害 若有注册伤害处理服务, Actor受到伤害时触发处理函数 本节在Tick函数中持续对游戏角色造成伤害 伤害处理服务 # 我们在Actor提供的数据成员处注册伤害处理函数, 在处理函数中减少游戏角色生命值 持续对游戏角色造成伤害 # C++ 伤害来源是自己 ShootThemUp: Player/STUBaseCharacter.cpp // Tick TakeDamage(0.1f, FDamageEvent{}, GetController(), this); 伤害处理服务 # AActor定义了委托类型FTakeAnyDamageSignature，并有该类型数据成员AActor::OnTakeAnyDamage 我们通过数据成员注册伤害处理服务 处理函数签名 void handler(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 该委托类型支持蓝图 触发伤害处理函数时，会传入UDamageType 注册伤害机制的委托服务 # C++ 搭建框架 # 添加空函数 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) {} 注册伤害处理函数 ShootThemUp: Components/STUHealthComponent.",content:"概览 # C++ 对游戏角色造成伤害 # 虚幻引擎提供一组函数，用来对Actor造成伤害 若有注册伤害处理服务, Actor受到伤害时触发处理函数 本节在Tick函数中持续对游戏角色造成伤害 伤害处理服务 # 我们在Actor提供的数据成员处注册伤害处理函数, 在处理函数中减少游戏角色生命值 持续对游戏角色造成伤害 # C++ 伤害来源是自己 ShootThemUp: Player/STUBaseCharacter.cpp // Tick TakeDamage(0.1f, FDamageEvent{}, GetController(), this); 伤害处理服务 # AActor定义了委托类型FTakeAnyDamageSignature，并有该类型数据成员AActor::OnTakeAnyDamage 我们通过数据成员注册伤害处理服务 处理函数签名 void handler(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 该委托类型支持蓝图 触发伤害处理函数时，会传入UDamageType 注册伤害机制的委托服务 # C++ 搭建框架 # 添加空函数 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) {} 注册伤害处理函数 ShootThemUp: Components/STUHealthComponent.cpp #include \u0026quot;GameFramework/Actor.h\u0026quot; // BeginPlay AActor *TheOwner = GetOwner(); if (TheOwner) { TheOwner-\u0026gt;OnTakeAnyDamage.AddDynamic(this, \u0026amp;USTUHealthComponent::OnTakeAnyDamage); } 添加函数声明 private ShootThemUp: Components/STUHealthComponent.h UFUNCTION() void OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 实现处理函数 # ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage Health -= Damage; 差不多一秒10帧，即1s调用十次处理函数；Health减为0之后，继续减少 "}),e.add({id:14,href:"/docs/%E5%88%86%E4%BA%AB/emacs/org-mode/",title:"org-mode",description:"便签 # The Org Manual 样式 # 删除线 # Content +Content+ 下划线 # Content _Content_ 文本块 # Content =test= ~test~ 斜体 # Content /Content/ 加粗 # Content *Content* 分隔线 # ----- 标题 # 标题间移动 # - 上一个 C-c C-p 下一个 C-c C-n 去到上级标题 # C-c C-u 同级标题间移动 # - 上一个 C-c C-b 下一个 C-c C-f 创建标题 # - 同级标题 C-RET 同级标题 / 列表项 M-RET 同级TODO标题 M-S-RET 标题、列表项转换 # - 标题转换为列表项 C-c - 文本、列表项转换为标题 C-c * 标题和列表项升降级 # - 降级 M-LEFT 升级 M-RIGHT TODO标题状态切换 # \u0026gt; 普通标题 \u0026gt; TODO \u0026gt; DONE 所属标题状态切换 # C-c C-t 处于标题行 # - S-LEFT 逆向 S-RIGHT 逆向 文本显示 # 进入预览模式，显示一级标题 # C-c C-j 标题展开 # \u0026gt; 只展开第一个一级标题 \u0026gt; 展开所有标题 \u0026gt; 展开全部内容 S-TAB 子树 # - 删除子树 C-c C-x C-w 拷贝子树 C-c C-x M-w 降级 M-S-LEFT 升级 M-S-RIGHT 模板 # Structure Templates 插入模板 # - 快捷键 C-c C-, 函数 org-insert-structure-template 不再支持 \u0026lt;s TAB 模板样式 # 代码块 # #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;Hello World!",content:"便签 # The Org Manual 样式 # 删除线 # Content +Content+ 下划线 # Content _Content_ 文本块 # Content =test= ~test~ 斜体 # Content /Content/ 加粗 # Content *Content* 分隔线 # ----- 标题 # 标题间移动 # - 上一个 C-c C-p 下一个 C-c C-n 去到上级标题 # C-c C-u 同级标题间移动 # - 上一个 C-c C-b 下一个 C-c C-f 创建标题 # - 同级标题 C-RET 同级标题 / 列表项 M-RET 同级TODO标题 M-S-RET 标题、列表项转换 # - 标题转换为列表项 C-c - 文本、列表项转换为标题 C-c * 标题和列表项升降级 # - 降级 M-LEFT 升级 M-RIGHT TODO标题状态切换 # \u0026gt; 普通标题 \u0026gt; TODO \u0026gt; DONE 所属标题状态切换 # C-c C-t 处于标题行 # - S-LEFT 逆向 S-RIGHT 逆向 文本显示 # 进入预览模式，显示一级标题 # C-c C-j 标题展开 # \u0026gt; 只展开第一个一级标题 \u0026gt; 展开所有标题 \u0026gt; 展开全部内容 S-TAB 子树 # - 删除子树 C-c C-x C-w 拷贝子树 C-c C-x M-w 降级 M-S-LEFT 升级 M-S-RIGHT 模板 # Structure Templates 插入模板 # - 快捷键 C-c C-, 函数 org-insert-structure-template 不再支持 \u0026lt;s TAB 模板样式 # 代码块 # #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;Hello World!\u0026quot; \u0026lt;\u0026lt; endl; return 0; } 需填写编程语言 #+begin_src \u0026lt;language\u0026gt; #+end_src 文本块 # Hello World! #+begin_example #+end_example 引用 # Hello World! #+begin_quote #+end_quote 代码块编辑 # 要求能识别编程语言 - 插入代码框 C-c C-, s 在新窗口编辑代码 C-c ' 保存修改 C-x C-s 关闭编辑窗口(未保存丢失) C-c C-k 执行 C-c C-c 对选中内容注释/去注释 M-； 计时 # 精确到分钟 - 开始 C-c C-x C-i 停止 C-c C-x C-o 链接 # - 插入 C-c C-l 打开 C-c C-o 显示/ 隐藏图片 C-c C-x C-v 网页 # [[http://www.baidu.com][百度]] 文件 # [[file:xxx.txt][描述]] 图片 # #+ATTR_ORG: :width 400 #+ATTR_HTML: :width 500 [[file:pic/xxxx.png]] org文件导出 # html # - 生成文件并打开 C-c C-e h o markdown # - 生成文件并打开 C-c C-e m o 菜单项添加markdown选项 customize-option \u0026gt; org-export-backends \u0026gt; 勾选org-markdown 安装markdown-mode 日程管理 # agenda 添加日程 # - 开始 C-c C-s 结束 C-c C-d 搜索路径保存在列表org-agenda-files中，不支持递归搜索 # 进入日程菜单 # - 函数 org-agenda 快捷键(自定义) C-c a 切换到当日安排/本周安排 d / w 表格 # 快捷键 # - M-LEFT / M-RIGHT 移动当前列 M-UP / M-DOWN 移动当前行 C-c - 在当前行下方加分割线 C-c RET 在当前行下方加分割线和换行 M-a 移动到cell开始 M-e 移动到cell末尾 TAB 下一个cell S-TAB 上一个cell C-c C-c 格式化表格 M-S-LEFT 删除当前列 M-S-RIGHT 左侧新建列 计算 # 快捷键 查询单元所在行列 C-c ? 显示表格相对行列 C-c } 行累加 # 在公式所在行C-c C-c |------+------------| | | 待累加数值 | |------+------------| | | 3 | | | 2 | | | 10 | | | 22 | |------+------------| | 累加 | 37 | |------+------------| #+TBLFM: @6$2=vsum(@2..@5) 使用插件按类别统计表格数据 # orgtbl-aggregate 在公式所在行C-c C-c #+NAME: 2023-08-01开销 |------+------+--------| | 类别 | 金额 | 项目 | |------+------+--------| | 水果 | 10 | 苹果 | | 水果 | 8 | 香蕉 | | 日化 | 12 | 洗手液 | |------+------+--------| #+BEGIN: aggregate :table \u0026quot;2023-08-01开销\u0026quot; :cols \u0026quot;类别 sum(金额)\u0026quot; | 类别 | sum(金额) | |------+-----------| | 水果 | 18 | | 日化 | 12 | #+END 缩进 # 第一种: 文本不含空格，在org-mode下显示缩进 # indent mode 使能mode # (org-indent-mode t) 全局设置 # (setq org-startup-indented t) 文件选项 # #+STARTUP：indent 第二种: 换行时自动缩进 # hard indentation 全局设置 (setq org-adapt-indentation t) 隐藏前缀星号 # 全局设置 (setq org-hide-leading-stars t) 文件选项 #+STARTUP: hidestars 选项设置 # 文章目录 # Table of Contents 导出时文章目录选项 不添加文章目录 # #+OPTIONS: toc:nil 生成的文章目录层级 # 包含1-2级标题 #+TOC: headlines 2 标题标号 # 导出时标题标号选项 不添加标题标号 # #+OPTIONS num:nil 上下标 # 格式 # 下标 a_b 上标 a^b 关闭上下标转换 # #+OPTIONS: ^:nil 要求使用{}转义 # #+OPTIONS ^:{} 上标 a^{b} 下标 a_{b} OPTIONS合并 # #+OPTIONS: toc:nil ^:{} 文本显示选项 # 只显示一级标题 # #+STARTUP: overview 显示所有内容 # #+STARTUP: showall STARTUP合并 # #+STARTUP: showall hidestars 函数 # 去到所属标题 # (outline-up-heading 0) 去到上级标题, 不超过1级标题 # ;; 所属标题的上级标题 (outline-up-heading 1) ;; 所属标题的上上级母标题 (outline-up-heading 2) 输出标题级别 # (outline-level) 比较 # (message \u0026quot;%s\u0026quot; (\u0026gt; (funcall outline-level) 1)) 去到下一个标题 # (outline-next-heading) 当前是否在标题行 # (outline-on-heading-p) 开启/关闭自动换行 # (toggle-truncate-lines) 行首 # (org-beginning-of-line) 删除行 # (kill-line) 调整所在行的缩进 # (indent-according-to-mode) "}),e.add({id:15,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BB%E7%BC%96%E8%BE%91%E5%99%A8/fabrik/",title:"FABRIK",description:"说明 # Forward and Backward Reaching Inverse Kinematics 逆运动学 # Inverse Kinematics 给出子骨骼的位置, 反求推导出其所在骨骼链上n级父骨骼位置, 从而确定整条骨骼链的方法 末端执行器 # End Effector 位于机械臂末端、与外界环境进行物理交互的工具, 也称作臂端工具 End-of-Arm Tooling , 缩写为EOAT FABRIK的设置, 就是给出骨骼链和末端执行器的描述, 计算骨骼链各关节变换 在动画蓝图中使用FABRIK # AnimGraph 末端执行器变换默认作为针脚 切换末端执行器变换在细节面板设置 # Details \u0026gt; End Effector \u0026gt; Effector Transform \u0026gt; 左键Pin, 取消Expose As Pin的勾选 FABRIK Effector Transform 配置末端执行器 # - Effector Target 在动画蓝图绑定的骨骼树中选取目标 Effector Transform Space 与Target类型有关, 默认Component Space, 骨骼对应Bone Space Effector Transform 相对于Target的变换 配置Solver # 设置骨骼链 - Tip Bone 机械臂末端骨骼 Root Bone 机械臂根骨骼 ",content:"说明 # Forward and Backward Reaching Inverse Kinematics 逆运动学 # Inverse Kinematics 给出子骨骼的位置, 反求推导出其所在骨骼链上n级父骨骼位置, 从而确定整条骨骼链的方法 末端执行器 # End Effector 位于机械臂末端、与外界环境进行物理交互的工具, 也称作臂端工具 End-of-Arm Tooling , 缩写为EOAT FABRIK的设置, 就是给出骨骼链和末端执行器的描述, 计算骨骼链各关节变换 在动画蓝图中使用FABRIK # AnimGraph 末端执行器变换默认作为针脚 切换末端执行器变换在细节面板设置 # Details \u0026gt; End Effector \u0026gt; Effector Transform \u0026gt; 左键Pin, 取消Expose As Pin的勾选 FABRIK Effector Transform 配置末端执行器 # - Effector Target 在动画蓝图绑定的骨骼树中选取目标 Effector Transform Space 与Target类型有关, 默认Component Space, 骨骼对应Bone Space Effector Transform 相对于Target的变换 配置Solver # 设置骨骼链 - Tip Bone 机械臂末端骨骼 Root Bone 机械臂根骨骼 "}),e.add({id:16,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/html/",title:"HTML",description:"注释 # 单行 # \u0026lt;!--这是单行注释--\u0026gt; 多行 # \u0026lt;!-- 这是多行注释 这是多行注释 这是多行注释 --\u0026gt; 无序列表 # \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;无\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;序\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;表\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ",content:"注释 # 单行 # \u0026lt;!--这是单行注释--\u0026gt; 多行 # \u0026lt;!-- 这是多行注释 这是多行注释 这是多行注释 --\u0026gt; 无序列表 # \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;无\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;序\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;表\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; "}),e.add({id:17,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/",title:"代码规范",description:"说明 # .clang-format .gitignore 虚幻引擎编码规范 - 大括号 放在新行 缩进 使用空格 缩进、制表符和空格 # 缩进 # indent 编写代码时，按下Tab键，会按制表符宽度留出空位，用以控制格式 使用制表符 Tab 和空格填充缩进 制表符的宽度可设置，不同平台制表符的宽度不一，视觉上，查看代码会有不习惯的感觉；可在本地设置使用空格，即用空格替换制表符 缩进使用空格 # 示例: 缩进使用空格, 制表符宽度 TabWidth 无效；缩进宽度 IndentWidth 生效, 一次缩进对应7个空格 IndentWidth: '7' UseTab: 'Never' TabWidth: '9' 缩进使用制表符和空格 # 若缩进宽度小于制表符宽度, 使用空格填充缩进; 若缩进宽度大于等于制表符宽度, 使用制表符和空格填充缩进 示例: 一次缩进对应7个空格，不会被替换为制表符；两个缩进对应14个空格，会被替换为1个制表符加5个空格 IndentWidth: '7' TabWidth: '9' UseTab: 'Always' 格式化代码规则 # .clang-format 官方文档 YAML标记文件 作为项目的一部分，描述管理代码文件的统一格式 每行遵循格式 key: value 设置受约束的开发语言 # Language: Cpp 如果项目中只一种开发语言，或者所有开发语言使用相同规范，可忽略该配置 通用样式 # Google: 一个制表符对应2个空格，大括号在行尾 BasedOnStyle: Google Microsoft: 一个制表符对应4个空格，大括号在新行 BasedOnStyle: Microsoft 制表符宽度 # 若缩进使用制表符，每6个空格替换一个制表符；当缩进宽度和制表符宽度不一致时，效果很糟糕 TabWidth: '6' 缩进宽度 # IndentWidth: '4' 缩进样式 # 空格 UseTab: Never 制表符: 源文件中既有空格又有制表符 UseTab: Always 设置大括号位置 # 行尾 BreakBeforeBraces: Attach 新行 BreakBeforeBraces: Allman 显示时, 每行最大字符个数 # 为0时，按输入的实际情况显示 ColumnLimit: '140' 向前缩进 # 控制访问说明符的缩进 AccessModifierOffset: '-4' 头文件排序 # SortIncludes: false 括号换行时，参数的对齐方式 # AlignAfterOpenBracket: Align 不对齐 DontAlign someLongFunction(argument1, argument2); 对齐 Align someLongFunction(argument1, argument2); 当语句较短时，是否允许写在单行 # AllowShortBlocksOnASingleLine: false 条件语句的执行部分为空，或只有一行语句时，可认为语句较短；为false则如下输出 while (true) { } while (true) { continue; } 当函数语句较短时，是否允许写在单行 # - Inline 若函数体为空，允许；若函数在类内定义，允许 InlineOnly 只允许一种情况：函数在类内定义 Empty 只允许一种情况：函数体为空 AllowShortFunctionsOnASingleLine: Inline 指针和引用的对齐方式 # PointerAlignment: Right Right int *a; Left int* a; Git仓库同步 # .",content:"说明 # .clang-format .gitignore 虚幻引擎编码规范 - 大括号 放在新行 缩进 使用空格 缩进、制表符和空格 # 缩进 # indent 编写代码时，按下Tab键，会按制表符宽度留出空位，用以控制格式 使用制表符 Tab 和空格填充缩进 制表符的宽度可设置，不同平台制表符的宽度不一，视觉上，查看代码会有不习惯的感觉；可在本地设置使用空格，即用空格替换制表符 缩进使用空格 # 示例: 缩进使用空格, 制表符宽度 TabWidth 无效；缩进宽度 IndentWidth 生效, 一次缩进对应7个空格 IndentWidth: '7' UseTab: 'Never' TabWidth: '9' 缩进使用制表符和空格 # 若缩进宽度小于制表符宽度, 使用空格填充缩进; 若缩进宽度大于等于制表符宽度, 使用制表符和空格填充缩进 示例: 一次缩进对应7个空格，不会被替换为制表符；两个缩进对应14个空格，会被替换为1个制表符加5个空格 IndentWidth: '7' TabWidth: '9' UseTab: 'Always' 格式化代码规则 # .clang-format 官方文档 YAML标记文件 作为项目的一部分，描述管理代码文件的统一格式 每行遵循格式 key: value 设置受约束的开发语言 # Language: Cpp 如果项目中只一种开发语言，或者所有开发语言使用相同规范，可忽略该配置 通用样式 # Google: 一个制表符对应2个空格，大括号在行尾 BasedOnStyle: Google Microsoft: 一个制表符对应4个空格，大括号在新行 BasedOnStyle: Microsoft 制表符宽度 # 若缩进使用制表符，每6个空格替换一个制表符；当缩进宽度和制表符宽度不一致时，效果很糟糕 TabWidth: '6' 缩进宽度 # IndentWidth: '4' 缩进样式 # 空格 UseTab: Never 制表符: 源文件中既有空格又有制表符 UseTab: Always 设置大括号位置 # 行尾 BreakBeforeBraces: Attach 新行 BreakBeforeBraces: Allman 显示时, 每行最大字符个数 # 为0时，按输入的实际情况显示 ColumnLimit: '140' 向前缩进 # 控制访问说明符的缩进 AccessModifierOffset: '-4' 头文件排序 # SortIncludes: false 括号换行时，参数的对齐方式 # AlignAfterOpenBracket: Align 不对齐 DontAlign someLongFunction(argument1, argument2); 对齐 Align someLongFunction(argument1, argument2); 当语句较短时，是否允许写在单行 # AllowShortBlocksOnASingleLine: false 条件语句的执行部分为空，或只有一行语句时，可认为语句较短；为false则如下输出 while (true) { } while (true) { continue; } 当函数语句较短时，是否允许写在单行 # - Inline 若函数体为空，允许；若函数在类内定义，允许 InlineOnly 只允许一种情况：函数在类内定义 Empty 只允许一种情况：函数体为空 AllowShortFunctionsOnASingleLine: Inline 指针和引用的对齐方式 # PointerAlignment: Right Right int *a; Left int* a; Git仓库同步 # .gitignore 虚幻引擎提供模板 告诉Git，同步时忽略的文件和文件夹 命名约定 # 虚幻编辑器 虚幻引擎命名规范参考 虚幻编辑器 材质 Material M_ 材质实例 Material Instance MI_ 基于C++的蓝图类 Blueprint BP_ 动画蓝图 Animation Blueprint ABP_ 混合空间(1D) Blend Space BS_ 动画剪辑 Animation Montage AM_ "}),e.add({id:18,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E6%8B%9F%E6%A6%B4%E5%BC%B9%E7%88%86%E7%82%B8/",title:"模拟榴弹爆炸",description:"建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 创建伤害源 # 创建Dev/STUDevDamageActor # 虚幻编辑器 Actor 公有类 设置头文件搜索路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot; }); 添加可视化组件，使得伤害源可变换 # 添加SceneComponent protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent; 初始化组件 ShootThemUp: Dev/STUDevDamageActor.cpp // 构造函数 SceneComponent = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(\u0026quot;SceneComponent\u0026quot;); SetRootComponent(SceneComponent); 绘制球体，使得爆炸范围可视化 # 添加球体参数 protected ShootThemUp: Dev/STUDevDamageActor.h - 颜色 SphereColor 半径 Radius UPROPERTY(EditAnywhere) float Radius = 300.0f; UPROPERTY(EditAnywhere) FColor SphereColor = FColor::Red; 每帧绘制球体 ShootThemUp: Dev/STUDevDamageActor.cpp #include \u0026quot;DrawDebugHelpers.h\u0026quot; // Tick DrawDebugSphere(GetWorld(), GetActorLocation(), Radius, 24, SphereColor); 使用了GetWorld，其声明和UWorld的定义在一处，而DrawDebugSphere的第一个参数类型为UWorld，不用包含Engine/World.",content:"建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 创建伤害源 # 创建Dev/STUDevDamageActor # 虚幻编辑器 Actor 公有类 设置头文件搜索路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot; }); 添加可视化组件，使得伤害源可变换 # 添加SceneComponent protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent; 初始化组件 ShootThemUp: Dev/STUDevDamageActor.cpp // 构造函数 SceneComponent = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(\u0026quot;SceneComponent\u0026quot;); SetRootComponent(SceneComponent); 绘制球体，使得爆炸范围可视化 # 添加球体参数 protected ShootThemUp: Dev/STUDevDamageActor.h - 颜色 SphereColor 半径 Radius UPROPERTY(EditAnywhere) float Radius = 300.0f; UPROPERTY(EditAnywhere) FColor SphereColor = FColor::Red; 每帧绘制球体 ShootThemUp: Dev/STUDevDamageActor.cpp #include \u0026quot;DrawDebugHelpers.h\u0026quot; // Tick DrawDebugSphere(GetWorld(), GetActorLocation(), Radius, 24, SphereColor); 使用了GetWorld，其声明和UWorld的定义在一处，而DrawDebugSphere的第一个参数类型为UWorld，不用包含Engine/World.h 对伤害范围内Actor造成半径伤害 # 添加半径伤害参数 protected ShootThemUp: Dev/STUDevDamageActor.h - Damage 伤害数值特征 DoFullDamage 半径伤害计算选项：为true，受到的伤害与到球心的距离有关；为false，使用简化模型，受到伤害值恒定 UPROPERTY(EditAnywhere) float Damage = 10.0f; UPROPERTY(EditAnywhere) bool DoFullDamage = false; 对伤害范围内Actor造成半径伤害 ShootThemUp: Dev/STUDevDamageActor.cpp #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;Kismet/GameplayStatics.h\u0026quot; // Tick UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); ApplyRadialDamage 的第一个参数类型为 UObject ，此时传入 UWorld ，需包含 UWorld 头文件 验证半径伤害数值 # C++ 定义日志宏，输出伤害值 ShootThemUp: Components/STUHealthComponent.cpp DEFINE_LOG_CATEGORY_STATIC(LogHealthComponent, All, All); // OnTakeAnyDamage UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;Damage: %.0f\u0026quot;), Damage); 屏蔽STUBaseCharacter\u0026gt;Tick中调用TakeDamage # ShootThemUp: Player/STUBaseCharacter.cpp 在关卡中添加伤害源 # 虚幻编辑器 调整BP_STUBaseCharacter\u0026gt;CameraComponent位置 # 向上，向后 在关卡中添加STDevDamageActor # 第一个伤害源: 使用默认设置，根据游戏角色到球心的距离计算伤害 第二个伤害源: 设置半径和颜色，处在伤害范围内受到伤害数值恒定（开销小） 调整 STDevDamageActor 的位置，效果图 要求伤害源球心无阻隔 验证 DoFullDamage # 处于蓝色球内，伤害值一致 处于红色球内，离球心越近，伤害值越大 球心在空中，跳跃也会缩短到球心的距离 伤害球内的所有Actor都会受到伤害 # "}),e.add({id:19,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E6%AD%A6%E5%99%A8%E7%BB%84%E4%BB%B6/",title:"武器组件",description:`概览 # 创建武器组件类 STUWeaponComponent 武器组件负责武器相关逻辑: 将SpawnWeapon移到武器组件 为游戏角色添加武器组件 为武器类添加 Fire 接口, 对应扣动扳机逻辑 为游戏角色绑定鼠标左键, 武器组件提供回调函数 Fire , 调用武器类 Fire 接口 初始化武器组件类 # 创建C++类: Components/STUWeaponComponent # 虚幻编辑器 - ActorComponent Public Components 调整框架 # C++ - 构造函数 每帧调用置false TickComponent 屏蔽 ShootThemUp: Components/STUWeaponComponent.h ShootThemUp: Components/STUWeaponComponent.cpp 将SpawnWeapon逻辑移动到武器组件 # C++ 在STUWeaponComponent中实现SpawnWeapon # 添加武器类型属性, 动态创建Actor时使用
ShootThemUp: Components/STUWeaponComponent.h protected class ASTUBaseWeapon; UPROPERTY(EditDefaultsOnly) TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponClass; ShootThemUp: Components/STUWeaponComponent.cpp #include \u0026quot;Weapon/STUBaseWeapon.h\u0026quot; 添加变量: 存放挂载点名称
protected ShootThemUp: Components/STUWeaponComponent.h UPROPERTY(EditDefaultsOnly) FName WeaponAttachPointName = \u0026quot;WeaponSocket\u0026quot;; 添加变量: 存放武器指针`,content:`概览 # 创建武器组件类 STUWeaponComponent 武器组件负责武器相关逻辑: 将SpawnWeapon移到武器组件 为游戏角色添加武器组件 为武器类添加 Fire 接口, 对应扣动扳机逻辑 为游戏角色绑定鼠标左键, 武器组件提供回调函数 Fire , 调用武器类 Fire 接口 初始化武器组件类 # 创建C++类: Components/STUWeaponComponent # 虚幻编辑器 - ActorComponent Public Components 调整框架 # C++ - 构造函数 每帧调用置false TickComponent 屏蔽 ShootThemUp: Components/STUWeaponComponent.h ShootThemUp: Components/STUWeaponComponent.cpp 将SpawnWeapon逻辑移动到武器组件 # C++ 在STUWeaponComponent中实现SpawnWeapon # 添加武器类型属性, 动态创建Actor时使用
ShootThemUp: Components/STUWeaponComponent.h protected class ASTUBaseWeapon; UPROPERTY(EditDefaultsOnly) TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponClass; ShootThemUp: Components/STUWeaponComponent.cpp #include \u0026quot;Weapon/STUBaseWeapon.h\u0026quot; 添加变量: 存放挂载点名称
protected ShootThemUp: Components/STUWeaponComponent.h UPROPERTY(EditDefaultsOnly) FName WeaponAttachPointName = \u0026quot;WeaponSocket\u0026quot;; 添加变量: 存放武器指针
private 使用UPROPERTY宏标识, 使得Garbage Collector管理该指针指向的内存 UPROPERTY() ASTUBaseWeapon *CurrentWeapon= nullptr; 添加函数: SpawnWeapon
ShootThemUp: Components/STUWeaponComponent.h private void SpawnWeapon(); ShootThemUp: Components/STUWeaponComponent.cpp 处理不正确则退出: 统一结构, 减少缩进 #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;Components/SkeletalMeshComponent.h\u0026quot; #include \u0026quot;Weapon/STUBaseWeapon.h\u0026quot; #include \u0026quot;GameFramework/Character.h\u0026quot; void USTUWeaponComponent::SpawnWeapon() { if (!GetWorld()) return; ACharacter *Character = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Character) return; CurrentWeapon = GetWorld()-\u0026gt;SpawnActor\u0026lt;ASTUBaseWeapon\u0026gt;(WeaponClass); if (!CurrentWeapon) return; FAttachmentTransformRules AttachmentRules(EAttachmentRule::SnapToTarget, false); CurrentWeapon-\u0026gt;AttachToComponent(Character-\u0026gt;GetMesh(), AttachmentRules, WeaponAttachPointName); } 武器组件出现在场景中时, 创建并装载武器: 在BeginPlay中调用SpawnWeapon 移除STUBaseCharacter中的SpawnWeapon # ShootThemUp: Player/STUBaseCharacter.h STUBaseWeapon前向声明 WeaponClass成员 SpawnWeapon声明 ShootThemUp: Player/STUBaseCharacter.cpp 头文件: STUBaseWeapon, World, SkeletalMeshComponent BeginPlay中调用SpawnWeapon SpawnWeapon 为游戏角色添加武器组件 # C++ 武器组件是纯逻辑组件, 不用设置上级组件 添加组件 protected ShootThemUp: Player/STUBaseCharacter.h class USTUWeaponComponent; UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USTUWeaponComponent *WeaponComponent; 初始化组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/STUWeaponComponent.h\u0026quot; // 构造函数 WeaponComponent = CreateDefaultSubobject\u0026lt;USTUWeaponComponent\u0026gt;(\u0026quot;WeaponComponent\u0026quot;); 查看武器绑定 # 虚幻编辑器 为武器组件设置武器类型 BP_STUBaseCharacter \u0026gt; Weapon Component \u0026gt; Weapon Class: 设置为BP_STUBaseWeapon 效果图: 和之前效果一致 实现游戏角色扣动扳机 # 为游戏角色绑定键位: 点击鼠标左键触发扣动扳机 # 项目设置 \u0026gt; Engine \u0026gt; Input \u0026gt; Bindings \u0026gt; Action Mappings - 函数描述 Fire 键位 Left Mouse Button 武器组件提供回调函数: 调用武器Fire接口 # C++ 为武器类添加Fire接口 # 具体类型武器派生自STUBaseWeapon, 各自对Fire的实现不同. 将Fire定义为虚函数, 打印日志 ShootThemUp: Weapon/STUBaseWeapon.h public virtual void Fire(); ShootThemUp: Weapon/STUBaseWeapon.cpp DEFINE_LOG_CATEGORY_STATIC(LogBaseWeapon, All, All); void ASTUBaseWeapon::Fire() { UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Fire!\u0026quot;)); } 回调函数 # ShootThemUp: Components/STUWeaponComponent.h public void Fire(); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::Fire() { if (!CurrentWeapon) return; CurrentWeapon-\u0026gt;Fire(); } 绑定绑定函数描述和回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp 检查组件初始化 // BeginPlay check(WeaponComponent); 绑定 // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Fire\u0026quot;, IE_Pressed, WeaponComponent, \u0026amp;USTUWeaponComponent::Fire); 查看 # 点击鼠标左键, 输出日志 `}),e.add({id:20,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%B8%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%9E%8B/",title:"为游戏角色绑定模型",description:"概览 # - 玩家控制的游戏角色 Character 游戏角色控制器 PlayerController 关卡设置 GameModeBase: DefaultPawnClass, PlayerControllerClass 第三视角 CameraComponent 创建Character类和PlayController类 # 虚幻编辑器 创建 Player/STUBaseCharacter ACharacter 公有类 创建 Player/STUPlayerController APlayerController 公有类 设置头文件搜索路径 # 源文件路径已包含上级文件夹 ShootThemUp: Player/STUBaseCharacter.cpp 设置头文件搜索路径之后，可以不指明上级文件夹 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot; }); 设置STUGameModeBase使用STUBaseCharacter和STUPlayController # C++ - DefaultPawnClass 游戏角色类型 PlayerControllerClass 游戏角色控制器类型 添加默认构造函数声明 ShootThemUp: STUGameModeBase.h 设置默认游戏角色类型和游戏角色控制器类型 ShootThemUp: STUGameModeBase.cpp #include \u0026quot;Player/STUBaseCharacter.h\u0026quot; #include \u0026quot;Player/STUPlayerController.h\u0026quot; // 以下亦正确 // #include \u0026quot;STUBaseCharacter.h\u0026quot; // #include \u0026quot;STUPlayerController.h\u0026quot; ASTUGameModeBase::ASTUGameModeBase() { DefaultPawnClass = ASTUBaseCharacter::StaticClass(); PlayerControllerClass = ASTUPlayerController::StaticClass(); } 为游戏角色添加第三视角 # C++ 为STUBaseCharacter添加UCameraComponent类型成员 添加CameraComponent类型成员 ShootThemUp: Player/STUBaseCharacter.",content:"概览 # - 玩家控制的游戏角色 Character 游戏角色控制器 PlayerController 关卡设置 GameModeBase: DefaultPawnClass, PlayerControllerClass 第三视角 CameraComponent 创建Character类和PlayController类 # 虚幻编辑器 创建 Player/STUBaseCharacter ACharacter 公有类 创建 Player/STUPlayerController APlayerController 公有类 设置头文件搜索路径 # 源文件路径已包含上级文件夹 ShootThemUp: Player/STUBaseCharacter.cpp 设置头文件搜索路径之后，可以不指明上级文件夹 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot; }); 设置STUGameModeBase使用STUBaseCharacter和STUPlayController # C++ - DefaultPawnClass 游戏角色类型 PlayerControllerClass 游戏角色控制器类型 添加默认构造函数声明 ShootThemUp: STUGameModeBase.h 设置默认游戏角色类型和游戏角色控制器类型 ShootThemUp: STUGameModeBase.cpp #include \u0026quot;Player/STUBaseCharacter.h\u0026quot; #include \u0026quot;Player/STUPlayerController.h\u0026quot; // 以下亦正确 // #include \u0026quot;STUBaseCharacter.h\u0026quot; // #include \u0026quot;STUPlayerController.h\u0026quot; ASTUGameModeBase::ASTUGameModeBase() { DefaultPawnClass = ASTUBaseCharacter::StaticClass(); PlayerControllerClass = ASTUPlayerController::StaticClass(); } 为游戏角色添加第三视角 # C++ 为STUBaseCharacter添加UCameraComponent类型成员 添加CameraComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h // 前向声明 class UCameraComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UCameraComponent *CameraComponent; 初始化组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Camera/CameraComponent.h\u0026quot; // 默认构造函数 CameraComponent = CreateDefaultSubobject\u0026lt;UCameraComponent\u0026gt;(\u0026quot;CameraComponent\u0026quot;); CameraComponent-\u0026gt;SetupAttachment(GetRootComponent()); 编译ShootThemUp 设置关卡使用蓝图类 # 虚幻编辑器 查看STUGameModeBase使用的类型 # 创建基于STUGameModeBase的蓝图类 # 选中C++ Classes/ShootThemUp/STUGameModeBase右键, 选择Create blueprint class based on STUGameModeBase 保存到Content/, 命名为BP_STUBaseGameBase 创建基于STUBaseCharacter和STUPlayerController的蓝图类 # 创建 Content/Player 文件夹 创建 BP_STUBaseCharacter 和 BP_STUPlayerController , 保存到 Content/Player/ 设置关卡使用BP_STUGameModeBase, 并设置BP_STUGameModeBase使用BP_STUBaseCharacter和BP_STUPlayerController # 为游戏角色绑定模型 # 虚幻编辑器 BP_STUBaseCharacter 查看组件信息 # 说明 Capsule Component 根组件，实现碰撞检测 Arrow Component 角色的前进方向 Camera Component 第三视角 Mesh 骨骼网格体(Skeletal Mesh) Character Movement 纯逻辑组件，负责游戏角色运动 设置蓝图类编译成功自动保存 # 为Mesh组件绑定骨骼网格体 # Mesh 绑定 HeroTPP 材质自动应用 HeroTPP 移动模型到合适位置，旋转模型与前进方向一致 实现第三视角 分离 Camera Component 和 Mesh 组件 效果图 "}),e.add({id:21,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E4%BC%A4%E5%AE%B3%E7%B1%BB%E5%9E%8B/",title:"使用伤害类型",description:"创建伤害类型 # 虚幻编辑器 创建Dev/STUFireDamageType # UDamageType 公有类 创建Dev/STUIceDamageType # UDamageType 公有类 为伤害来源添加伤害类型属性 # C++ 添加伤害类型参数 protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UDamageType\u0026gt; DamageType; 造成伤害时，传入伤害类型 ShootThemUp: Dev/STUDevDamageActor.cpp // Tick // UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); 在伤害处理函数中输出伤害来源信息 # C++ ShootThemUp: Components/STUHealthComponent.cpp #include \u0026quot;Dev/STUFireDamageType.h\u0026quot; #include \u0026quot;Dev/STUIceDamageType.h\u0026quot; // OnTakeAnyDamage if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTUFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTUIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !",content:"创建伤害类型 # 虚幻编辑器 创建Dev/STUFireDamageType # UDamageType 公有类 创建Dev/STUIceDamageType # UDamageType 公有类 为伤害来源添加伤害类型属性 # C++ 添加伤害类型参数 protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UDamageType\u0026gt; DamageType; 造成伤害时，传入伤害类型 ShootThemUp: Dev/STUDevDamageActor.cpp // Tick // UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); 在伤害处理函数中输出伤害来源信息 # C++ ShootThemUp: Components/STUHealthComponent.cpp #include \u0026quot;Dev/STUFireDamageType.h\u0026quot; #include \u0026quot;Dev/STUIceDamageType.h\u0026quot; // OnTakeAnyDamage if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTUFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTUIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !!!\u0026quot;)); } } 查看 # 虚幻编辑器 为伤害来源设置DamageType属性 # DamageSphere-Red 选择 STUFireDamageType DamageSphere-Blue 选择 STUIceDamageType 查看日志 # 游戏角色进入到 DamageSphere-Red 游戏角色进入到 DamageSphere-Blue "}),e.add({id:22,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%88%9D%E8%AF%86%E7%A2%B0%E6%92%9E/",title:"初识碰撞",description:"概览 # 虚幻编辑器 在虚幻编辑器使用控制台 Console 碰撞选项 设置对其他类型物体的反馈 设置对通道的反馈 碰撞时产生重叠事件 碰撞时产生碰撞事件 自定义物体类型 碰撞 # 物体之间的交互，会发生以下情形 - Ignore 不会发生碰撞 Overlap 重叠: 可以发生碰撞, 允许通过, 可以产生重叠事件 Block 阻挡：可以发生碰撞, 形成阻碍, 可以产生碰撞事件 游戏角色拥有Capsule组件, 用以处理碰撞相关逻辑: 如游戏角色跳起后会落到地面, 而不是穿过地板; 可以操控其上楼梯; 和另一个游戏角色碰撞, 而不是穿过他 轨迹计算 # Logical Trace 给定轨迹的端点, 计算场景中与轨迹相交的物体 通过轨迹计算得到射击击中的目标 在虚幻编辑器使用控制台 # 打开控制台 运行时, 按下 ` Apostrophe Sign , 在视口下方会出现命令行, 可以输入调试命令 设置打开控制台的快捷键 项目设置 \u0026gt; Engine \u0026gt; Input \u0026gt; Console \u0026gt; Console Keys 输出每秒帧数 # stat fps 在右上方显示 1秒将近40帧 1s / 25ms = 1000ms / 25ms = 40 输出GPU统计数据 # stat GPU 隐藏Debug信息 # 输入相同命令, 或 stat none 显示场景中的碰撞 # show collision 可以看到Character的Capsule组件；碰撞组件纯逻辑, 在游戏中默认不可见 再次输入隐藏 碰撞选项 # 碰撞选项 设置游戏角色穿过物体 # 在场景中添加Sphere和Cube Place Actors \u0026gt; Shapes 设置游戏角色Capsule组件的碰撞选项 # BP_STUBaseCharacter \u0026gt; Capsule Component \u0026gt; Details \u0026gt; Collision 碰撞预设默认为Pawn 将碰撞预设置为Custom 设置Sphere的碰撞选项 # 将碰撞预设设置为Custom 允许游戏角色穿过 对物体类型的碰撞反馈中, 设置对Pawn执行Overlap Collision Responses \u0026gt; Object Responses \u0026gt; Pawn, 勾选Overlap 设置Cube的碰撞选项 # 设置 Collision Preset 为Custom 允许Pawn穿过 查看 # 游戏角色可以穿过Sphere和Cube # 游戏角色与物体碰撞时, 镜头会放大, 这是Camera通道对于Block设置给出的碰撞反馈 # 可以在SpringArm组件设置碰撞探测通道, 默认使用Camera通道 Camera组件作为SpringArm组件的下级组件, 是游戏角色的一部分, 此时也与物体碰撞 之所以会放大镜头, 在于发生碰撞时要表示阻挡; 我们不应该看到已经穿过物体那部分 设置Camera通道忽略物体 # 查看SpringArm组件 # BP_STUBaseCharacter \u0026gt; 选中SpringArmComponent \u0026gt; Details \u0026gt; Camera Collision \u0026gt; Probe Channel SpringArm组件如何进行碰撞探测, 默认为Camera通道 Probe Channel Camera 设置Camera通道忽略Sphere # Collision Responses \u0026gt; Trace Responses \u0026gt; Camera, 选择Ignore 查看: 游戏角色穿过Sphere时, 感官上正常 # 产生重叠事件: 输出Actor信息 # 在蓝图中处理事件 # 打开 BP_STUBaseCharacter \u0026gt; Event Graph Event ActorBeginOverlap 之后, 在屏幕打印 PrintString OtherActor作为PrintString输入, 实际输出产生碰撞的物体名称 为物体勾选发生碰撞时产生重叠事件 # Sphere Details \u0026gt; 勾选 Generate Overlap Events Cube Details \u0026gt; 勾选 Generate Overlap Events 查看日志 # 产生碰撞事件: 获取碰撞信息 # 为物体勾选发生碰撞时产生碰撞事件 # 选择Cube, 去到Details面板, 勾选 Simulation Generates Hit Events 在蓝图中添加事件 # BP_STUBaseCharacter \u0026gt; EventGraph, 添加EventHit 补充： 要求物体与Cube的碰撞反馈互为Block，发生碰撞时，才会产生碰撞事件 # 自定义物体类型 # 项目设置 \u0026gt; Engine \u0026gt; Collision 创建物体类型Enemy # New Object Channel 设置 - Name Enemy Default Response Block 其他类型物体对Enemy采取Block 创建物体类型Geometry # New Object Channel 设置 - Name Geometry Default Response Ignore 其他类型物体对Geometry采取Ignore 查看游戏角色的碰撞选项 # - Enemy Block Geometry Ignore 设置Cube # 物体类型为Geometry 忽略Pawn 设置Sphere # 物体类型为Enemy 阻挡Pawn ",content:"概览 # 虚幻编辑器 在虚幻编辑器使用控制台 Console 碰撞选项 设置对其他类型物体的反馈 设置对通道的反馈 碰撞时产生重叠事件 碰撞时产生碰撞事件 自定义物体类型 碰撞 # 物体之间的交互，会发生以下情形 - Ignore 不会发生碰撞 Overlap 重叠: 可以发生碰撞, 允许通过, 可以产生重叠事件 Block 阻挡：可以发生碰撞, 形成阻碍, 可以产生碰撞事件 游戏角色拥有Capsule组件, 用以处理碰撞相关逻辑: 如游戏角色跳起后会落到地面, 而不是穿过地板; 可以操控其上楼梯; 和另一个游戏角色碰撞, 而不是穿过他 轨迹计算 # Logical Trace 给定轨迹的端点, 计算场景中与轨迹相交的物体 通过轨迹计算得到射击击中的目标 在虚幻编辑器使用控制台 # 打开控制台 运行时, 按下 ` Apostrophe Sign , 在视口下方会出现命令行, 可以输入调试命令 设置打开控制台的快捷键 项目设置 \u0026gt; Engine \u0026gt; Input \u0026gt; Console \u0026gt; Console Keys 输出每秒帧数 # stat fps 在右上方显示 1秒将近40帧 1s / 25ms = 1000ms / 25ms = 40 输出GPU统计数据 # stat GPU 隐藏Debug信息 # 输入相同命令, 或 stat none 显示场景中的碰撞 # show collision 可以看到Character的Capsule组件；碰撞组件纯逻辑, 在游戏中默认不可见 再次输入隐藏 碰撞选项 # 碰撞选项 设置游戏角色穿过物体 # 在场景中添加Sphere和Cube Place Actors \u0026gt; Shapes 设置游戏角色Capsule组件的碰撞选项 # BP_STUBaseCharacter \u0026gt; Capsule Component \u0026gt; Details \u0026gt; Collision 碰撞预设默认为Pawn 将碰撞预设置为Custom 设置Sphere的碰撞选项 # 将碰撞预设设置为Custom 允许游戏角色穿过 对物体类型的碰撞反馈中, 设置对Pawn执行Overlap Collision Responses \u0026gt; Object Responses \u0026gt; Pawn, 勾选Overlap 设置Cube的碰撞选项 # 设置 Collision Preset 为Custom 允许Pawn穿过 查看 # 游戏角色可以穿过Sphere和Cube # 游戏角色与物体碰撞时, 镜头会放大, 这是Camera通道对于Block设置给出的碰撞反馈 # 可以在SpringArm组件设置碰撞探测通道, 默认使用Camera通道 Camera组件作为SpringArm组件的下级组件, 是游戏角色的一部分, 此时也与物体碰撞 之所以会放大镜头, 在于发生碰撞时要表示阻挡; 我们不应该看到已经穿过物体那部分 设置Camera通道忽略物体 # 查看SpringArm组件 # BP_STUBaseCharacter \u0026gt; 选中SpringArmComponent \u0026gt; Details \u0026gt; Camera Collision \u0026gt; Probe Channel SpringArm组件如何进行碰撞探测, 默认为Camera通道 Probe Channel Camera 设置Camera通道忽略Sphere # Collision Responses \u0026gt; Trace Responses \u0026gt; Camera, 选择Ignore 查看: 游戏角色穿过Sphere时, 感官上正常 # 产生重叠事件: 输出Actor信息 # 在蓝图中处理事件 # 打开 BP_STUBaseCharacter \u0026gt; Event Graph Event ActorBeginOverlap 之后, 在屏幕打印 PrintString OtherActor作为PrintString输入, 实际输出产生碰撞的物体名称 为物体勾选发生碰撞时产生重叠事件 # Sphere Details \u0026gt; 勾选 Generate Overlap Events Cube Details \u0026gt; 勾选 Generate Overlap Events 查看日志 # 产生碰撞事件: 获取碰撞信息 # 为物体勾选发生碰撞时产生碰撞事件 # 选择Cube, 去到Details面板, 勾选 Simulation Generates Hit Events 在蓝图中添加事件 # BP_STUBaseCharacter \u0026gt; EventGraph, 添加EventHit 补充： 要求物体与Cube的碰撞反馈互为Block，发生碰撞时，才会产生碰撞事件 # 自定义物体类型 # 项目设置 \u0026gt; Engine \u0026gt; Collision 创建物体类型Enemy # New Object Channel 设置 - Name Enemy Default Response Block 其他类型物体对Enemy采取Block 创建物体类型Geometry # New Object Channel 设置 - Name Geometry Default Response Ignore 其他类型物体对Geometry采取Ignore 查看游戏角色的碰撞选项 # - Enemy Block Geometry Ignore 设置Cube # 物体类型为Geometry 忽略Pawn 设置Sphere # 物体类型为Enemy 阻挡Pawn "}),e.add({id:23,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%89%8D%E5%90%8E%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8/",title:"实现游戏角色前后左右移动",description:"概览 # 举例 轴映射 连续 前后左右移动 动作映射 离散 跳跃，装弹，更换武器 绑定移动键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 Scale MoveRight Left/A -1 Right/D 1 MoveForward Up/W 1 Down/S -1 实现前后左右移动逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 方向 输入处理 MoveForward MoveForward GetActorForwardVector AddMovementInput MoveRight MoveRight GetActorRightVector AddMovementInput 实现回调函数 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/InputComponent.h\u0026quot; void ASTUBaseCharacter::MoveForward(float Amount) { AddMovementInput(GetActorForwardVector(), Amount); } void ASTUBaseCharacter::MoveRight(float Amount) { AddMovementInput(GetActorRightVector(), Amount); } 绑定到函数描述 ShootThemUp: Player/STUBaseCharacter.",content:"概览 # 举例 轴映射 连续 前后左右移动 动作映射 离散 跳跃，装弹，更换武器 绑定移动键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 Scale MoveRight Left/A -1 Right/D 1 MoveForward Up/W 1 Down/S -1 实现前后左右移动逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 方向 输入处理 MoveForward MoveForward GetActorForwardVector AddMovementInput MoveRight MoveRight GetActorRightVector AddMovementInput 实现回调函数 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/InputComponent.h\u0026quot; void ASTUBaseCharacter::MoveForward(float Amount) { AddMovementInput(GetActorForwardVector(), Amount); } void ASTUBaseCharacter::MoveRight(float Amount) { AddMovementInput(GetActorRightVector(), Amount); } 绑定到函数描述 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;MoveForward\u0026quot;, this, \u0026amp;ASTUBaseCharacter::MoveForward); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;MoveRight\u0026quot;, this, \u0026amp;ASTUBaseCharacter::MoveRight); 添加函数声明 ShootThemUp: Player/STUBaseCharacter.h private 编译ShootThemUp "}),e.add({id:24,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%AD%BB%E4%BA%A1%E9%80%BB%E8%BE%91/",title:"添加游戏角色死亡逻辑",description:"说明 # 生命值修改时, 同步到HealthTextComponent组件 # 生命值为0，销毁游戏角色 # 死亡时, 播放死亡动画 # 动画剪辑 # Animation Montage 可以将多个动画组合播放。把希望连续播放的动画添加到时间线 timeline ，在代码或蓝图中播放动画剪辑 命名：以AM_打头 Slot # 若此时播放动画剪辑，输出输入动画和动画剪辑的拼接；若无动画剪辑在播放，输出输入动画 添加委托：当生命值更改时，同步到HealthTextComponent文本 # C++ 屏蔽当前HealthTextComponent文本的设置 # ShootThemUp: Player/STUBaseCharacter.cpp 屏蔽Tick函数中的文本更新 初始化HealthTextComponent文本 # ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); HealthComponent提供委托服务: 生命值修改通知 # - 多播 仅C++ 在HealthComponent定义委托类型FChangeHealthSignature # ShootThemUp: Components/STUHealthComponent.h DECLARE_MULTICAST_DELEGATE(FChangeHealthSignature); 添加数据成员OnChangeHealth，提供委托服务 # public ShootThemUp: Components/STUHealthComponent.h FChangeHealthSignature OnChangeHealth; 封装修改Health逻辑，调用时通知客户端 # 只能通过SetHealth接口修改生命值 函数定义 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::SetHealth(float NewHealth) { Health = NewHealth; OnChangeHealth.Broadcast(); } 函数声明 private ShootThemUp: Components/STUHealthComponent.",content:"说明 # 生命值修改时, 同步到HealthTextComponent组件 # 生命值为0，销毁游戏角色 # 死亡时, 播放死亡动画 # 动画剪辑 # Animation Montage 可以将多个动画组合播放。把希望连续播放的动画添加到时间线 timeline ，在代码或蓝图中播放动画剪辑 命名：以AM_打头 Slot # 若此时播放动画剪辑，输出输入动画和动画剪辑的拼接；若无动画剪辑在播放，输出输入动画 添加委托：当生命值更改时，同步到HealthTextComponent文本 # C++ 屏蔽当前HealthTextComponent文本的设置 # ShootThemUp: Player/STUBaseCharacter.cpp 屏蔽Tick函数中的文本更新 初始化HealthTextComponent文本 # ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); HealthComponent提供委托服务: 生命值修改通知 # - 多播 仅C++ 在HealthComponent定义委托类型FChangeHealthSignature # ShootThemUp: Components/STUHealthComponent.h DECLARE_MULTICAST_DELEGATE(FChangeHealthSignature); 添加数据成员OnChangeHealth，提供委托服务 # public ShootThemUp: Components/STUHealthComponent.h FChangeHealthSignature OnChangeHealth; 封装修改Health逻辑，调用时通知客户端 # 只能通过SetHealth接口修改生命值 函数定义 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::SetHealth(float NewHealth) { Health = NewHealth; OnChangeHealth.Broadcast(); } 函数声明 private ShootThemUp: Components/STUHealthComponent.h 修改OnTakeAnyDamage # ShootThemUp: Components/STUHealthComponent.cpp // Health -= Damage; SetHealth(Health - Damage); STUBaseCharacter注册委托服务: OnChangeHealth # - 仅C++ AddUObject 搭建框架: 注册生命值修改通知 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnChangeHealth() {} 注册委托服务 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthComponent-\u0026gt;OnChangeHealth.AddUObject(this, \u0026amp;ASTUBaseCharacter::OnChangeHealth); 函数声明 private ShootThemUp: Player/STUBaseCharacter.h 实现处理函数OnChangeHealth # 设置HealthTextComponent文本 ShootThemUp: Player/STUBaseCharacter.cpp // OnChangeHealth HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); Character和其组件调用BeginPlay的先后顺序 # 先调用Component的BeginPlay，再调用Character的BeginPlay。 先由HealthComponent在BeginPlay初始化Health, 才轮到Character在BeginPlay中注册服务。 若我们没有在Character的BeginPlay中初始化HealthTextComponent文本，当Character在BeginPlay中注册服务完成，HealthTextComponent 文本显示为0。直到Health再次被更改，Character才会收到通知同步。 游戏角色死亡后，生命值不再减少 # C++ 提供接口，判断Character是否死亡 # public ShootThemUp: Components/STUHealthComponent.h UFUNCTION(BlueprintCallable) bool IsDead() const { return Health \u0026lt;= 0.0f; } Character死亡之后，生命值不再减少 # 若伤害的数量特征不大于0，或者当前生命值不大于0，无法继续对Character造成伤害 ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage if (Damage \u0026lt;= 0.0f || IsDead()) return; 限制Health范围 # ShootThemUp: Components/STUHealthComponent.cpp // Health = NewHealth; Health = FMath::Clamp(NewHealth, 0.0f, MaxHealth); 添加委托：游戏角色死亡，销毁Character # C++ 当生命值发生改变时修改HealthText文本，当生命值变为0时销毁Character，一码归一码 HealthComponent提供委托服务: 游戏角色死亡通知 # - 多播 仅C++ 在HealthComponent定义委托类型FDeathSignature # ShootThemUp: Components/STUHealthComponent.h DECLARE_MULTICAST_DELEGATE(FDeathSignature); 添加数据成员OnDeath，提供委托服务 # public ShootThemUp: Components/STUHealthComponent.h FDeathSignature OnDeath; Character死亡，通知客户端 # ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage if (IsDead()) { OnDeath.Broadcast(); } STUBaseCharacter注册委托服务: OnDeath # - 仅C++ AddUObject 搭建框架: 注册死亡通知 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnDeath() {} 注册委托服务 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthComponent-\u0026gt;OnDeath.AddUObject(this, \u0026amp;ASTUBaseCharacter::OnDeath); 函数声明 private ShootThemUp: Player/STUBaseCharacter.h 实现处理函数OnDeath # 添加销毁延时 protected ShootThemUp: Player/STUBaseCharacter.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;10.0\u0026quot;)) float LifeSpanOnDeath = 5.0f; 检查CharacterMovement组件有效性 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay check(GetCharacterMovement()); 剥夺玩家对游戏角色的控制权，开启定时器销毁Character ShootThemUp: Player/STUBaseCharacter.cpp // OnDeath GetCharacterMovement()-\u0026gt;DisableMovement(); SetLifeSpan(LifeSpanOnDeath); 创建死亡动画剪辑 # 虚幻编辑器 之前的跳跃、跑步、转向动画，均对应状态机中的一个状态。如果游戏角色死亡拥有对应状态，每个状态都可能迁移到死亡状态，光是想想都觉得麻烦 使用动画剪辑 AnimMontage 资产，当游戏角色死亡时，播放死亡动画剪辑, 通过slot连接当前动画和死亡动画剪辑 创建AnimMontage资产 # - 死亡动画资产 ExternalContent/Animation/Animations/TTP_Animations/Death 选中死亡动画资产，右键 \u0026gt; Create \u0026gt; Create AnimMontage \u0026gt; 命名为AM_Death 移动到Content/Player/Animations路径下 在动画蓝图中添加Slot # ABP_BaseCharacter \u0026gt; AnimGraph 在Locomotion和OutputPose之间添加Slot # Slot和AM_Death的分组一致 # Slot - SlotName DefaultGroup.DefaultSlot AM_Death - Montage DefaultGroup.DefaultSlot 设置动画剪辑 # AM_Death 死亡动画结束后，不再播放其他动画 Asset Details \u0026gt; BlendOptions \u0026gt; EnableAutoBlendOut，取消勾选 游戏角色死亡时，播放动画剪辑 # C++ C++类型 动画剪辑 AnimMontage UAnimMontage 添加UAnimMontage类型数据成员 # protected ShootThemUp: Player/STUBaseCharacter.h UPROPERTY(EditDefaultsOnly) UAnimMontage *DeathAnimMontage; Character死亡时，播放动画剪辑 # ShootThemUp: Player/STUBaseCharacter.cpp // OnDeath PlayAnimMontage(DeathAnimMontage); 查看 # 虚幻编辑器 设置游戏角色死亡时播放的动画剪辑 BP_STUBaseCharacter 效果图 禁止移动Character之后，销毁Character之前，仍可以移动Camera；即，水平旋转视角时可以旋转Character "}),e.add({id:25,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%B0%84%E5%87%BB%E8%BD%A8%E8%BF%B9/",title:"射击轨迹",description:"概览 # Line Trace 获取Socket变换信息 获取游戏角色Camera组件的变换信息 射击游戏对发射子弹的建模 完成轨迹计算并获取碰撞信息 绘制子弹轨迹和交点 为轨迹计算添加屏蔽Actor Socket # 之前我们使用Socket作为锚来附加武器 现在我们使用它来标记枪口, 获取变换信息 为网格体Rifle添加Socket标记枪口, 获取变换信息 # 虚幻编辑器 双击打开 Content \u0026gt; ExternalContent \u0026gt; Weapon \u0026gt; Weapons \u0026gt; Rifle 选中 Skeleton Tree \u0026gt; RifleRoot , 右键, 选择 Add Socket , 命名为MuzzleSocket 在细节面板设置MuzzleSocket的位置 Relative Location 默认在武器坐标系的0坐标, 调整到枪口位置 更换观察视角, 检查MuzzleSocket变换参数 Top视角 模拟射击: 绘制子弹轨迹 # C++ STUBaseWeapon - 起点 枪口 MuzzleSocket的位置分量 偏移 放大的武器朝向 MuzzleSocket的前进方向: 通过MuzzleSocket的旋转分量, 获取前进向量 终点 起点 + 偏移 获取MuzzleSocket变换以得到线段所需信息 # Stub MuzzleSocketName 保存Socket名称 TraceMaxDistance 放大系数, 亦是子弹射击距离; 1 unreal unit = 1 cm 获取Socket变换 # 加载WeaponMeshComponent时检查其有效性",content:`概览 # Line Trace 获取Socket变换信息 获取游戏角色Camera组件的变换信息 射击游戏对发射子弹的建模 完成轨迹计算并获取碰撞信息 绘制子弹轨迹和交点 为轨迹计算添加屏蔽Actor Socket # 之前我们使用Socket作为锚来附加武器 现在我们使用它来标记枪口, 获取变换信息 为网格体Rifle添加Socket标记枪口, 获取变换信息 # 虚幻编辑器 双击打开 Content \u0026gt; ExternalContent \u0026gt; Weapon \u0026gt; Weapons \u0026gt; Rifle 选中 Skeleton Tree \u0026gt; RifleRoot , 右键, 选择 Add Socket , 命名为MuzzleSocket 在细节面板设置MuzzleSocket的位置 Relative Location 默认在武器坐标系的0坐标, 调整到枪口位置 更换观察视角, 检查MuzzleSocket变换参数 Top视角 模拟射击: 绘制子弹轨迹 # C++ STUBaseWeapon - 起点 枪口 MuzzleSocket的位置分量 偏移 放大的武器朝向 MuzzleSocket的前进方向: 通过MuzzleSocket的旋转分量, 获取前进向量 终点 起点 + 偏移 获取MuzzleSocket变换以得到线段所需信息 # Stub MuzzleSocketName 保存Socket名称 TraceMaxDistance 放大系数, 亦是子弹射击距离; 1 unreal unit = 1 cm 获取Socket变换 # 加载WeaponMeshComponent时检查其有效性
在BeginPlay中调用; 使用时不必检查 check(WeaponMeshComponent); 获取变换
参数: Socket名 返回相对于指定座标系的Socket变换, 默认是世界座标系 const FTransform SocketTransform = WeaponMeshComponent-\u0026gt;GetSocketTransform(MuzzleSocketName); // 默认世界坐标系 获取起点 # const FVector TraceStart = SocketTransform.GetLocation(); 获取武器的朝向 # const FVector ShootDirection = SocketTransform.GetRotation().GetForwardVector(); // 单位向量 // GetRotation返回类型FQuat // 在此处FQuat比FRotator更方便, 因为GetForwardVector的存在, 可以获取X轴分量 计算终点 # const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; 绘制线段 # 获取World对象 # #include \u0026quot;Engine/World.h\u0026quot; if(!GetWorld()) return; 绘制线段 # 参数 bPersistentLines 是否一直存在 false LifeTime 持续时间, 单位s 3 DepthPriority 绘制优先级 0 #include \u0026quot;DrawDebugHelpers.h\u0026quot; DrawDebugLine(GetWorld(), TraceStart, TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); 完整代码 # 添加数据成员 # ShootThemUp: Weapon/STUBaseWeapon.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) FName MuzzleSocketName = \u0026quot;MuzzleSocket\u0026quot;; UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float TraceMaxDistance = 1500.0f; // 1 unreal unit = 1cm \u0026gt; 15m 检查WeaponMeshComponent # ShootThemUp: Weapon/STUBaseWeapon.cpp // BeginPlay check(WeaponMeshComponent); MakeShot # 包含发射子弹的所有逻辑; 如温切斯特连发步枪, 扣一下扳机, 连发数枚子弹, 所以和Fire分开 ShootThemUp: Weapon/STUBaseWeapon.h protected void MakeShot(); ShootThemUp: Weapon/STUBaseWeapon.cpp #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;DrawDebugHelpers.h\u0026quot; void ASTUBaseWeapon::MakeShot() { if(!GetWorld()) return; const FTransform SocketTransform = WeaponMeshComponent-\u0026gt;GetSocketTransform(MuzzleSocketName); const FVector TraceStart = SocketTransform.GetLocation(); const FVector ShootDirection = SocketTransform.GetRotation().GetForwardVector(); const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; DrawDebugLine(GetWorld(), TraceStart, TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); } 在Fire中调用 在虚幻编辑器中查看 # 点击鼠标左键, 触发Fire 轨迹与枪口垂直: 未设置MuzzleSocket旋转信息, 需要与世界座标系对应轴方向一致 配置MuzzleSocket旋转信息 # Rifle \u0026gt; Details 当前 前进方向对应X轴方向, 使MuzzleSocket座标系绕自己的Y轴逆时针旋转90度 Relative Rotation \u0026gt; Pitch = 90 向上方向对应Z轴方向, 使MuzzleSocket座标系绕自己的X轴顺时针旋转90度 Relative Rotation \u0026gt; Roll = -90 效果图 模拟射击: 绘制相交点 # C++ 给出子弹轨迹的起点和终点, 计算场景中与轨迹碰撞的物体, 保存到FHitResult对象中 HitResult存放碰撞结果 # 包含以下信息 - 数据成员 碰撞时间 交点 ImpactPoint 法向量 指向碰撞Actor的指针 碰撞标志 bBlockingHit \u0026hellip; 需要交点信息 计算与轨迹发生碰撞的Actor # Engine提供多个碰撞计算函数, 我们使用UWorld::LineTraceSingleByChannel LineTraceSingleByChannel返回true则有碰撞, false则无; 而HitResult中亦有bBlockingHit 如果发生碰撞, LineTraceSingleByChannel通过函数参数返回与线段第一个发生碰撞的物体信息 - ECollisionChannel::ECC_Visibility 阻挡了Visibility的物体才参与轨迹计算 FHitResult HitResult; GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility); 绘制相交点 # if (HitResult.bBlockingHit) { DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); } 完整代码 # ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot FHitResult HitResult; GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility); if (HitResult.bBlockingHit) { DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); } 查看相交点 # 虚幻编辑器 查看游戏角色Capsule组件的碰撞选项 # BP_STUBaseCharacter \u0026gt; CapsuleComponent \u0026gt; Collision Collision Presets为Custom Trace Responses \u0026gt; Visibility为Block 为Overlap或Ignore时, 不会参与相交计算 射中时, 以交点为圆心绘制球 # 注意到, 瞄准十字与子弹轨迹不重合 # 射击游戏中发射子弹建模 # C++ 子弹从枪口射出, 是对真实世界中的射击进行模拟. 射击游戏中, 子弹从Camera组件位置射出. 该建模也适用于VR Virtual Reality 需要将子弹轨迹的起点改为Camera组件的位置 在武器类获取游戏角色Camera组件的变换信息 # 之前旋转游戏角色视角那里, 有提到是通过游戏角色控制器旋转Camera组件完成的; 获取游戏角色Camera组件的变换信息, 亦是通过游戏角色控制器得到 可以通过游戏角色获取其所属控制器 可以通过武器组件获取其所属游戏角色 武器组件生成武器时, 可以为武器设置所属, 即设置武器属于游戏角色 武器 \u0026gt; 游戏角色 \u0026gt; 游戏角色控制器 \u0026gt; 游戏角色Camera组件的变换信息 武器类生成武器时, 设置其属于游戏角色 # STUWeaponComponent SpawnActor时, 可以通过FActorSpawnParameters设置其所属; 或者调用SetOwner, 武器的Owner和WeaponComponent的Owner相同 使用GetOwner函数和Character数据成员均可获取武器类所属游戏角色 // CurrentWeapon-\u0026gt;SetOwner(GetOwner()); CurrentWeapon-\u0026gt;SetOwner(Character); 获取游戏角色控制器 # STUBaseWeapon #include \u0026quot;GameFramework/Character.h\u0026quot; #include \u0026quot;GameFramework/PlayerController.h\u0026quot; const auto Player = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Player) return; const auto Controller = Player-\u0026gt;GetController\u0026lt;APlayerController\u0026gt;(); if (!Controller) return; 通过游戏角色控制器获取Camera组件的变换信息: 位置和旋转 # PlayerCameraManager是全局类, 负责管理Camera, 可以直接获取Character的Camera组件 GetPlayerViewPoint访问PlayerCameraManager类 FVector ViewLocation; FRotator ViewRotation; Controller-\u0026gt;GetPlayerViewPoint(ViewLocation, ViewRotation); 重新计算子弹轨迹和碰撞信息 # - 起点 Camera组件位置 偏移 Camera组件旋转 const FVector TraceStart = ViewLocation; const FVector ShootDirection = ViewRotation.Vector(); const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; FHitResult HitResult; GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility); 绘制子弹轨迹和交点 # 子弹从Camera组件所在射出; 若击中, 到击中物体结束, 否则, 绘制射程 绘制子弹轨迹时, 起点仍是枪口, 终点为击中物体或射程终点 若击中物体, 绘制交点 if (HitResult.bBlockingHit) { DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f); DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); } else { DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); } 完整代码 # ShootThemUp: Components/STUWeaponComponent.cpp // SpawnWeapon CurrentWeapon-\u0026gt;SetOwner(Character); ShootThemUp: Weapon/STUBaseWeapon.cpp #include \u0026quot;GameFramework/Character.h\u0026quot; #include \u0026quot;GameFramework/PlayerController.h\u0026quot; // MakeShot void ASTUBaseWeapon::MakeShot() { if(!GetWorld()) return; const auto Player = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Player) return; const auto Controller = Player-\u0026gt;GetController\u0026lt;APlayerController\u0026gt;(); if (!Controller) return; FVector ViewLocation; FRotator ViewRotation; Controller-\u0026gt;GetPlayerViewPoint(ViewLocation, ViewRotation); const FVector TraceStart = ViewLocation; const FVector ShootDirection = ViewRotation.Vector(); const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; FHitResult HitResult; GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility); if (HitResult.bBlockingHit) { DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f); DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); } else { DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); } } 查看 # 击中 未击中: 真实起点是Camera组件位置 终点和瞄准十字重合 击中游戏角色时, 交点在骨骼网格体上 # 虚幻编辑器 当前击中游戏角色时, 交点在Capsule组件上 # 放大Capsule组件显示 # 打开BP_STUBaseCharacter, 选择CapsuleComponent, 去到Details \u0026gt; Shape 当前 设置 - Capsule Half Height 88 Capsule Radius 88 显示Capsule组件 # 打开Console 执行命令 show collision 效果图 # 轨迹计算时, 忽略游戏角色Capsule组件, 将骨骼网格体考虑在内 # 设置Capsule组件的碰撞选项 # BP_STUBaseCharacter \u0026gt; CapsuleComponent \u0026gt; Details \u0026gt; Collision \u0026gt; Collision Presets 当前 TraceResponses \u0026gt; Visibility为Block, Capsule组件参与轨迹计算 设置碰撞预设为Pawn TraceResponses \u0026gt; Visibility为Ignore, Capsule组件不参与轨迹计算 设置骨骼网格体的碰撞选项 # BP_STUBaseCharacter \u0026gt; Mesh \u0026gt; Details \u0026gt; Collision \u0026gt; Collision Presets 碰撞预设默认为CharacterMesh, TraceResponses \u0026gt; Visibility为Ignore, 骨骼网格体不参与轨迹计算 将碰撞预设设置为Custom, 将TraceResponses \u0026gt; Visibility设置为Block, 使骨骼网格体参与轨迹计算 查看 # 可以击中骨骼网格体 子弹可以穿过游戏角色两腿之间而不被Capsule组件阻挡 恢复CapsuleComponent的Shape # 当前的问题: 射程的起点为Camera组件位置, 理论上, 我们可以打到枪口无法打到的位置 # 和敌人背对背时击中敌人 没调出来 解决思路: 要求武器朝向和子弹真实轨迹的夹角为锐角 打到自己 BP_STUBaseCharacter \u0026gt; Camera组件 \u0026gt; Details \u0026gt; Transform \u0026gt; Location, 将XYZ置为0 解决思路: 轨迹计算时, 屏蔽游戏角色本身 轨迹计算时屏蔽游戏角色本身 # C++ 设置轨迹计算参数 FCollisionQueryParams # 添加屏蔽Actor ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot FCollisionQueryParams CollisionParams; // CollisionParams.AddIgnoredActor(Player); CollisionParams.AddIgnoredActor(GetOwner()); 计算与轨迹发生碰撞的Actor: 修改参数 # ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility, CollisionParams); 击中时, 输出骨骼信息 # 对不同部位造成伤害时, 游戏角色减少的生命值不同; 比如爆头可以导致游戏角色死亡 存放在FHitResult中 # C++ ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Bone: %s\u0026quot;), *HitResult.BoneName.ToString()); 查看日志 # 虚幻编辑器 `}),e.add({id:26,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A7%86%E8%A7%92%E6%97%8B%E8%BD%AC/",title:"实现游戏角色视角旋转",description:"说明 # 视角旋转 垂直方向 抬头低头 Camera绕Y轴旋转 鼠标垂直方向位移决定旋转角度 水平方向 环顾左右 Camera绕Z轴旋转 鼠标水平方向位移决定旋转角度 绑定旋转键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 LookUp MouseY TurnAround MouseX 实现视角旋转逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 LookUp LookUp AddControllerPitchInput 绕Y轴旋转，增加Y轴旋转角度(Pitch) TurnAround TurnAround AddControllerYawInput 绕Z轴旋转，增加Z轴旋转角度(Yaw) 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::LookUp(float Amount) {} void ASTUBaseCharacter::TurnAround(float Amount) {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTUBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::TurnAround); 添加函数声明 ShootThemUp: Player/STUBaseCharacter.",content:"说明 # 视角旋转 垂直方向 抬头低头 Camera绕Y轴旋转 鼠标垂直方向位移决定旋转角度 水平方向 环顾左右 Camera绕Z轴旋转 鼠标水平方向位移决定旋转角度 绑定旋转键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 LookUp MouseY TurnAround MouseX 实现视角旋转逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 LookUp LookUp AddControllerPitchInput 绕Y轴旋转，增加Y轴旋转角度(Pitch) TurnAround TurnAround AddControllerYawInput 绕Z轴旋转，增加Z轴旋转角度(Yaw) 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::LookUp(float Amount) {} void ASTUBaseCharacter::TurnAround(float Amount) {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTUBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::TurnAround); 添加函数声明 ShootThemUp: Player/STUBaseCharacter.h private 添加静态日志类型 # ShootThemUp: Player/STUBaseCharacter.cpp DEFINE_LOG_CATEGORY_STATIC(LogBaseCharacter, All, All); 实现回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::LookUp(float Amount) { AddControllerPitchInput(Amount); UE_LOG(LogBaseCharacter, Log, TEXT(\u0026quot;LookUp Amount: %f\u0026quot;), Amount); } void ASTUBaseCharacter::TurnAround(float Amount) { AddControllerYawInput(Amount); } 编译ShootThemUp并运行 # 视角可以在水平方向旋转, 身体跟随旋转 无法在垂直方向旋转 查看日志，鼠标向上移动时，Amount为正数 使视角可以在垂直方向旋转 # 虚幻编辑器 CameraComponent的UsePawnControlRotation选项 # 设置CamerComponent是否跟随Pawn旋转 勾选 BP_STUBaseCharacter \u0026gt; CameraComponent \u0026gt; UsePawnControlRotation 选中Camera Component \u0026gt; 细节面板 \u0026gt; CameraOptions \u0026gt; 勾选UsePawnControlRotation 编译并运行 向下移动鼠标，Camera向上旋转; 向上移动鼠标，Camera向下旋转 旋转中心点为CameraComponent PlayerController的InputPitchScale选项 # 游戏角色旋转的逻辑是通过旋转PlayerController完成的 游戏角色视角垂直方向旋转反向InputPitchScale有关，该参数默认为负数, 已退化 参考 InputPitchScale, InputYawScale, InputRollScale的绝对值对应旋转速度 引擎版本 5.1 之前，可以在 PlayerController蓝图类 的细节面板查看 InputPitchScale 打印InputPitchScale # 解决方法一: 将InputPitchScale设为正数 # 解决方法二: 将LookUp的Scale改为-1 # 善后 # 采用解决方法二 去除 BP_STUPlayerController 中的打印和InputPitchScale设置 去除 C++ LookUp 中的日志打印 游戏角色视角绕Z轴旋转时，使中心点为游戏角色 # 为STUBaseCharacter添加USpringArmComponent类型成员 # C++ 添加SpringArmComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h // 前向声明 class USpringArmComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USpringArmComponent *SpringArmComponent; 初始化组件, 设置SpringArmComponent默认跟随Pawn旋转 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;GameFrameWork/SpringArmComponent.h\u0026quot; // 默认构造函数 SpringArmComponent = CreateDefaultSubobject\u0026lt;USpringArmComponent\u0026gt;(\u0026quot;SpringArmComponent\u0026quot;); SpringArmComponent-\u0026gt;SetupAttachment(GetRootComponent()); SpringArmComponent-\u0026gt;bUsePawnControlRotation = true; 修改CameraComponent的上级组件为SpringArmComponent ShootThemUp: Player/STUBaseCharacter.cpp // 默认构造函数 // CameraComponent-\u0026gt;SetupAttachment(GetRootComponent()); CameraComponent-\u0026gt;SetupAttachment(SpringArmComponent); 编译ShootThemUp 配置SpringArmComponent # 虚幻编辑器 BP_STUBaseCharacter 查看SpringArmComponent和CameraComponent # 关于bUsePawnControlRotation设置 # UCameraComponent 和 USpringArmComponent 均有该数据成员 在代码中设置 bUsePawnControlRotation ，设置的是类数据成员初始值。在蓝图编辑器中，对基于C++类的蓝图类数据成员恢复默认值，得到类数据成员初始值 为参数添加默认值，不会改变参数已有值 清除CameraComponent的相对变换，置UsePawnControlRotation为false # 设置SpringArmComponent和CameraComponent的相对变换 # 查看 SpringArmComponent 臂长参数 设置CameraComponent相对SpringArmComponent的偏移 CameraComponent和SpringArmComponent的bUsePawnControlRotation生效问题 # - 二者均为 true SpringArmComponent的生效，Camera以游戏角色为中心绕Y轴旋转 二者均为 false Camera不可绕Y轴旋转 仅 CameraComponent 的为true 以Camera为中心绕Y轴旋转 仅 SpringArmComponent 的为true Camera以游戏角色为中心绕Y轴旋转 为Character绑定动画 # 虚幻编辑器 BP_STUBaseCharacter 绑定动画 选中Mesh组件 \u0026gt; Details \u0026gt; Animation - Animation Mode Use Animation Asset Anim To Play Run_Fwd 可能存在动画下拉框无可选项的情况, 需要重新为动画绑定骨骼网格体 编译并运行 优化视角旋转逻辑 # C++ STUBaseCharacter LookUp, TurnAround, AddControllerPitchInput和AddControllerYawInput的函数签名一致 void LookUp(float Amount); void TurnAround(float Amount); void AddControllerPitchInput(float Val); void AddControllerYawInput(float Val) 屏蔽 LookUp 和 TurnAround ShootThemUp: Player/STUBaseCharacter.cpp ShootThemUp: Player/STUBaseCharacter.h 函数描述直接绑定 AddControllerPitchInput 和 AddControllerYawInput ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent // PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTUBaseCharacter::LookUp); // PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::TurnAround); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;Lookup\u0026quot;, this, \u0026amp;ASTUBaseCharacter::AddControllerPitchInput); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::AddControllerYawInput) 编译并运行 "}),e.add({id:27,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E8%A7%82%E5%AF%9F%E8%A7%86%E8%A7%92/",title:"添加观察视角",description:"说明 # 当游戏角色生命值为0，我们尝试剥夺玩家对游戏角色的控制，此时仍能旋转Camera; 左右旋转视角时, Character身体也会旋转 我们可以在游戏角色死亡时，切换玩家控制的Pawn：一方面，彻底剥夺玩家对游戏角色的控制，另一方面，允许玩家做合理的操作 观察视角 # 对应一个APawn派生类，ASpectatorPawn 关卡的默认类型里，观察者类使用ASpectatorPawn 玩家死亡后，使其操控SpectatorPawn，仍能继续观看游戏 场景中的SpectatorPawn # 漂浮的Camera，除了可以前后左右移动，还可以上下移动，亦支持旋转，由鼠标控制 本小节使用默认的观察者类 # 游戏角色死亡后，切换到观察视角 # C++ 先前我们已设置STUGameModeBase使用STUPlayerController类。 APawn::Controller和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STUPlayerController的。 游戏角色死亡时，切换到观察视角 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;GameFramework/Controller.h\u0026quot; // OnDeath if (Controller) { Controller-\u0026gt;ChangeState(NAME_Spectating); } 查看 # 虚幻编辑器 查看SpectatorPawn # WorldSetting中，GameMode默认选择SpectatorPawn作为Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 # Character死亡后，世界大纲新增SpectatorPawn1 ",content:"说明 # 当游戏角色生命值为0，我们尝试剥夺玩家对游戏角色的控制，此时仍能旋转Camera; 左右旋转视角时, Character身体也会旋转 我们可以在游戏角色死亡时，切换玩家控制的Pawn：一方面，彻底剥夺玩家对游戏角色的控制，另一方面，允许玩家做合理的操作 观察视角 # 对应一个APawn派生类，ASpectatorPawn 关卡的默认类型里，观察者类使用ASpectatorPawn 玩家死亡后，使其操控SpectatorPawn，仍能继续观看游戏 场景中的SpectatorPawn # 漂浮的Camera，除了可以前后左右移动，还可以上下移动，亦支持旋转，由鼠标控制 本小节使用默认的观察者类 # 游戏角色死亡后，切换到观察视角 # C++ 先前我们已设置STUGameModeBase使用STUPlayerController类。 APawn::Controller和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STUPlayerController的。 游戏角色死亡时，切换到观察视角 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;GameFramework/Controller.h\u0026quot; // OnDeath if (Controller) { Controller-\u0026gt;ChangeState(NAME_Spectating); } 查看 # 虚幻编辑器 查看SpectatorPawn # WorldSetting中，GameMode默认选择SpectatorPawn作为Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 # Character死亡后，世界大纲新增SpectatorPawn1 "}),e.add({id:28,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E9%87%8D%E6%9E%84makeshot/",title:"重构MakeShot",description:"说明 # 本节使用的重构被称作提取 The Extract Method , 将函数切分, 使得代码可读性更高 对武器类的MakeShot重构 纯理论逻辑放在 protected , 供派生类调用 调整逻辑 # void ASTUBaseWeapon::MakeShot() { if(!GetWorld()) return; // 获取PlayerController const auto Player = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Player) return; const auto Controller = Player-\u0026gt;GetController\u0026lt;APlayerController\u0026gt;(); if (!Controller) return; // 通过Controller获取CameraComponent的位置和方向 FVector ViewLocation; FRotator ViewRotation; Controller-\u0026gt;GetPlayerViewPoint(ViewLocation, ViewRotation); // 通过CameraComponent的位置和方向计算轨迹信息 const FVector TraceStart = ViewLocation; const FVector ShootDirection = ViewRotation.Vector(); const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; // 提供轨迹获取碰撞信息 FHitResult HitResult; FCollisionQueryParams CollisionParams; CollisionParams.",content:"说明 # 本节使用的重构被称作提取 The Extract Method , 将函数切分, 使得代码可读性更高 对武器类的MakeShot重构 纯理论逻辑放在 protected , 供派生类调用 调整逻辑 # void ASTUBaseWeapon::MakeShot() { if(!GetWorld()) return; // 获取PlayerController const auto Player = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Player) return; const auto Controller = Player-\u0026gt;GetController\u0026lt;APlayerController\u0026gt;(); if (!Controller) return; // 通过Controller获取CameraComponent的位置和方向 FVector ViewLocation; FRotator ViewRotation; Controller-\u0026gt;GetPlayerViewPoint(ViewLocation, ViewRotation); // 通过CameraComponent的位置和方向计算轨迹信息 const FVector TraceStart = ViewLocation; const FVector ShootDirection = ViewRotation.Vector(); const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; // 提供轨迹获取碰撞信息 FHitResult HitResult; FCollisionQueryParams CollisionParams; CollisionParams.AddIgnoredActor(GetOwner()); GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility, CollisionParams); // 获取枪口信息: 只用到了位置分量 const FTransform SocketTransform = WeaponMeshComponent-\u0026gt;GetSocketTransform(MuzzleSocketName); // 使用碰撞信息和枪口信息绘制轨迹和交点 if (HitResult.bBlockingHit) { DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f); DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Bone: %s\u0026quot;), *HitResult.BoneName.ToString()); } else { DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); } } 拆分 # ShootThemUp: Weapon/STUBaseWeapon.cpp GetPlayerController # APlayerController *ASTUBaseWeapon::GetPlayerController() const { const auto Player = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Player) return nullptr; return Player-\u0026gt;GetController\u0026lt;APlayerController\u0026gt;(); } GetPlayerViewPoint # bool ASTUBaseWeapon::GetPlayerViewPoint(FVector \u0026amp;ViewLocation, FRotator \u0026amp;ViewRotation) const { const auto Controller = GetPlayerController(); if (!Controller) return false; Controller-\u0026gt;GetPlayerViewPoint(ViewLocation, ViewRotation); return true; } GetTraceData # bool ASTUBaseWeapon::GetTraceData(FVector\u0026amp; TraceStart, FVector\u0026amp; TraceEnd) const { FVector ViewLocation; FRotator ViewRotation; if (!GetPlayerViewPoint(ViewLocation, ViewRotation)) return false; TraceStart = ViewLocation; const FVector ShootDirection = ViewRotation.Vector(); TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; return true; } MakeHit # void ASTUBaseWeapon::MakeHit(FHitResult \u0026amp;HitResult, const FVector \u0026amp;TraceStart, const FVector \u0026amp;TraceEnd) { if (!GetWorld()) return; FCollisionQueryParams CollisionParams; CollisionParams.AddIgnoredActor(GetOwner()); GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility, CollisionParams); } GetMuzzleWorldLocation # FVector ASTUBaseWeapon::GetMuzzleWorldLocation() const { return WeaponMeshComponent-\u0026gt;GetSocketLocation(MuzzleSocketName); } MakeShot # void ASTUBaseWeapon::MakeShot() { if (!GetWorld()) return; FVector TraceStart, TraceEnd; if (!GetTraceData(TraceStart, TraceEnd)) return; FHitResult HitResult; MakeHit(HitResult, TraceStart, TraceEnd); if (HitResult.bBlockingHit) { DrawDebugLine(GetWorld(), GetMuzzleWorldLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f); DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); // UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Bone: %s\u0026quot;), *HitResult.BoneName.ToString()); } else { DrawDebugLine(GetWorld(), GetMuzzleWorldLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); } } 添加声明 # protected ShootThemUp: Weapon/STUBaseWeapon.h APlayerController *GetPlayerController() const; bool GetPlayerViewPoint(FVector \u0026amp;ViewLocation, FRotator \u0026amp;ViewRotation) const; bool GetTraceData(FVector\u0026amp; TraceStart, FVector\u0026amp; TraceEnd) const; void MakeHit(FHitResult \u0026amp;HitResult, const FVector \u0026amp;TraceStart, const FVector \u0026amp;TraceEnd); FVector GetMuzzleWorldLocation() const; "}),e.add({id:29,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%B8%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%B7%BB%E5%8A%A0%E5%90%91%E5%89%8D%E8%B5%B0%E8%B7%AF%E5%8A%A8%E7%94%BB/",title:"为游戏角色添加向前走路动画",description:"概览 # 虚幻编辑器 动画随着游戏角色的运动速度而变化 brush # 最简单的可编辑几何体，我们可以修改其顶点位置，调整其他参数，然后将其转换成静态网格体 CharacterMovementComponent # 负责 Character 运动，其各种属性均和 Character 运动有关 动画蓝图 # Animation Blueprint 动画蓝图需绑定 Skeleton Mesh 命名：ABP_ 打头 动画混合 # Animation Blend 流畅地从一个动画切入到另一个动画 混合空间 # Blend Space 能在两个骨骼动画之间创建过渡动画 使用插值来得到动画姿势的中间值 需绑定 Skeleton Mesh 命名： 混合空间 和 混合空间1D 均以 BS_ 打头 一维混合空间 # Blend Space 1D 横轴 混合空间 # Blend Space 横轴和纵轴 重新设置平台 # 从场景中移除Floor 添加 Geometry/Box 恢复 Box Brush 默认位置，设置长宽高 Character运动速度上限 # BP_STUBaseCharacter CharacterMovementComponent 选择CharacterMovementComponent \u0026gt; 细节面板 \u0026gt; Character Movement: Walking \u0026gt; MaxWalkSpeed MaxWalkSpeed 即 Character 的最大运动速度，单位 cm/s 虚幻引擎里的步长使用 cm 修改 MaxWalkSpeed ，当速度改为 1600 时，可以看到单位时间内移动的距离增加，而跑步动画缺少对应的加速过程 获取实时速度并打印 # BP_STUBaseCharacter 在 EventGraph 实现 - GetVelocity函数 获取Character速度 获得Actor各个方向上的速度，保存在FVector中 FVector::VectorLength 获得速度标量 PrintString 在屏幕上输出实时速度 PrintString 使用 AddOnScreenDebugMessage 可以看到加速过程 移除打印 创建动画蓝图ABP_BaseCharacter # Animation Blueprint 创建文件夹Content/Players/Animations # 方法一: 基于Skeleton Mesh创建动画蓝图 # 选中ExternalContent/Animation/Characters/HeroTPP/HeroTPP \u0026gt; 右键 \u0026gt; Create \u0026gt; AnimBlueprint 方法二: 在指定位置创建动画蓝图 # 去到 Content/Player/Animations，右键 \u0026gt; Animation \u0026gt; 选择Animation Blueprint 选择 HeroTPP_Skeleton 命名为 ABP_BaseCharacter 在蓝图编辑器中查看动画蓝图 # ABP_BaseCharacter - EventGraph 事件图表 处理各种动画事件；像使用 Tick 一样使用 EventBlueprintUpdateAnimation AnimGraph 动画图表 处理所有动画；可以将动画资产作为 OutputPose 的输入 AssetBrowser 动画资产窗口 可以从 Window \u0026gt; AssetBrowser 打开，罗列了 SkeletonMesh 所有相关动画 为游戏角色设置动画时使用动画蓝图 # 为ABP_BaseCharacter设置输入 # 动画图表 将 Run_Fwd 作为 OutputPose 的输入 设置 Run_Fwd 重复播放 选中Run_Fwd \u0026gt; Details \u0026gt; Settings \u0026gt; 使能 LoopAnimation 让Character使用动画蓝图 # BP_STBaseCharacter - Animation Mode Use Animation Blueprint Anim Class ABP_BaseCharacter 查看动画资产 # 去到Content/ExternalContent/Animation/Animations/TTP_Animations，双击 Run_Fwd 可在 AssetBrowser 中选择其他动画 混合空间资产 # Blend Space 速度从 0 - 600 ，动画从 Idle 过渡到 Run_Fwd 创建BS_Locomotion_Walk_1D # 去到Content/Player/Animations，右键 选择 HeroTPP_Skeleton 命名为 BS_Locomotion_Walk_1D 配置BS_Locomotion_Walk_1D # 双击打开 BS_Locomotion_Walk_1D 配置横轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis 说明 Name 名称 Velocity Minimum Axis Value 轴最小值 0 Maximum Axis Value 轴最大值 600 游戏角色运动速度上限 Grid Divisions 过渡区间 4 使用默认值；和可以添加的动画个数有关 配置动画 动画资产 Velocity 起点 Idle 0 终点 Run_Fwd 600 查看插值 系统 键位 Windows Control MacOS Command 按下键位，水平移动鼠标，绿色X随之在起点和终点间移动，视口展示过渡动画 将BS_Locomotion_Walk_1D作为动画蓝图输入 # ABP_BaseCharacter 添加变量Velocity # 在 MyBlueprint 添加变量 Velocity ，在Details设置名称和类型 设置变量Velocity # EventGraph 将变量Velocity拖动到EventGraph, 选择设置变量值 在 EventBlueprintUpdateAnimation 之后，执行 SetVelocity GetPawnOwner 返回 Pawn 实例的引用, 变量 Velocity 的输入是 Actor 实时速度 设置动画蓝图输入 # AnimGraph 将BS_Locomotion_Walk_1D作为OutputPose的输入 将变量Velocity拖动到AnimGraph, 选择获取变量值 将变量Velocity作为BS_Locomotion_Walk_1D的输入 ",content:"概览 # 虚幻编辑器 动画随着游戏角色的运动速度而变化 brush # 最简单的可编辑几何体，我们可以修改其顶点位置，调整其他参数，然后将其转换成静态网格体 CharacterMovementComponent # 负责 Character 运动，其各种属性均和 Character 运动有关 动画蓝图 # Animation Blueprint 动画蓝图需绑定 Skeleton Mesh 命名：ABP_ 打头 动画混合 # Animation Blend 流畅地从一个动画切入到另一个动画 混合空间 # Blend Space 能在两个骨骼动画之间创建过渡动画 使用插值来得到动画姿势的中间值 需绑定 Skeleton Mesh 命名： 混合空间 和 混合空间1D 均以 BS_ 打头 一维混合空间 # Blend Space 1D 横轴 混合空间 # Blend Space 横轴和纵轴 重新设置平台 # 从场景中移除Floor 添加 Geometry/Box 恢复 Box Brush 默认位置，设置长宽高 Character运动速度上限 # BP_STUBaseCharacter CharacterMovementComponent 选择CharacterMovementComponent \u0026gt; 细节面板 \u0026gt; Character Movement: Walking \u0026gt; MaxWalkSpeed MaxWalkSpeed 即 Character 的最大运动速度，单位 cm/s 虚幻引擎里的步长使用 cm 修改 MaxWalkSpeed ，当速度改为 1600 时，可以看到单位时间内移动的距离增加，而跑步动画缺少对应的加速过程 获取实时速度并打印 # BP_STUBaseCharacter 在 EventGraph 实现 - GetVelocity函数 获取Character速度 获得Actor各个方向上的速度，保存在FVector中 FVector::VectorLength 获得速度标量 PrintString 在屏幕上输出实时速度 PrintString 使用 AddOnScreenDebugMessage 可以看到加速过程 移除打印 创建动画蓝图ABP_BaseCharacter # Animation Blueprint 创建文件夹Content/Players/Animations # 方法一: 基于Skeleton Mesh创建动画蓝图 # 选中ExternalContent/Animation/Characters/HeroTPP/HeroTPP \u0026gt; 右键 \u0026gt; Create \u0026gt; AnimBlueprint 方法二: 在指定位置创建动画蓝图 # 去到 Content/Player/Animations，右键 \u0026gt; Animation \u0026gt; 选择Animation Blueprint 选择 HeroTPP_Skeleton 命名为 ABP_BaseCharacter 在蓝图编辑器中查看动画蓝图 # ABP_BaseCharacter - EventGraph 事件图表 处理各种动画事件；像使用 Tick 一样使用 EventBlueprintUpdateAnimation AnimGraph 动画图表 处理所有动画；可以将动画资产作为 OutputPose 的输入 AssetBrowser 动画资产窗口 可以从 Window \u0026gt; AssetBrowser 打开，罗列了 SkeletonMesh 所有相关动画 为游戏角色设置动画时使用动画蓝图 # 为ABP_BaseCharacter设置输入 # 动画图表 将 Run_Fwd 作为 OutputPose 的输入 设置 Run_Fwd 重复播放 选中Run_Fwd \u0026gt; Details \u0026gt; Settings \u0026gt; 使能 LoopAnimation 让Character使用动画蓝图 # BP_STBaseCharacter - Animation Mode Use Animation Blueprint Anim Class ABP_BaseCharacter 查看动画资产 # 去到Content/ExternalContent/Animation/Animations/TTP_Animations，双击 Run_Fwd 可在 AssetBrowser 中选择其他动画 混合空间资产 # Blend Space 速度从 0 - 600 ，动画从 Idle 过渡到 Run_Fwd 创建BS_Locomotion_Walk_1D # 去到Content/Player/Animations，右键 选择 HeroTPP_Skeleton 命名为 BS_Locomotion_Walk_1D 配置BS_Locomotion_Walk_1D # 双击打开 BS_Locomotion_Walk_1D 配置横轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis 说明 Name 名称 Velocity Minimum Axis Value 轴最小值 0 Maximum Axis Value 轴最大值 600 游戏角色运动速度上限 Grid Divisions 过渡区间 4 使用默认值；和可以添加的动画个数有关 配置动画 动画资产 Velocity 起点 Idle 0 终点 Run_Fwd 600 查看插值 系统 键位 Windows Control MacOS Command 按下键位，水平移动鼠标，绿色X随之在起点和终点间移动，视口展示过渡动画 将BS_Locomotion_Walk_1D作为动画蓝图输入 # ABP_BaseCharacter 添加变量Velocity # 在 MyBlueprint 添加变量 Velocity ，在Details设置名称和类型 设置变量Velocity # EventGraph 将变量Velocity拖动到EventGraph, 选择设置变量值 在 EventBlueprintUpdateAnimation 之后，执行 SetVelocity GetPawnOwner 返回 Pawn 实例的引用, 变量 Velocity 的输入是 Actor 实时速度 设置动画蓝图输入 # AnimGraph 将BS_Locomotion_Walk_1D作为OutputPose的输入 将变量Velocity拖动到AnimGraph, 选择获取变量值 将变量Velocity作为BS_Locomotion_Walk_1D的输入 "}),e.add({id:30,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%8A%A8%E6%B2%BB%E7%96%97/",title:"自动治疗",description:"说明 # C++ 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现 获取定时器管理对象 UActorComponent::GetOwner \u0026gt; AActor::GetWorldTimerManager UActorComponent::GetWorld \u0026gt; UWorld::GetTimerManager 实现自动治疗 # 添加治疗参数 # protected 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealDelay = 3.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealModifier = 5.0f; 添加定时器 # 添加数据成员 # private ShootThemUp: Components/STUHealthComponent.",content:`说明 # C++ 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现 获取定时器管理对象 UActorComponent::GetOwner \u0026gt; AActor::GetWorldTimerManager UActorComponent::GetWorld \u0026gt; UWorld::GetTimerManager 实现自动治疗 # 添加治疗参数 # protected 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealDelay = 3.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealModifier = 5.0f; 添加定时器 # 添加数据成员 # private ShootThemUp: Components/STUHealthComponent.h FTimerHandle HealTimer; 搭建框架 # 添加空的回调函数
ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnHeal() {} 定时器接口
ShootThemUp: Components/STUHealthComponent.cpp 头文件 #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;TimerManager.h\u0026quot; 开启定时器 void USTUHealthComponent::StartHealTimer() { if (AutoHeal \u0026amp;\u0026amp; GetWorld()) { GetWorld()-\u0026gt;GetTimerManager().SetTimer(HealTimer, this, \u0026amp;USTUHealthComponent::OnHeal, HealRate, true, HealDelay); } } 关闭定时器 void USTUHealthComponent::StopHealTimer() { if (AutoHeal \u0026amp;\u0026amp; GetWorld()) { GetWorld()-\u0026gt;GetTimerManager().ClearTimer(HealTimer); } } 接口声明 private ShootThemUp: Components/STUHealthComponent.h 回调函数声明
private ShootThemUp: Components/STUHealthComponent.h 回调函数实现 # ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnHeal() { SetHealth(Health + HealModifier); if (FMath::IsNearlyEqual(Health, MaxHealth)) { StopHealTimer(); } } 游戏角色受到伤害延缓治疗 # ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnTakeAnyDamage(AActor *DamagedActor, float Damage, const UDamageType *DamageType, AController *InstigatedBy, AActor *DamageCauser) { if (Damage \u0026lt;= 0.0f || IsDead()) return; if (!FMath::IsNearlyEqual(Health, MaxHealth)) StopHealTimer(); // Health -= Damage; SetHealth(Health - Damage); UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;Damage: %.0f\u0026quot;), Damage); if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTUFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTUIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !!!\u0026quot;)); } } if (IsDead()) { OnDeath.Broadcast(); } else { StartHealTimer(); } } 重写IsDead # ShootThemUp: Components/STUHealthComponent.h bool IsDead() const { return FMath::IsNearlyZero(Health); } `}),e.add({id:31,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%B0%84%E5%87%BB%E4%BC%A4%E5%AE%B3/",title:"射击伤害",description:"概览 # 击中游戏角色时, 对其造成伤害 在代码中设置Capsule组件的碰撞反馈 搭建框架: 轨迹计算发生碰撞时, 调用MakeDamage, 传入碰撞信息 # C++ ShootThemUp: Weapon/STUBaseWeapon.h protected void MakeDamage(const FHitResult\u0026amp; HitResult); ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::MakeDamage(const FHitResult\u0026amp; HitResult) {} 在MakeShot中调用MakeDamage ShootThemUp: Weapon/STUBaseWeapon.cpp 实现MakeDamage # 添加数据成员: 固定伤害值 # protected ShootThemUp: Weapon/STUBaseWeapon.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float DamageAmount = 10.0f; 获取碰撞Actor, 对其造成伤害 # ShootThemUp: Weapon/STUBaseWeapon.cpp const auto DamagedActor = HitResult.GetActor(); if (!DamagedActor) return; DamagedActor-\u0026gt;TakeDamage(DamageAmount, FDamageEvent(), GetPlayerController(), this); 查看 # 虚幻编辑器 对游戏角色造成射击伤害 游戏角色死亡 游戏角色死亡后播放死亡动画倒地, 其销毁前, Capsule组件成为障碍物 # 虚幻编辑器 运行时显示Capsule组件 show collision 游戏角色死亡, 无法穿过竖立着的Capsule组件 游戏角色死亡后, 设置所有碰撞通道忽略Capsule组件 # C++ ShootThemUp: Player/STUBaseCharacter.",content:"概览 # 击中游戏角色时, 对其造成伤害 在代码中设置Capsule组件的碰撞反馈 搭建框架: 轨迹计算发生碰撞时, 调用MakeDamage, 传入碰撞信息 # C++ ShootThemUp: Weapon/STUBaseWeapon.h protected void MakeDamage(const FHitResult\u0026amp; HitResult); ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::MakeDamage(const FHitResult\u0026amp; HitResult) {} 在MakeShot中调用MakeDamage ShootThemUp: Weapon/STUBaseWeapon.cpp 实现MakeDamage # 添加数据成员: 固定伤害值 # protected ShootThemUp: Weapon/STUBaseWeapon.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float DamageAmount = 10.0f; 获取碰撞Actor, 对其造成伤害 # ShootThemUp: Weapon/STUBaseWeapon.cpp const auto DamagedActor = HitResult.GetActor(); if (!DamagedActor) return; DamagedActor-\u0026gt;TakeDamage(DamageAmount, FDamageEvent(), GetPlayerController(), this); 查看 # 虚幻编辑器 对游戏角色造成射击伤害 游戏角色死亡 游戏角色死亡后播放死亡动画倒地, 其销毁前, Capsule组件成为障碍物 # 虚幻编辑器 运行时显示Capsule组件 show collision 游戏角色死亡, 无法穿过竖立着的Capsule组件 游戏角色死亡后, 设置所有碰撞通道忽略Capsule组件 # C++ ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/CapsuleComponent.h\u0026quot; // OnDeath GetCapsuleComponent()-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore); // 对所有channel的碰撞反馈统一进行设置 游戏角色死亡后, 武器还在 # 虚幻编辑器 "}),e.add({id:32,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%B7%B3%E8%B7%83/",title:"实现游戏角色跳跃",description:"概览 # 状态机 # State Machine 定义多个状态，每个状态对应一个动画 在一个动画蓝图中管理多个状态，并定义状态之间的迁移条件 ACharacter::IsFalling # 当Character在空中时返回true，Character落地时返回false 绑定跳跃键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Jump SpaceBar 实现跳跃逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Jump Jump 回调函数由虚幻引擎提供，按下时触发 绑定函数描述和回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Jump\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::Jump); 使用状态机实现跳跃动画 # 虚幻编辑器 实现跳跃动画 # ABP_BaseCharacter 添加状态机, 将其作为OutPose的输入 # AnimGraph 添加 状态机 ，命名为 Locomotion 将 Locomotion 作为 OutputPose 的输入 状态机说明 # 跳跃动画资产 - JumpStart 跳起 JumpLoop 在空中 JumpEnd 落地 状态 - Walk JumpStart JumpLoop JumpEnd 状态迁移 - Walk \u0026gt; JumpStart 游戏角色在空中 JumpStart \u0026gt; JumpLoop JumpStart 动画播放结束 JumpLoop \u0026gt; JumpEnd 游戏角色落地 JumpEnd \u0026gt; Walk JumpEnd 动画播放结束 实现状态机 # 双击Locomotion，进入状态机",content:`概览 # 状态机 # State Machine 定义多个状态，每个状态对应一个动画 在一个动画蓝图中管理多个状态，并定义状态之间的迁移条件 ACharacter::IsFalling # 当Character在空中时返回true，Character落地时返回false 绑定跳跃键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Jump SpaceBar 实现跳跃逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Jump Jump 回调函数由虚幻引擎提供，按下时触发 绑定函数描述和回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Jump\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::Jump); 使用状态机实现跳跃动画 # 虚幻编辑器 实现跳跃动画 # ABP_BaseCharacter 添加状态机, 将其作为OutPose的输入 # AnimGraph 添加 状态机 ，命名为 Locomotion 将 Locomotion 作为 OutputPose 的输入 状态机说明 # 跳跃动画资产 - JumpStart 跳起 JumpLoop 在空中 JumpEnd 落地 状态 - Walk JumpStart JumpLoop JumpEnd 状态迁移 - Walk \u0026gt; JumpStart 游戏角色在空中 JumpStart \u0026gt; JumpLoop JumpStart 动画播放结束 JumpLoop \u0026gt; JumpEnd 游戏角色落地 JumpEnd \u0026gt; Walk JumpEnd 动画播放结束 实现状态机 # 双击Locomotion，进入状态机
仅一个入口 Entry 移植Walk状态
为 Locomotion 添加 State ，命名为 Walk ，使 Entry 指向 双击 Walk 将OutputPose之前的输入， Velocity + BS_Locomotion_Walk_1D 封装到 Walk 状态（剪切）， 作为其 OutputAnimationPose 的输入 至此， Character 的运动动画和上一小节一致 实现跳跃状态
添加布尔型变量IsFalling
上一小节中，变量 Velocity 横跨 ABP_BaseCharacter 的 EventGraph 和 AnimGraph ，这里，布尔类型变量 IsFalling 也一样 在 EventGraph 设置变量值，在 AnimGraph 中使用变量 使用ACharacter::IsFalling设置变量IsFalling
EventGraph 将Pawn转换为Character
接着设置Velocity, 将Pawn转换为Character 不能同时从 EventBlueprintUpdateAnimation 出发， SetVelocity 之后，执行转换 双击 TryGetPawnOwner 和 CastToCharacter 连线上的一点，创建Bezier曲线，排线更易整理 对ACharacter::CharacterMovement调用ACharacter::IsFalling
接着CastToCharacter, 设置IsFalling 从 CaseToCharacter \u0026gt; AsCharacter 到 IsFalling \u0026gt; Target ，自动添加提取数据成员; IsFalling 函数的返回类型是布尔，作为 SetIsFalling 的输入 完整EventGraph
实现状态机
回到 Locomotion 从 AssetBrowser 把 Jump 的三个动画拖入 Locomotion 动画自动被封装为 State ，和之前 AddState ，再将动画作为状态输入达到的效果一样 添加状态迁移路径 添加状态迁移条件 状态迁移 触发条件 Walk \u0026gt; JumpStart 游戏角色在空中 ACharacter::IsFalling 返回true JumpStart \u0026gt; JumpLoop JumpStart 动画播放结束 TimeRemaining \u0026lt; 0.1 JumpLoop \u0026gt; JumpEnd 游戏角色落地 ACharacter::IsFalling 返回true JumpEnd \u0026gt; Walk JumpEnd 动画播放结束 TimeRemaining \u0026lt; 0.1 双击转换图标，即可为状态迁移添加迁移条件 拿 Walk \u0026gt; JumpStart 举例 Walk \u0026gt; JumpStart 迁移条件：变量 IsFalling 为 true JumpStart \u0026gt; JumpLoop 迁移条件： JumpStart 动画将近结束 JumpLoop \u0026gt; JumpEnd 迁移条件：变量 IsFalling 为 false JumpEnd \u0026gt; Walk 迁移条件： JumpEnd 将近结束 设置 State 输入动画是否循环播放 - BS_Locomotion_Walk_1D 循环播放 JumpStart 播放一次 JumpLoop 循环播放 JumpEnd 播放一次 拿 JumpStart 状态举例: 选中JumpStart动画 \u0026gt; Details \u0026gt; Settings \u0026gt; LoopAnimation 为true 如此设置还可修复Character跳跃时的卡顿 添加楼梯，查看Jump三阶段是否正常显示 # 添加楼梯 PlaceActors \u0026gt; Geometry \u0026gt; LinearStair 设置阶数 选中LinearStairBrush \u0026gt; Details \u0026gt; BrushSettings \u0026gt; NumSteps 将楼梯移动到合适位置 游戏角色从楼梯跳到平面时，循环 JumpLoop 跑步时跳跃，落地后会平滑一段距离 跳跃时Z方向速度 # BP_STUBaseCharacter JumpZVelocity不宜过大, 不然 JumpStart 动画播放结束，速度却未减为0，此时Character还在上升，却在播放 JumpLoop - Vz \u0026gt; 0 JumpStart 该过程应 近似 JumpStart 播放时长 Vz \u0026lt;= 0 JumpLoop 从临界点落下 Vz = 0 JumpEnd `}),e.add({id:33,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%9D%A0%E8%90%BD%E4%BC%A4%E5%AE%B3/",title:"坠落伤害",description:"说明 # C++ 落地速度Z方向的分量和坠落高度有关；速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落机制 # Character定义了坠落委托类型FLandedSignature，并有该类型成员ACharacter::LandedDelegate 委托类型的处理函数签名 void handler(const FHitResult\u0026amp; Hit); 该委托类型支持蓝图 Character在ACharacter::Landed通知客户端 思路 # 我们可以注册LandedDelegate的委托服务，也可以覆写ACharacter::Landed，添加相应处理 选择注册委托服务 坠落伤害计算 # 参数 - 坠落伤害范围 LandedDamageRange [c, d] 落地速度范围 LandedDamageVelocityRange [a, b] 落地速度和对应的伤害 速度 伤害 \u0026lt; a 无伤 [a, b] [c, d] c + (Velocity - a) (d - c) / (b - a) \u0026gt; b d 获取Character速度 APawn::GetVelocity ACharacter:: GetCharacterMovement \u0026gt; UCharacterMovementComponent::Velocity 添加坠落伤害参数 # protected ShootThemUp: Player/STUBaseCharacter.",content:"说明 # C++ 落地速度Z方向的分量和坠落高度有关；速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落机制 # Character定义了坠落委托类型FLandedSignature，并有该类型成员ACharacter::LandedDelegate 委托类型的处理函数签名 void handler(const FHitResult\u0026amp; Hit); 该委托类型支持蓝图 Character在ACharacter::Landed通知客户端 思路 # 我们可以注册LandedDelegate的委托服务，也可以覆写ACharacter::Landed，添加相应处理 选择注册委托服务 坠落伤害计算 # 参数 - 坠落伤害范围 LandedDamageRange [c, d] 落地速度范围 LandedDamageVelocityRange [a, b] 落地速度和对应的伤害 速度 伤害 \u0026lt; a 无伤 [a, b] [c, d] c + (Velocity - a) (d - c) / (b - a) \u0026gt; b d 获取Character速度 APawn::GetVelocity ACharacter:: GetCharacterMovement \u0026gt; UCharacterMovementComponent::Velocity 添加坠落伤害参数 # protected ShootThemUp: Player/STUBaseCharacter.h UPROPERTY(EditDefaultsOnly) FVector2D LandedDamageVelocityRange = {900.0f, 1200.0f}; UPROPERTY(EditDefaultsOnly)	FVector2D LandedDamageRange = {10.0f, 100.0f}; 注册坠落伤害的委托服务 # 搭建框架 # 添加空函数 OnLanded函数名已被使用 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnGroundLanded(const FHitResult \u0026amp;Hit) {} 注册服务 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay LandedDelegate.AddDynamic(this, \u0026amp;ASTUBaseCharacter::OnGroundLanded); 函数声明 private ShootThemUp: Player/STUBaseCharacter.h UFUNCTION() void OnGroundLanded(const FHitResult\u0026amp; Hit); 实现处理函数 # 坠落伤害属于环境伤害，无伤害源(Actor)和阵营(Controller) ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnGroundLanded(const FHitResult \u0026amp;Hit) { float Velocity = -GetVelocity().Z; if (Velocity \u0026lt; LandedDamageVelocityRange.X) return; float LandedDamage = FMath::GetMappedRangeValueClamped(LandedDamageVelocityRange, LandedDamageRange, Velocity); TakeDamage(LandedDamage, FDamageEvent{}, nullptr, nullptr); } "}),e.add({id:34,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%9E%84%E5%87%86%E5%81%8F%E7%A7%BB/",title:"瞄准偏移",description:"说明 # 游戏角色视角水平旋转时, 身体会跟随; 垂直方向旋转时, 缺乏相应动画 使用瞄准偏移资产, 游戏角色视角垂直旋转时, 显示相应动画 游戏角色视角垂直旋转即Camera组件垂直旋转, 可以用来校准处垂直方向上的瞄准偏移 概览 # 导入AimOffset相关动画 绘制Camera组件的前进向量 创建瞄准偏移资产 在动画蓝图中使用瞄准偏移资产校准垂直方向上的动画 绘制Camera组件的前进向量 # 虚幻编辑器 函数 GetBaseAimRotation 通过Pawn的Controller返回游戏角色CameraComponent的旋转分量 GetForwardVector 从FRotator获取前进分量 GetActorLocation 获取游戏角色位置 在蓝图中获取Camera组件旋转分量 # ABP_BaseCharacter \u0026gt; EventGraph 保存旋转分量到变量, AnimGraph中会用到 # Promote to Variable 变量列表出现新变量, 命名为AimRotation 完整实现 # 绘制Camera组件前进方向 # - 起点 游戏角色位置 偏移 放大的Camera组件前进向量 终点 起点 + 偏移 乘法输入转为float: 右键另一个输入 使用DrawDebugLine绘制 线段参数 Duration 0.0 Thickness 3.0 Line Color 瞄准偏移资产 # Aim Offset 专门用于瞄准 有常规和1D两种, 和混合空间一样 常规AimOffset有两个轴, 覆盖瞄准在水平和垂直方向的偏移 需要绑定骨骼 命名前缀为AO_ 使用瞄准偏移资产 # 导入AimOffset相关动画 # 之前导入的动画资产打开导致程序挂死, 不用亦不删除, 从ShooterGame单独导入 使用到的动画资产 # 这些动画倾向于作为姿势, 由少数帧组成 - AimOffsetFwd AimOffsetUp AimOffsetDown AimOffsetLeft AimOfsetLeftDown AimOffsetLeftUp AimOffsetRight AimOfsetRightDown AimOffsetRightUp 从ShooterGame迁移 # ShooterGame 选中Content/Animations/TTP_Animations，右键，选择Migrate 仅勾选AimOffset相关动画，共9个 放入指定位置并绑定骨骼 # ShootThemUp 重命名Content/Animations/TTP_Animations为AimOffsetAnimation，移动到Content/ExternalContent目录下, 删除Content/Animations 动画资产全选打开, 为其绑定骨骼HeroTPP_Skeleton 为文件夹设置颜色 创建瞄准偏移资产 # Aim Offset Content/Player/Animations文件夹空白处右键, 选择AimOffset 选择骨骼 HeroTPP_Skeleton 命名为AO_BaseCharacter 配置瞄准偏移资产 # AO_BaseCharacter 双击打开, 面板和混合空间一样 配置轴 # - Name 范围 水平 Yaw -90 ~ 90 垂直 Pitch -90 ~ 90 要求Asset Browser有以下动画 # - AimOffsetFwd AimOffsetUp AimOffsetDown AimOffsetLeft AimOfsetLeftDown AimOffsetLeftUp AimOffsetRight AimOfsetRightDown AimOffsetRightUp 调整动画资产参数以兼容AimOffset资产 # 使得这些动画可以附加到已有姿势上 依次打开9个动画资产, 做如下设置: Asset Details \u0026gt; Additive Settings, 将Additive Anim Type设置为Mesh Space AnimOffset只和该类型动画兼容 Base Pose Type默认为Selected animation frame 选择动画Idle 使用AimOffset相关动画 # 将9个动画拖入到指定位置, 调整座标 (Yaw, Pitch) AimOffsetFwd (0, 0) AimOffsetUp (0, 90) AimOffsetDown (0, -90) AimOffsetLeft (-90, 0) AimOfsetLeftDown (-90, -90) AimOffsetLeftUp (-90, 90) AimOffsetRight (90, 0) AimOfsetRightDown (90, -90) AimOffsetRightUp (90, 90) 动画座标配置 效果 说明 # AO_BaseCharacter在水平和垂直方向都有输入, 本节中, 只配置垂直输入 对于玩家操控的游戏角色, 旋转视角时, 在水平和垂直方向都有动画; 玩家不需要看到游戏角色的侧面旋转 如果希望AI的旋转更写实, 需要配置瞄准偏移的水平输入 在动画蓝图中使用瞄准偏移资产 # ABP_BaseCharacter \u0026gt; AnimGraph 计算运动姿势之后, 添加瞄准偏移 将AO_BaseCharacter拖入AnimGraph, Locomotion作为其输入, 输出作为Slot的输入 可以调试AO_BaseCharacter的(Yaw, Pitch), 编译后, 在窗口检视Idle姿势在该设置下的AimOffset效果 - (90, 0) 右转 (90, 45) 右下 可以调试Velocity, 查看运动时的瞄准偏移效果 获取AimRotation变量, 使用Pitch分量(垂直); Camera组件旋转的水平分量与侧面动画不一致, 不能用作Yaw的输入 查看垂直方向的瞄准偏移 # 武器跟随游戏角色在垂直方向旋转, 射击瞄准相较之前自然一些 ",content:"说明 # 游戏角色视角水平旋转时, 身体会跟随; 垂直方向旋转时, 缺乏相应动画 使用瞄准偏移资产, 游戏角色视角垂直旋转时, 显示相应动画 游戏角色视角垂直旋转即Camera组件垂直旋转, 可以用来校准处垂直方向上的瞄准偏移 概览 # 导入AimOffset相关动画 绘制Camera组件的前进向量 创建瞄准偏移资产 在动画蓝图中使用瞄准偏移资产校准垂直方向上的动画 绘制Camera组件的前进向量 # 虚幻编辑器 函数 GetBaseAimRotation 通过Pawn的Controller返回游戏角色CameraComponent的旋转分量 GetForwardVector 从FRotator获取前进分量 GetActorLocation 获取游戏角色位置 在蓝图中获取Camera组件旋转分量 # ABP_BaseCharacter \u0026gt; EventGraph 保存旋转分量到变量, AnimGraph中会用到 # Promote to Variable 变量列表出现新变量, 命名为AimRotation 完整实现 # 绘制Camera组件前进方向 # - 起点 游戏角色位置 偏移 放大的Camera组件前进向量 终点 起点 + 偏移 乘法输入转为float: 右键另一个输入 使用DrawDebugLine绘制 线段参数 Duration 0.0 Thickness 3.0 Line Color 瞄准偏移资产 # Aim Offset 专门用于瞄准 有常规和1D两种, 和混合空间一样 常规AimOffset有两个轴, 覆盖瞄准在水平和垂直方向的偏移 需要绑定骨骼 命名前缀为AO_ 使用瞄准偏移资产 # 导入AimOffset相关动画 # 之前导入的动画资产打开导致程序挂死, 不用亦不删除, 从ShooterGame单独导入 使用到的动画资产 # 这些动画倾向于作为姿势, 由少数帧组成 - AimOffsetFwd AimOffsetUp AimOffsetDown AimOffsetLeft AimOfsetLeftDown AimOffsetLeftUp AimOffsetRight AimOfsetRightDown AimOffsetRightUp 从ShooterGame迁移 # ShooterGame 选中Content/Animations/TTP_Animations，右键，选择Migrate 仅勾选AimOffset相关动画，共9个 放入指定位置并绑定骨骼 # ShootThemUp 重命名Content/Animations/TTP_Animations为AimOffsetAnimation，移动到Content/ExternalContent目录下, 删除Content/Animations 动画资产全选打开, 为其绑定骨骼HeroTPP_Skeleton 为文件夹设置颜色 创建瞄准偏移资产 # Aim Offset Content/Player/Animations文件夹空白处右键, 选择AimOffset 选择骨骼 HeroTPP_Skeleton 命名为AO_BaseCharacter 配置瞄准偏移资产 # AO_BaseCharacter 双击打开, 面板和混合空间一样 配置轴 # - Name 范围 水平 Yaw -90 ~ 90 垂直 Pitch -90 ~ 90 要求Asset Browser有以下动画 # - AimOffsetFwd AimOffsetUp AimOffsetDown AimOffsetLeft AimOfsetLeftDown AimOffsetLeftUp AimOffsetRight AimOfsetRightDown AimOffsetRightUp 调整动画资产参数以兼容AimOffset资产 # 使得这些动画可以附加到已有姿势上 依次打开9个动画资产, 做如下设置: Asset Details \u0026gt; Additive Settings, 将Additive Anim Type设置为Mesh Space AnimOffset只和该类型动画兼容 Base Pose Type默认为Selected animation frame 选择动画Idle 使用AimOffset相关动画 # 将9个动画拖入到指定位置, 调整座标 (Yaw, Pitch) AimOffsetFwd (0, 0) AimOffsetUp (0, 90) AimOffsetDown (0, -90) AimOffsetLeft (-90, 0) AimOfsetLeftDown (-90, -90) AimOffsetLeftUp (-90, 90) AimOffsetRight (90, 0) AimOfsetRightDown (90, -90) AimOffsetRightUp (90, 90) 动画座标配置 效果 说明 # AO_BaseCharacter在水平和垂直方向都有输入, 本节中, 只配置垂直输入 对于玩家操控的游戏角色, 旋转视角时, 在水平和垂直方向都有动画; 玩家不需要看到游戏角色的侧面旋转 如果希望AI的旋转更写实, 需要配置瞄准偏移的水平输入 在动画蓝图中使用瞄准偏移资产 # ABP_BaseCharacter \u0026gt; AnimGraph 计算运动姿势之后, 添加瞄准偏移 将AO_BaseCharacter拖入AnimGraph, Locomotion作为其输入, 输出作为Slot的输入 可以调试AO_BaseCharacter的(Yaw, Pitch), 编译后, 在窗口检视Idle姿势在该设置下的AimOffset效果 - (90, 0) 右转 (90, 45) 右下 可以调试Velocity, 查看运动时的瞄准偏移效果 获取AimRotation变量, 使用Pitch分量(垂直); Camera组件旋转的水平分量与侧面动画不一致, 不能用作Yaw的输入 查看垂直方向的瞄准偏移 # 武器跟随游戏角色在垂直方向旋转, 射击瞄准相较之前自然一些 "}),e.add({id:35,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%B7%91%E6%AD%A5/",title:"实现游戏角色跑步",description:"概览 # 跑步条件 # 按下Shift键 运动方向为向前 判断方法1：同时按下 W 或 Up 判断方法2：速度矢量和朝向的夹角为0 速度不为0 前方有障碍物时，游戏角色无法跑步 跑步时，播放跑步动画 # 跑步时，游戏角色运动速度提高 # 绑定跑步键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Run LeftShift 实现跑步逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Run RunEnable 按下时触发 RunDisable 松开时触发 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::RunEnable() {} void ASTUBaseCharacter::RunDisable() {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::RunEnable); PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Released, this, \u0026amp;ASTUBaseCharacter::RunDisable); 添加函数声明 private ShootThemUp: Player/STUBaseCharacter.",content:`概览 # 跑步条件 # 按下Shift键 运动方向为向前 判断方法1：同时按下 W 或 Up 判断方法2：速度矢量和朝向的夹角为0 速度不为0 前方有障碍物时，游戏角色无法跑步 跑步时，播放跑步动画 # 跑步时，游戏角色运动速度提高 # 绑定跑步键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Run LeftShift 实现跑步逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Run RunEnable 按下时触发 RunDisable 松开时触发 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::RunEnable() {} void ASTUBaseCharacter::RunDisable() {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::RunEnable); PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Released, this, \u0026amp;ASTUBaseCharacter::RunDisable); 添加函数声明 private ShootThemUp: Player/STUBaseCharacter.h 实现回调函数 # 键位生效时，设置标识位 # 定义标志位 private ShootThemUp: Player/STUBaseCharacter.h bool AbleRun = false; 键位事件发生时, 更新标志位 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::RunEnable() { AbleRun = true; } void ASTUBaseCharacter::RunDisable() { AbleRun = false; } 运动方向向前时，设置标志位 # 定义标志位 private ShootThemUp: Player/STUBaseCharacter.h bool IsForward = false; MoveForward被调用时, 更新标志位 ShootThemUp: Player/STUBaseCharacter.cpp // MoveForward IsForward = Amount \u0026gt; 0.0f; 添加接口, 返回跑步条件满足情况 # 添加函数声明 public 可在蓝图中调用，也可供其他类使用 ShootThemUp: Player/STUBaseCharacter.h UFUNCTION(BlueprintCallable) bool IsRunning() const; 实现 ShootThemUp: Player/STUBaseCharacter.cpp bool ASTUBaseCharacter::IsRunning() const { return AbleRun \u0026amp;\u0026amp; IsForward \u0026amp;\u0026amp; !GetVelocity().IsZero(); } 添加跑步动画 # 虚幻编辑器 创建混合空间资产作为跑步动画 # Blend Space 1D 创建 Content/Player/Animations/BS_Locomotion_Run，绑定骨骼网格体 HeroTPP_Skeleton 设置轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis - Name Velocity Maximum Axis Value 600 设置动画 - 起点 Idle 终点 RoadieRun_Fwd 在动画蓝图中引入跑步动画 # ABP_BaseCharacter 状态机说明 # 新增状态: Run 状态迁移 - Walk \u0026gt; Run 满足跑步条件 Run \u0026gt; Walk 不再满足跑步条件 Run \u0026gt; JumpStart 游戏角色在空中 使状态机管理跑步状态 # 添加布尔型变量IsRunning 设置变量IsRunning
EventGraph 使用 STUBaseCharacter::IsRunning ，需要 Pawn 到 STUBaseCharacter 的转换 设置IsFalling后, 执行Pawn到STUBaseCharacter的转换 转换完成后, 设置变量 IsRunning 完整 EventGraph 可以合并 Pawn 到 Character 和 STUBaseCharacter 的转换 状态机中添加跑步状态
AnimGraph 将BS_Locomotion_Run拖入到状态机, 命令为 Run 双击 Run ，设置BS_Locomotion_Run输入 添加状态迁移条件
- 触发条件 Walk \u0026gt; Run 满足跑步条件 STUBaseCharacter::IsRunning 返回true Run \u0026gt; Walk 不再满足跑步条件 STUBaseCharacter::IsRunning 返回false Run \u0026gt; JumpStart 游戏角色在空中 复用 Walk \u0026gt; JumpStart 迁移条件 Walk \u0026lt;\u0026gt; Run
状态迁移路径 Walk \u0026gt; Run 迁移条件 Run \u0026gt; Walk 迁移条件 Run \u0026gt; Jump
状态迁移路径
初稿 优解 如果 IsRunning 为 true, 发生 JumpEnd \u0026gt; Walk 时, 会立即从 Walk 切换到 Run 省略 JumpEnd \u0026gt; =Run ，可以降低状态机复杂度 复用迁移条件
Run \u0026gt; JumpStart 复用 Walk \u0026gt; JumpStart 迁移条件 选中 Walk \u0026gt; JumpStart 迁移条件, Details \u0026gt; Transiton \u0026gt; Transition Rule Sharing \u0026gt; Promote To Share 命名为 IsFalling ，共享条件显示为红色 选中 Run \u0026gt; JumpStart 迁移条件, Details \u0026gt; Transition \u0026gt; Transition Rule Sharing \u0026gt; Use Shared \u0026gt; 选择IsFalling 完整状态机 效果 # 运行游戏，走路到跑步动画正常切换 实现跑步加速 # 创建Components/CharacterMovementComponent的派生类 # 虚幻编辑器 CharacterMovementComponent 公有类 设置头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot; }); 满足跑步条件时, 增加游戏角色运动速度上限 # C++ 添加加速系数 # protected ShootThemUp: Components/STUCharacterMovementComponent.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;1.5\u0026quot;, ClampMax = \u0026quot;10.0\u0026quot;)) float SpeedAcceleration = 2.0f; 覆写UCharacterMovementComponent::GetMaxSpeed # 并不直接修改 MaxWalkSpeed 某个地方会调用 GetMaxSpeed 来确定 Character 运动速度的上限，当获取的 MaxWalkSpeed 增加，速度增加的幅度也变大，用以实现加速 添加函数声明
public ShootThemUp: Components/STUCharacterMovementComponent.h virtual float GetMaxSpeed() const override; 实现
ShootThemUp: Components/STUCharacterMovementComponent.cpp #include \u0026quot;Player/STUBaseCharacter.h\u0026quot; float USTUCharacterMovementComponent::GetMaxSpeed() const { const float MaxSpeed = Super::GetMaxSpeed(); ASTUBaseCharacter *Player = Cast\u0026lt;ASTUBaseCharacter\u0026gt;(GetPawnOwner()); return Player \u0026amp;\u0026amp; Player-\u0026gt;IsRunning() ? SpeedAcceleration * MaxSpeed : MaxSpeed; } 游戏角色使用STUCharacterMovementComponent # 屏蔽默认构造函数声明，声明构造函数 ShootThemUp: Player/STUBaseCharacter.h // ASTUBaseCharacter(); ASTUBaseCharacter(const FObjectInitializer \u0026amp;ObjInit); 修改构造函数初始化列表 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/STUCharacterMovementComponent.h\u0026quot; ASTUBaseCharacter::ASTUBaseCharacter(const FObjectInitializer \u0026amp;ObjInit) : Super(ObjInit.SetDefaultSubobjectClass\u0026lt;USTUCharacterMovementComponent\u0026gt;(ACharacter::CharacterMovementComponentName)) { // ... } `}),e.add({id:36,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/",title:"阶段性总结",description:"项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D AM_Death BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent STUHealthComponent Player STUBaseCharacter STUPlayerController Dev STUDevDamageActor STUFireDamageType STUIceDamageType STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D Player/Animations/AM_Death STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 轴映射 左右移动 APawn::AddMovementInput；AActor::GetActorRightVector MoveForward 轴映射 前后移动 APawn::AddMovementInput；AActor::GetActorForwardVector 轴映射 左右旋转 ACharacter::AddControllerYawInput 轴映射 上下旋转 ACharacter::AddControllerPitchInput 动作映射 跳跃 ACharacter::Jump RunEnable，RunDisable 动作映射 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 委托 处理函数 作用 委托成员 操作 OnChangeHealth 修改显示生命值 HealthComponent::OnChangeHealth 修改HealthTextComponent文本 OnDeath 游戏角色死亡处理 HealthComponent::OnDeath 播放死亡动画剪辑；禁止操作Character；定时销毁；切换到观察视角 OnGroundLanded 计算落地伤害 ACharacter::LandedDelegate 计算落地伤害；对Character调用TakeDamage 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 HealthComponent 生命值系统 HealthTextComponent 显示生命值 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 游戏角色死亡逻辑 说明 DeathAnimMontage 死亡动画剪辑 LifeSpanOnDeath 销毁角色定时间隔 落地伤害逻辑 说明 LandedDamageRange 伤害范围 LandedDamageVelocityRange 造成伤害的速度范围 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true HealthComponent # HealthTextComponent # 说明 Horizontal Alignment Center Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机",content:`项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D AM_Death BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent STUHealthComponent Player STUBaseCharacter STUPlayerController Dev STUDevDamageActor STUFireDamageType STUIceDamageType STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D Player/Animations/AM_Death STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 轴映射 左右移动 APawn::AddMovementInput；AActor::GetActorRightVector MoveForward 轴映射 前后移动 APawn::AddMovementInput；AActor::GetActorForwardVector 轴映射 左右旋转 ACharacter::AddControllerYawInput 轴映射 上下旋转 ACharacter::AddControllerPitchInput 动作映射 跳跃 ACharacter::Jump RunEnable，RunDisable 动作映射 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 委托 处理函数 作用 委托成员 操作 OnChangeHealth 修改显示生命值 HealthComponent::OnChangeHealth 修改HealthTextComponent文本 OnDeath 游戏角色死亡处理 HealthComponent::OnDeath 播放死亡动画剪辑；禁止操作Character；定时销毁；切换到观察视角 OnGroundLanded 计算落地伤害 ACharacter::LandedDelegate 计算落地伤害；对Character调用TakeDamage 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 HealthComponent 生命值系统 HealthTextComponent 显示生命值 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 游戏角色死亡逻辑 说明 DeathAnimMontage 死亡动画剪辑 LifeSpanOnDeath 销毁角色定时间隔 落地伤害逻辑 说明 LandedDamageRange 伤害范围 LandedDamageVelocityRange 造成伤害的速度范围 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true HealthComponent # HealthTextComponent # 说明 Horizontal Alignment Center Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机
Locomotion \u0026gt; Slot \u0026gt; OutputPose 状态 状态 说明 走路 Walk BS_Locomotion_Walk；混合空间 跑步 Run BS_Locomotion_Run；混合空间1D 跳跃 JumpStart JumpLoop JumpEnd 死亡 AM_Death；动画剪辑 变量 动画输入 名称 速度 Velocity 速度和前进方向的夹角 Directon 转换条件 说明 IsRunning C++ 满足3个条件：按下Shift；速度和前进方向夹角为0（或按下W/Up）；速度不为0 IsFalling CharacterMovementComponent::IsFalling 返回true，意味着游戏角色跳起；接着返回false，意味着游戏角色回到地面 EventGraph # 设置变量 - Velocity Directon IsRunning IsFalling 组件 # C++ STUCharacterMovementComponent # 满足跑步条件时，提高运动速度上限 参数 说明 SpeedAcceleration 加速系数 STUHealthComponent # 函数成员 # 基本函数 操作 构造函数 每帧调用Tick标志位置为false BeginPlay 初始化生命值；注册AActor::OnTakeAnyDamage TickComponent 屏蔽 接口 接口函数 操作 GetHealth 获取当前生命值；STBaseCharacter调用 IsDead 判断角色是否死亡 内部逻辑 说明 SetHealth 修改生命值；受到伤害或治疗时调用，随之广播 治疗 说明 OnHeal 定时器回调函数；治疗；满生命值停止定时器 StartHealTimer 受到伤害则开启定时器 StopHealTimer 受到伤害会关闭之前开启的定时器；满生命值时停止定时器 受伤处理函数 - OnTakeAnyDamage 进入条件：伤害为正数，当前角色存活；受伤后，停止已开启的治疗定时器；更新生命值；若角色死亡，广播，否则，开启治疗定时器 数据成员 # 说明 Health 生命值 MaxHealth 最大生命值 委托成员 说明 OnChangeHealth 修改生命值(SetHealth)时广播 OnDeath 受到伤害时，若死亡，广播 治疗 说明 HealTimer 定时器 AutoHeal 使能治疗 HealModifier 治疗量 HealRate 治疗频率 HealDelay 治疗延时 伤害 # C++ STUDevDamageActor # 函数成员 # 基本函数 操作 构造函数 初始化组件 BeginPlay Tick 绘制球体模拟爆炸范围；对球体内以及相交Actor造成伤害 数据成员 # 说明 SceneComponent 变换属性 Radius 球体半径 SphereColor 球体颜色 Damage 伤害的数值特征 DoFullDamage 计算伤害机制标志位 STUFireDamageType和STUIceDamageType # `}),e.add({id:37,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/fabrik/",title:"FABRIK",description:"概览 # 问题描述 FABRIK 在动画蓝图中使用FABRIK 问题描述 # 调整游戏角色Camera组件位置, 使之拍摄游戏角色正面 # BP_STUBaseCharacter 在SpringArm组件细节面板设置Camera组件的Socket Offset 之前 SpringArm \u0026gt; Details \u0026gt; Camera \u0026gt; Socket Offset \u0026gt; X = 600 Y = 0 设置Camera组件变换属性 之前 Camera \u0026gt; Details \u0026gt; Transform \u0026gt; Rotation \u0026gt; Yaw = 180 效果图 操控游戏角色运动时, 左手和枪管之间未固定, 二者会有错开的情况 # 在动画蓝图添加FABRIK, 将左手固定在枪管合适位置 # FABRIK # FABRIK 在动画蓝图添加FABRIK # ABP_BaseCharacter \u0026gt; AnimGraph 在动画蓝图添加FABRIK, 切换末端执行器变换在细节面板设置 确定骨骼链 # 在导航栏选择骨骼 左臂的起点为b_LeftArm, 终点为b_LeftWeapon 配置FABRIK \u0026gt; Solver - Tip Bone b_LeftWeapon Root Bone b_LeftArm 游戏角色移动时, 左手和右手都在武器上, 以右手为参照, 固定左手位置 # 设置末端执行器Target 设置相对Target的变换 - Effector Target b_RightHand Effector Transform Space Bone Space Effector Transform X=-50 Y=-11 Z=4 将FABRIK加入到输出 # 将AO_BaseCharacter作为FABRIK的输入 Component Pose 自动添加转换座标系的节点 LocalToComponent 将输出作为Slot的输入 自动添加转换座标系的节点 ComponentToLocal 播放死亡动画时, 左手不需要扶在枪管上 查看 # 操控游戏角色运动时, 左手固定在枪管合适位置 ",content:"概览 # 问题描述 FABRIK 在动画蓝图中使用FABRIK 问题描述 # 调整游戏角色Camera组件位置, 使之拍摄游戏角色正面 # BP_STUBaseCharacter 在SpringArm组件细节面板设置Camera组件的Socket Offset 之前 SpringArm \u0026gt; Details \u0026gt; Camera \u0026gt; Socket Offset \u0026gt; X = 600 Y = 0 设置Camera组件变换属性 之前 Camera \u0026gt; Details \u0026gt; Transform \u0026gt; Rotation \u0026gt; Yaw = 180 效果图 操控游戏角色运动时, 左手和枪管之间未固定, 二者会有错开的情况 # 在动画蓝图添加FABRIK, 将左手固定在枪管合适位置 # FABRIK # FABRIK 在动画蓝图添加FABRIK # ABP_BaseCharacter \u0026gt; AnimGraph 在动画蓝图添加FABRIK, 切换末端执行器变换在细节面板设置 确定骨骼链 # 在导航栏选择骨骼 左臂的起点为b_LeftArm, 终点为b_LeftWeapon 配置FABRIK \u0026gt; Solver - Tip Bone b_LeftWeapon Root Bone b_LeftArm 游戏角色移动时, 左手和右手都在武器上, 以右手为参照, 固定左手位置 # 设置末端执行器Target 设置相对Target的变换 - Effector Target b_RightHand Effector Transform Space Bone Space Effector Transform X=-50 Y=-11 Z=4 将FABRIK加入到输出 # 将AO_BaseCharacter作为FABRIK的输入 Component Pose 自动添加转换座标系的节点 LocalToComponent 将输出作为Slot的输入 自动添加转换座标系的节点 ComponentToLocal 播放死亡动画时, 左手不需要扶在枪管上 查看 # 操控游戏角色运动时, 左手固定在枪管合适位置 "}),e.add({id:38,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E6%B7%BB%E5%8A%A0%E8%B5%B0%E8%B7%AF%E6%97%B6%E8%BD%AC%E5%90%91%E5%8A%A8%E7%94%BB/",title:"添加走路转向动画",description:"概览 # 已实现动作 # Walk: 从静止到跑起来支持加速，使用 BS_Locomotion_Walk_1D Run: BS_Locomotion_Run Jump: JumpStart , JumpEnd , JumpLoop 本节内容 # 重新实现走路动画，根据游戏角色前进方向和速度方向的夹角，增加转向和后退动画 之后还有 装弹 Reloading , 死亡 Death 和瞄准 Aiming 动画 2D混合空间 # Blend Space 拥有两个轴， Vertial Axis 和 Horizontal Axis 建模 # 游戏角色朝向 # - 前进和后退 ForwardVector 左右 RightVector 游戏角色前后左右移动有使用到这两个方向向量 我们水平移动鼠标时， ForwardVector 和 RightVector 随之发生改变 在视觉上， ForwardVector 一直向前， RightVector 一直向右，二者在水平面垂直 数学基础 # 点乘 # 计算向量夹角 其中一个向量为 0向量 时，点乘结果为 0 ，而反余弦计算得到其夹角为 PI/2 叉乘 # 将向量夹角从[0, PI]扩充到[-PI, PI] theta 为 0 PI 和 -PI 时，叉乘结果为 0 ，此时无法通过向量确定平面，也就无法得到平面法向量 向量c的z坐标 c.",content:"概览 # 已实现动作 # Walk: 从静止到跑起来支持加速，使用 BS_Locomotion_Walk_1D Run: BS_Locomotion_Run Jump: JumpStart , JumpEnd , JumpLoop 本节内容 # 重新实现走路动画，根据游戏角色前进方向和速度方向的夹角，增加转向和后退动画 之后还有 装弹 Reloading , 死亡 Death 和瞄准 Aiming 动画 2D混合空间 # Blend Space 拥有两个轴， Vertial Axis 和 Horizontal Axis 建模 # 游戏角色朝向 # - 前进和后退 ForwardVector 左右 RightVector 游戏角色前后左右移动有使用到这两个方向向量 我们水平移动鼠标时， ForwardVector 和 RightVector 随之发生改变 在视觉上， ForwardVector 一直向前， RightVector 一直向右，二者在水平面垂直 数学基础 # 点乘 # 计算向量夹角 其中一个向量为 0向量 时，点乘结果为 0 ，而反余弦计算得到其夹角为 PI/2 叉乘 # 将向量夹角从[0, PI]扩充到[-PI, PI] theta 为 0 PI 和 -PI 时，叉乘结果为 0 ，此时无法通过向量确定平面，也就无法得到平面法向量 向量c的z坐标 c.z 的符号说明向量的方向 速度方向 # VelocityVector Actor 的速度是一个矢量，其表现是单位时间内的位移方向 当速度不为 0 ， VelocityVector 和 ForwardVector 的夹角与此时 Actor 应该展现的动画有关 计算游戏角色前进方向和速度方向的夹角 # VelocityVector 和 ForwardVector 的夹角通过向量点乘反余弦结果和向量叉乘结果z分量符号 sign(c.z) 的乘积得到 夹角 反余弦结果 sign(c.z) 目的动画 使用乘积效果 0 0 0 Fwd o ( 0, PI/2 ) ( 0, PI/2 ) 1 Fwd \u0026gt; Right o PI/2 PI/2 1 Right o ( PI/2, PI ) ( PI/2, PI ) 1 Right \u0026gt; Bwd o PI PI 0 Bwd x -PI PI 0 Bwd x ( -PI, -PI/2 ) ( PI/2, PI ) -1 Left \u0026gt; Bwd o -PI/2 PI/2 -1 Left o ( -PI/2, 0 ) ( 0, PI/2 ) -1 Fwd \u0026gt; Left o 分析特殊情形 # 坐标 ( Velocity , Angle ) 速度为0，夹角应该为0 # Velocity 为 0 ，( 0, 任意 ) 对应 Idle ，可以显示正确动画 速度不为0，夹角为0或PI时 # 叉乘结果为 0 ，即sign(c.z)为 0 ，即计算夹角得到 0 ，对应动画 RunFwd 夹角为 0 使用 RunFwd 正确，夹角为 PI 应该使用 RunBwd 夹角为 PI 时，不使用乘积，使用反余弦结果 可以在蓝图中实现夹角的计算，也可以在C++中实现 # 绘制ForwardVector，RightVector和VelocityVector # 虚幻编辑器 使用 DrawDebugArrow : Duration 为 0 ，每帧都进行绘画 - 起点 Actor 当前位置 终点 起点 + 偏移 绘制 ForwardVector # - 偏移 放大的前进方向向量 绘制 RightVector # - 偏移 放大的向右方向向量 绘制 VelocityVector # - 偏移 放大的速度方向单位向量 效果图 # 一直显示 ForwardVector 和 RightVector ，有速度才会显示 VelocityVector 优化显示 # 项目设置 \u0026gt; Engine \u0026gt; Rendering \u0026gt; Default Settings \u0026gt; Auto Exposure，取消勾选 旨在模拟人眼适应不同亮度 看不出区别, 取消设置 添加走路转向动画 # 虚幻编辑器 创建2D混合空间资产作为走路转向动画 # Blend Space 创建2D混合空间资产, 命名为BS_Locomotion_Walk 设置轴 横轴: 速度 - Name Velocity 范围 [ 0, 600 ] 纵轴: ForwardVector 和 VelocityVector 的夹角 - Name Direction 范围 [ -180, 180 ] 设置动画 ( Velocity , Direction ) 动画资产 说明 ( 0, 0 ) Idle 初始状态 ( 600, 0 ) Run_Fwd 满速前进 ( 600, -180 ) 和 ( 600, 180 ) Run_Bwd 满速后退 ( 600, 90 ) Run_Rt 满速向右 ( 600, -90 ) Run_Lt 满速向左 将BS_Locomotion_Walk用作走路动画 # ABP_BaseCharacter 将BS_Locomotion_Walk设置为Walk状态的输入 变量Velocity作为横轴Velocity的输入 添加变量 Direction - 类型 float 默认值 0 变量Direction作为纵轴Direction的输入 在蓝图中计算夹角 # 虚幻编辑器 在蓝图中计算夹角并设置变量 # 计算点乘时， ForwardVector 和 VelocityVector 都是单位向量 计算夹角 # 当前并未在夹角为PI时做处理，后退动画偶有闪动但看似正常 接着设置IsRunning, 设置Direction # 输出 # 输出点乘的反余弦结果，静止时输出90 输出叉乘结果，静止、前进或后退时，坐标为 0 但是有正负 输出 Sign 结果，静止时为 0 ，前进或后退时，其结果或为 1 或为 -1 ，飘忽不定，但不为 0 ，所以后退动画看似正常 可以做出合理推测：显示为 0 但不意味着为 0 ，数值很小 叉乘时传入未单位化的 Velocity 无改善 同时按下后退和向左，或者后退和向右，正负 3PI/4 的动画较为刻意 ( PI/2, PI ) 和 ( -PI, -PI/2 ) 时可以只显示 Run_Bwd 绘制 ForwardVectr 和 VelocityVector 的叉乘结果 # - 偏移 放大的叉乘结果 运动时才有向量显示 向前和向后运动时，偶有不明显的显示 取消变量的设置 # 接下来在代码计算夹角 在代码中计算夹角 # 添加接口, 返回Direction # C++ 添加函数声明 public 可在蓝图中调用，也可供其他类使用 ShootThemUp: Player/STUBaseCharacter.h UFUNCTION(BlueprintCallable) float GetDirection() const; 实现 速度为0时, 夹角为0 速度不为0, 叉乘结果为0时, 夹角为PI或-PI, 返回反余弦结果 ShootThemUp: Player/STUBaseCharacter.cpp float ASTUBaseCharacter::GetDirection() const { if (GetVelocity().IsZero()) return 0.0f; const FVector ForwardVector = GetActorForwardVector(); const FVector VelocityNormalizedVector = GetVelocity().GetSafeNormal(); const float DotProductResult = FVector::DotProduct(ForwardVector, VelocityNormalizedVector); const float Theta = FMath::RadiansToDegrees(FMath::Acos(DotProductResult)); const FVector CrossProductResult = FVector::CrossProduct(ForwardVector, VelocityNormalizedVector); return (CrossProductResult.IsZero() ? Theta : FMath::Sign(CrossProductResult.Z) * Theta); } 代码优化: 前后左右移动的回调函数MoveForward和MoveRight # C++ 若 Amount 为0，直接返回 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::MoveForward(float Amount) { IsForward = Amount \u0026gt; 0.0f; if (Amount == 0.0f) return; AddMovementInput(GetActorForwardVector(), Amount); } void ASTUBaseCharacter::MoveRight(float Amount) { if (Amount == 0.0f) return; AddMovementInput(GetActorRightVector(), Amount); } 在蓝图中使用C++函数设置变量Direction # 虚幻编辑器 ABP_BaseCharacter \u0026gt; EventGraph 阻断动画蓝图无效状态 # 当我们打开动画蓝图时，其以standalone方式运行。即使未在虚幻编辑器中运行游戏，在蓝图编辑器打开ABP_BaseCharacter，其处于运行状态。可以看到动画蓝图视口的 Actor 是有动画的。 从EventBlueprintUpdateAnimation出发，TryGetPawnOwner得到空指针，停在CastToCharacter # 添加打印名，验证动画蓝图运行 # 未在虚幻编辑器运行游戏，保持动画蓝图在前台，日志窗口一直有输出 未运行游戏时，阻断动画蓝图 # 从 EventBlueprintUpdateAnimation 出发，添加 IsValid 宏，检查 Pawn 有效性 "}),e.add({id:39,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E6%8C%81%E7%BB%AD%E5%B0%84%E5%87%BB%E5%92%8C%E7%9E%84%E5%87%86%E5%81%8F%E7%A6%BB/",title:"持续射击和瞄准偏离",description:"说明 # 当前: 按下鼠标左键触发武器组件的回调函数, 其会调用武器的Fire接口; 只发射一次子弹 为发射子弹添加定时器, 鼠标左键按下开启定时器, 进行持续射击, 松开时关闭定时器 概览 # 恢复Camera组件位置 为武器发射子弹添加定时器 修改武器组件和游戏角色相关逻辑 实现瞄准偏离 恢复Camera组件位置, 使之拍摄游戏角色背面 # BP_STUBaseCharacter 设置Camera组件变换属性 Camera \u0026gt; Details \u0026gt; Transform \u0026gt; Rotation \u0026gt; Yaw = 0 在SpringArm组件细节面板设置Camera组件的Socket Offset SpringArm \u0026gt; Details \u0026gt; Camera \u0026gt; Socket Offset \u0026gt; X = 0 Y = 100 持续射击 # 修改武器发射子弹逻辑 # Stub # ShootThemUp: Weapon/STUBaseWeapon.h 定时器 private FTimerHandle ShotTimerHandle; 定时器间隔 protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float TimeBetweenShots = 0.1f; 回调函数使用MakeShot 添加FireStart和FireStop接口 # public ShootThemUp: Weapon/STUBaseWeapon.",content:"说明 # 当前: 按下鼠标左键触发武器组件的回调函数, 其会调用武器的Fire接口; 只发射一次子弹 为发射子弹添加定时器, 鼠标左键按下开启定时器, 进行持续射击, 松开时关闭定时器 概览 # 恢复Camera组件位置 为武器发射子弹添加定时器 修改武器组件和游戏角色相关逻辑 实现瞄准偏离 恢复Camera组件位置, 使之拍摄游戏角色背面 # BP_STUBaseCharacter 设置Camera组件变换属性 Camera \u0026gt; Details \u0026gt; Transform \u0026gt; Rotation \u0026gt; Yaw = 0 在SpringArm组件细节面板设置Camera组件的Socket Offset SpringArm \u0026gt; Details \u0026gt; Camera \u0026gt; Socket Offset \u0026gt; X = 0 Y = 100 持续射击 # 修改武器发射子弹逻辑 # Stub # ShootThemUp: Weapon/STUBaseWeapon.h 定时器 private FTimerHandle ShotTimerHandle; 定时器间隔 protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float TimeBetweenShots = 0.1f; 回调函数使用MakeShot 添加FireStart和FireStop接口 # public ShootThemUp: Weapon/STUBaseWeapon.h virtual void FireStart(); virtual void FireStop(); 设置定时器 # ShootThemUp: Weapon/STUBaseWeapon.cpp #include \u0026quot;TimerManager.h\u0026quot; void ASTUBaseWeapon::FireStart() { MakeShot(); GetWorldTimerManager().SetTimer(ShotTimerHandle, this, \u0026amp;ASTUBaseWeapon::MakeShot, TimeBetweenShots, true); } void ASTUBaseWeapon::FireStop() { GetWorldTimerManager().ClearTimer(ShotTimerHandle); } 移除Fire接口 # 修改武器组件发射子弹逻辑 # 添加回调函数FireStart和FireStop # public ShootThemUp: Components/STUWeaponComponent.h void FireStart(); void FireStop(); 调用武器的FireStart和FireStop接口 # ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::FireStart() { if (!CurrentWeapon) return; CurrentWeapon-\u0026gt;FireStart(); } void USTUWeaponComponent::FireStop() { if (!CurrentWeapon) return; CurrentWeapon-\u0026gt;FireStop(); } 移除Fire接口 # 修改扣动扳机按键绑定 # 屏蔽对武器组件Fire接口的绑定, 重新绑定武器组件的FireStart和FireStop接口 ShootThemUp: Player/STUBaseCharacter.cpp PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Fire\u0026quot;, IE_Pressed, WeaponComponent, \u0026amp;USTUWeaponComponent::FireStart); PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Fire\u0026quot;, IE_Released, WeaponComponent, \u0026amp;USTUWeaponComponent::FireStop); 瞄准目标时, 添加轻微偏离 # 建模 # 设想一个圆锥, 给出中心线和偏移角(顶角的一半), 随机返回圆锥内射线, 作为射击方向 添加偏移角 # protected ShootThemUp: Weapon/STUBaseWeapon.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float BulletSpread = 1.5f; 修改射击方向 # ShootThemUp: Weapon/STUBaseWeapon.cpp // GetTraceData const auto HalfRad = FMath::DegreesToRadians(BulletSpread); const FVector ShootDirection = FMath::VRandCone(ViewRotation.Vector(), HalfRad); 查看 # 按下鼠标左键数秒, 不移动鼠标, 子弹轨迹成束 遗留问题: 游戏角色射击时死亡, 射击定时器未关闭 测试方法: 在模拟榴弹爆炸的球内进行持续射击; 在MakeShot添加进入打印 进入MakeShot函数后, 因为游戏角色已被销毁, 不会继续处理 "}),e.add({id:40,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F/",title:"打包游戏",description:"说明 # 打包游戏，从二进制文件运行 定期打包游戏，确保所做改动能正常运行 设置玩家出发点 # 参考 LevelEditor \u0026gt; PlaceActors \u0026gt; Basic \u0026gt; PlayerStart，添加到关卡中 设置编译选项 # 项目设置 \u0026gt; Project \u0026gt; Packaging \u0026gt; Project \u0026gt; Build Configuration，选择 发行(Shipping) 编译游戏 # 参考 创建文件夹 ShootThemUp/Build 设置二进制文件保存路径 工具栏 \u0026gt; Platforms \u0026gt; Mac \u0026gt; Package Project，选择 Build 文件夹 可在日志窗口查看过程 打包成功 生成 ShootThemUp/Build/Mac/ShootThemUp-Shipping.app 尝试 Development 和 DebugGame 选项，均可 纯蓝图项目没有 DebugGame 选项 metal-ar报错 # 当前项目路径不包含空格，但包含汉字 打包项目 菜单栏 \u0026gt; File \u0026gt; Zip Project 移动到不含空格的英文路径 ",content:"说明 # 打包游戏，从二进制文件运行 定期打包游戏，确保所做改动能正常运行 设置玩家出发点 # 参考 LevelEditor \u0026gt; PlaceActors \u0026gt; Basic \u0026gt; PlayerStart，添加到关卡中 设置编译选项 # 项目设置 \u0026gt; Project \u0026gt; Packaging \u0026gt; Project \u0026gt; Build Configuration，选择 发行(Shipping) 编译游戏 # 参考 创建文件夹 ShootThemUp/Build 设置二进制文件保存路径 工具栏 \u0026gt; Platforms \u0026gt; Mac \u0026gt; Package Project，选择 Build 文件夹 可在日志窗口查看过程 打包成功 生成 ShootThemUp/Build/Mac/ShootThemUp-Shipping.app 尝试 Development 和 DebugGame 选项，均可 纯蓝图项目没有 DebugGame 选项 metal-ar报错 # 当前项目路径不包含空格，但包含汉字 打包项目 菜单栏 \u0026gt; File \u0026gt; Zip Project 移动到不含空格的英文路径 "}),e.add({id:41,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/",title:"阶段性总结",description:"项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent Player STUBaseCharacter STUPlayerController STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 左右移动 AddMovementInput；GetActorRightVector MoveForward 前后移动 AddMovementInput；GetActorForwardVector 左右旋转 ACharacter::AddControllerYawInput 上下旋转 ACharacter::AddControllerPitchInput 跳跃 ACharacter::Jump RunEnable，RunDisable 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机",content:`项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent Player STUBaseCharacter STUPlayerController STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 左右移动 AddMovementInput；GetActorRightVector MoveForward 前后移动 AddMovementInput；GetActorForwardVector 左右旋转 ACharacter::AddControllerYawInput 上下旋转 ACharacter::AddControllerPitchInput 跳跃 ACharacter::Jump RunEnable，RunDisable 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机
Locomotion作为OutputPose的输入 状态 状态 说明 走路 Walk BS_Locomotion_Walk；混合空间 跑步 Run BS_Locomotion_Run；混合空间1D 跳跃 JumpStart JumpLoop JumpEnd 变量 动画输入 名称 速度 Velocity 速度和前进方向的夹角 Directon 转换条件 说明 IsRunning C++ 满足3个条件：按下Shift；速度和前进方向夹角为0（按下W或Up）；速度不为0 IsFalling CharacterMovementComponent::IsFalling 返回true，意味着游戏角色跳起；接着返回false，意味着游戏角色回到地面 EventGraph # 设置变量 - Velocity Directon IsRunning IsFalling 组件 # C++ STUCharacterMovementComponent # 满足跑步条件时，提高运动速度上限 参数 说明 SpeedAcceleration 加速系数 `}),e.add({id:42,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E4%BD%BF%E7%94%A8eqs%E5%AF%BB%E6%89%BE%E7%94%9F%E5%91%BD%E8%A1%A5%E7%BB%99/",title:"使用EQS寻找生命补给",description:"说明 # AI / EQS / Find Health Pickup 概览 # EQS生成器 生成器限制条件 使用C++实现Decorator 暂时修改生命补给外观 # EQS标记也是亮色 Content \u0026gt; Materials 目录下选中 M_BaseColor 选择关卡中的BP_STUHealthPickup, 通过Details面板在蓝图编辑器中打开 BP_STUHealthPickup 选中 Static Mesh , 应用材质 回到关卡编辑器, 按住 Option 拖动BP_STUHealthPickup进行复制, 共三个 在场景中添加墙 Place Actors \u0026gt; Geometry \u0026gt; Box 设置墙; 将一个生命补给放在墙后 Details \u0026gt; Brush Settings , 设置X = 50, Y = 500, Z = 500 创建EQS资产 # Content/AI/EQS 目录下, 新建EQS资产, 命名为EQS_FindHealthPickup 添加生成器, 寻找场景中指定类型的Actor # Generators \u0026gt; Actors Of Class - Searched Actor Class 指定Actor类型 STUHealthPickup Search Radius 搜索半径 1500 设置场景中EQS_TestPawn使用的EQS模板 # Details \u0026gt; EQS \u0026gt; Query Template , 选择EQS_FindHealthPickup 移动EQS_TestPawn到合适位置, 三个生命补给均被标记为亮蓝色, 此时无视阻挡, 以搜索半径为准 为生成器添加限制条件: 要求视线可见 # Add Test \u0026gt; Trace 在Visibility通道计算Pawn到Actor之间是否存在其他物体阻挡视线 使用默认设置 - Trace \u0026gt; Trace Data \u0026gt; Trace Channel Visibility Trace \u0026gt; Trace Data \u0026gt; Trace Shape Line 勾选则要求阻挡 取消勾选则要求无阻挡 设置为无阻挡 - Filter \u0026gt; Bool Match 取消勾选 通道存在阻挡则Actor被标记为蓝色; 无阻挡被标记为绿色 为生成器添加限制条件: 寻找距离最近的生命补给 # Add Test \u0026gt; Distance - Filter \u0026gt; Filter Type Minimum Filter \u0026gt; Float Value Min 0 Score \u0026gt; Scoring Factor -1 距离越近, 权重越大 为生成器添加限制条件: 存在获取生命补给的有效路径 # Add Test \u0026gt; Path Finding 过滤掉无法去到的生命补给 使用默认设置 - Pathfinding \u0026gt; Test Mode Path Exists 在行为树中使用EQS_FindHealthPickup # 暂时停止当前逻辑 添加节点: Selector NPC寻找生命补给, 或等待 添加节点: Wait 设置时长为2s 添加序列 为序列添加任务: RunEQSQuery 设置EQS Details \u0026gt; EQS \u0026gt; EQSRequest \u0026gt; Query Template , 设置为EQS_FindHealthPickup Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 设置为AimLocation 为序列添加任务: MoveTo Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 设置为AimLocation 查看 # 在选中窗口运行 按下 F8 或者点击 Eject 拖动距离NPC最近的生命补给: NPC寻找并去到此时距离最近的生命补给位置 点击 Pause simulation , 将所有生命补给移动到墙后, 点击 Resume play-in-editor session 序列停止, NPC循环执行Wait任务 使用C++实现Decorator # 检查NPC生命值, 低于给定百分比NPC才会拾取生命补给 学习BTDecorator类 # 在CalculateRawConditionValue中计算条件布尔值 protected // calculates raw, core value of decorator's condition.",content:"说明 # AI / EQS / Find Health Pickup 概览 # EQS生成器 生成器限制条件 使用C++实现Decorator 暂时修改生命补给外观 # EQS标记也是亮色 Content \u0026gt; Materials 目录下选中 M_BaseColor 选择关卡中的BP_STUHealthPickup, 通过Details面板在蓝图编辑器中打开 BP_STUHealthPickup 选中 Static Mesh , 应用材质 回到关卡编辑器, 按住 Option 拖动BP_STUHealthPickup进行复制, 共三个 在场景中添加墙 Place Actors \u0026gt; Geometry \u0026gt; Box 设置墙; 将一个生命补给放在墙后 Details \u0026gt; Brush Settings , 设置X = 50, Y = 500, Z = 500 创建EQS资产 # Content/AI/EQS 目录下, 新建EQS资产, 命名为EQS_FindHealthPickup 添加生成器, 寻找场景中指定类型的Actor # Generators \u0026gt; Actors Of Class - Searched Actor Class 指定Actor类型 STUHealthPickup Search Radius 搜索半径 1500 设置场景中EQS_TestPawn使用的EQS模板 # Details \u0026gt; EQS \u0026gt; Query Template , 选择EQS_FindHealthPickup 移动EQS_TestPawn到合适位置, 三个生命补给均被标记为亮蓝色, 此时无视阻挡, 以搜索半径为准 为生成器添加限制条件: 要求视线可见 # Add Test \u0026gt; Trace 在Visibility通道计算Pawn到Actor之间是否存在其他物体阻挡视线 使用默认设置 - Trace \u0026gt; Trace Data \u0026gt; Trace Channel Visibility Trace \u0026gt; Trace Data \u0026gt; Trace Shape Line 勾选则要求阻挡 取消勾选则要求无阻挡 设置为无阻挡 - Filter \u0026gt; Bool Match 取消勾选 通道存在阻挡则Actor被标记为蓝色; 无阻挡被标记为绿色 为生成器添加限制条件: 寻找距离最近的生命补给 # Add Test \u0026gt; Distance - Filter \u0026gt; Filter Type Minimum Filter \u0026gt; Float Value Min 0 Score \u0026gt; Scoring Factor -1 距离越近, 权重越大 为生成器添加限制条件: 存在获取生命补给的有效路径 # Add Test \u0026gt; Path Finding 过滤掉无法去到的生命补给 使用默认设置 - Pathfinding \u0026gt; Test Mode Path Exists 在行为树中使用EQS_FindHealthPickup # 暂时停止当前逻辑 添加节点: Selector NPC寻找生命补给, 或等待 添加节点: Wait 设置时长为2s 添加序列 为序列添加任务: RunEQSQuery 设置EQS Details \u0026gt; EQS \u0026gt; EQSRequest \u0026gt; Query Template , 设置为EQS_FindHealthPickup Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 设置为AimLocation 为序列添加任务: MoveTo Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 设置为AimLocation 查看 # 在选中窗口运行 按下 F8 或者点击 Eject 拖动距离NPC最近的生命补给: NPC寻找并去到此时距离最近的生命补给位置 点击 Pause simulation , 将所有生命补给移动到墙后, 点击 Resume play-in-editor session 序列停止, NPC循环执行Wait任务 使用C++实现Decorator # 检查NPC生命值, 低于给定百分比NPC才会拾取生命补给 学习BTDecorator类 # 在CalculateRawConditionValue中计算条件布尔值 protected // calculates raw, core value of decorator's condition. Should not include calling IsInversed virtual bool CalculateRawConditionValue(UBehaviorTreeComponent\u0026amp; OwnerComp, uint8* NodeMemory) const; 创建C++类 # - 基类 BTDecorator 名称 STUHealthPercentDecorator 路径 AI/Decorators 属性 Public 添加到头文件搜索路径 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon/Components\u0026quot;, \u0026quot;ShootThemUp/Public/AI\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Tasks\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Services\u0026quot;, \u0026quot;ShootThemUp/Public/AI/EQS\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Decorators\u0026quot; }); 添加构造函数 # public ShootThemUp: AI/Decorators/STUHealthPercentDecorator.h USTUHealthPercentDecorator(); ShootThemUp: AI/Decorators/STUHealthPercentDecorator.cpp USTUHealthPercentDecorator::USTUHealthPercentDecorator() { NodeName = \u0026quot;Health Percent\u0026quot;; } 添加属性: 指定生命值 # protected ShootThemUp: AI/Decorators/STUHealthPercentDecorator.h UPROPERTY(EditAnywhere, BlueprintReadWrite) float HealthPercent = 0.6f; 覆写条件 # protected ShootThemUp: AI/Decorators/STUHealthPercentDecorator.h virtual bool CalculateRawConditionValue(UBehaviorTreeComponent\u0026amp; OwnerComp, uint8* NodeMemory) const override; 通过控制器获取当前Pawn, 通过Pawn获取健康组件 ShootThemUp: AI/Decorators/STUHealthPercentDecorator.cpp #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; #include \u0026quot;Components/STUHealthComponent.h\u0026quot; bool USTUHealthPercentDecorator::CalculateRawConditionValue(UBehaviorTreeComponent\u0026amp; OwnerComp, uint8* NodeMemory) const { const auto Controller = OwnerComp.GetAIOwner(); if (!Controller) return false; const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(Controller-\u0026gt;GetPawn()); if (!HealthComponent || HealthComponent-\u0026gt;IsDead()) return false; return HealthComponent-\u0026gt;GetHealthPercent() \u0026lt;= HealthPercent; } 使用STUHealthPercentDecorator # BT_STUCharacter 为Sequence添加Decorator 设置STUHealthPercentDecorator - Observer aborts Self 查看 NPC满生命值时呆在原地 \u0026gt; 使之生命值不大于60% \u0026gt; NPC去到生命补给所在 整理行为树 # 将本节新建序列移动到原行为树左侧: 优先级最高 作为Selector的下级; 设置Root节点 将Fire服务移动到选择器 NPC寻找生命补给时仍射击敌人(是否有敌人?) 查看时注意NPC是否满足寻找生命补给条件 恢复设置 # 可以恢复Fire服务目标: 保证当前为None 恢复生命补给材质 "}),e.add({id:43,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E7%BB%84%E4%BB%B6/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/",title:"自定义组件",description:"ActorComponent UActorComponent # UActorComponent::GetOwner # 访问组件上级 // Follow the Outer chain to get the AActor that 'Owns' this component UFUNCTION(BlueprintCallable, Category=\u0026quot;Components\u0026quot;, meta=(Keywords = \u0026quot;Actor Owning Parent\u0026quot;)) AActor* GetOwner() const; UActorComponent::GetOwner\u0026lt;T\u0026gt; # 访问组件上级 // Templated version of GetOwner(), will return nullptr if cast fails template\u0026lt; class T \u0026gt; T* GetOwner() const { return Cast\u0026lt;T\u0026gt;(GetOwner()); } ",content:"ActorComponent UActorComponent # UActorComponent::GetOwner # 访问组件上级 // Follow the Outer chain to get the AActor that 'Owns' this component UFUNCTION(BlueprintCallable, Category=\u0026quot;Components\u0026quot;, meta=(Keywords = \u0026quot;Actor Owning Parent\u0026quot;)) AActor* GetOwner() const; UActorComponent::GetOwner\u0026lt;T\u0026gt; # 访问组件上级 // Templated version of GetOwner(), will return nullptr if cast fails template\u0026lt; class T \u0026gt; T* GetOwner() const { return Cast\u0026lt;T\u0026gt;(GetOwner()); } "}),e.add({id:44,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E7%BB%84%E4%BB%B6/%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6/",title:"创建组件",description:"UObject::CreateDefaultSubobject\u0026lt;T\u0026gt; ",content:"UObject::CreateDefaultSubobject\u0026lt;T\u0026gt; "}),e.add({id:45,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E6%8E%A7%E5%88%B6%E5%99%A8/controller%E7%B1%BB/",title:"Controller类",description:"AController # 切换Pawn # AController::Possess # 切换到指定Pawn AController::OnPossess # protected 切换Pawn时被调用 // * // * Overridable native function for when this controller is asked to possess a pawn. // * @param InPawn The Pawn to be possessed // * virtual void OnPossess(APawn* InPawn); AController::GetPawn # 访问当前Pawn // Getter for Pawn FORCEINLINE APawn* GetPawn() const { return Pawn; } AController::GetPawn\u0026lt;T\u0026gt; # 访问当前Pawn // Templated version of GetPawn, will return nullptr if cast fails template\u0026lt;class T\u0026gt; T* GetPawn() const { return Cast\u0026lt;T\u0026gt;(Pawn); } AController::GetPlayerViewPoint # // * // * Returns Player's Point of View // * For the AI this means the Pawn's 'Eyes' ViewPoint // * For a Human player, this means the Camera's ViewPoint // * // * @output	out_Location, view location of player // * @output	out_rotation, view rotation of player // * UFUNCTION(BlueprintCallable, Category = Pawn) virtual void GetPlayerViewPoint( FVector\u0026amp; Location, FRotator\u0026amp; Rotation ) const; ",content:"AController # 切换Pawn # AController::Possess # 切换到指定Pawn AController::OnPossess # protected 切换Pawn时被调用 // * // * Overridable native function for when this controller is asked to possess a pawn. // * @param InPawn The Pawn to be possessed // * virtual void OnPossess(APawn* InPawn); AController::GetPawn # 访问当前Pawn // Getter for Pawn FORCEINLINE APawn* GetPawn() const { return Pawn; } AController::GetPawn\u0026lt;T\u0026gt; # 访问当前Pawn // Templated version of GetPawn, will return nullptr if cast fails template\u0026lt;class T\u0026gt; T* GetPawn() const { return Cast\u0026lt;T\u0026gt;(Pawn); } AController::GetPlayerViewPoint # // * // * Returns Player's Point of View // * For the AI this means the Pawn's 'Eyes' ViewPoint // * For a Human player, this means the Camera's ViewPoint // * // * @output	out_Location, view location of player // * @output	out_rotation, view rotation of player // * UFUNCTION(BlueprintCallable, Category = Pawn) virtual void GetPlayerViewPoint( FVector\u0026amp; Location, FRotator\u0026amp; Rotation ) const; "}),e.add({id:46,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2/object%E7%B1%BB/",title:"Object类",description:"虚幻引擎中最基础的类型，AActor类型的父类 不能在场景中添加UObject对象，可以在代码中创建UObject对象并对逻辑进行封装 UObject # UObject::CreateDefaultSubobject\u0026lt;T\u0026gt; # 创建组件 返回指向组件的指针 将this设置为组件的上级 参数 含义 说明 SubobjectName 虚幻编辑器中显示的组件名 FName类型 BTransient 使用默认值 使用 # StaticMesh = CreateDefaultSubobject\u0026lt;UStaticMeshComponent\u0026gt;(\u0026quot;StaticMeshInEditor\u0026quot;); 在C++中对变量StaticMesh做设置，在虚幻编辑器中对名为\u0026quot;StaticMeshInEditor\u0026quot;的组件做设置；二者相对应。 可以在C++中修改变量名；如果修改组件名，虚幻编辑器中该组件的已有设置会因找不到目标载体而无法生效。 ",content:"虚幻引擎中最基础的类型，AActor类型的父类 不能在场景中添加UObject对象，可以在代码中创建UObject对象并对逻辑进行封装 UObject # UObject::CreateDefaultSubobject\u0026lt;T\u0026gt; # 创建组件 返回指向组件的指针 将this设置为组件的上级 参数 含义 说明 SubobjectName 虚幻编辑器中显示的组件名 FName类型 BTransient 使用默认值 使用 # StaticMesh = CreateDefaultSubobject\u0026lt;UStaticMeshComponent\u0026gt;(\u0026quot;StaticMeshInEditor\u0026quot;); 在C++中对变量StaticMesh做设置，在虚幻编辑器中对名为\u0026quot;StaticMeshInEditor\u0026quot;的组件做设置；二者相对应。 可以在C++中修改变量名；如果修改组件名，虚幻编辑器中该组件的已有设置会因找不到目标载体而无法生效。 "}),e.add({id:47,href:"/docs/game/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD/",title:"星露谷物语",description:"书签 # 官方wiki 灰机wiki 模组 # 官方wiki-模组指南 mod推荐 说明 # 介绍的模组均为了提高可玩性, 并节省不必要的时间 安装环境 # macOS - 模组系统 SMAPI 模组网站 NexusMods SMAPI # Mod系统：SMAPI 下载 \u0026gt; 解压 \u0026gt; 运行 install on macOS.command \u0026gt; 2 浅色背景板 \u0026gt; 1 安装到默认路径: 要求包含Stardew Valley.dll文件 \u0026gt; 1 安装SMAPI 下载模组 # NexusMods 免费创建帐号 将下载好的模组拷贝到 /Users/XXX/Library/Application Support/Steam/steamapps/common/Stardew Valley/Contents/MacOS/Mods 通过名字搜索模组时, 使用下载量分辨 边下载边测试 模组配置菜单 # Generic Mod Config Menu 和农场动物培养感情 # auto-petter - 在玛妮家购买 Marnie Sells Auto-Petter 修改商店框架 Shop Tile Framework 添加限制条件 Expanded Preconditions Utility 设备自动化 # Automate 批量处理 # Tractor Mod 门自动打开/关闭 # Auto-gate 布告栏和日历便捷查询 # Billboard Anywhere 信息查询 # Lookup Anything npc地图 # NPC Map Locations 动物好友度提示 # Loved Labels Redux 沙漠矿洞电梯 # Better Elevator 宝箱管理 # Chests Anywhere 其他模组 # 任意位置召唤马: 平替拖拉机 Horse Flute Anywhere ",content:"书签 # 官方wiki 灰机wiki 模组 # 官方wiki-模组指南 mod推荐 说明 # 介绍的模组均为了提高可玩性, 并节省不必要的时间 安装环境 # macOS - 模组系统 SMAPI 模组网站 NexusMods SMAPI # Mod系统：SMAPI 下载 \u0026gt; 解压 \u0026gt; 运行 install on macOS.command \u0026gt; 2 浅色背景板 \u0026gt; 1 安装到默认路径: 要求包含Stardew Valley.dll文件 \u0026gt; 1 安装SMAPI 下载模组 # NexusMods 免费创建帐号 将下载好的模组拷贝到 /Users/XXX/Library/Application Support/Steam/steamapps/common/Stardew Valley/Contents/MacOS/Mods 通过名字搜索模组时, 使用下载量分辨 边下载边测试 模组配置菜单 # Generic Mod Config Menu 和农场动物培养感情 # auto-petter - 在玛妮家购买 Marnie Sells Auto-Petter 修改商店框架 Shop Tile Framework 添加限制条件 Expanded Preconditions Utility 设备自动化 # Automate 批量处理 # Tractor Mod 门自动打开/关闭 # Auto-gate 布告栏和日历便捷查询 # Billboard Anywhere 信息查询 # Lookup Anything npc地图 # NPC Map Locations 动物好友度提示 # Loved Labels Redux 沙漠矿洞电梯 # Better Elevator 宝箱管理 # Chests Anywhere 其他模组 # 任意位置召唤马: 平替拖拉机 Horse Flute Anywhere "}),e.add({id:48,href:"/docs/%E5%B0%8F%E8%BD%A6%E8%BD%A6/%E8%93%84%E7%94%B5%E6%B1%A0/",title:"蓄电池",description:"2022-04-29 汽车的自动启停功能 # 城市道路会经常遇到红绿灯，这个时候就要一直踩刹车；若开启自动启停功能，踩下刹车至指示灯亮起，这个时候可以松刹车，车仍保持刹车状态. 需要启动时，再踩油门 有自动启停功能的汽车，需要蓄电池提供相应支持，也就是配置支持启停的蓄电池. 价格也会贵一些 支持启停的蓄电池 # 有EFB和AGM两种，AGM的价格更贵一些，二者不一定可以相互替代：EFB的蓄电池具有耐高温的特点，那么汽车原装蓄电池是EFB类型的，就不建议更换为价格更贵的AGM 更换蓄电池 # 方法一: 去4S店 # 原装蓄电池一般只有4S店可以拿到货 方法二: 自己购买对应型号质量好的蓄电池, 去店里找师傅帮忙更换 # - 风帆（Sail） 国产蓄电池品牌，和4S店有合作关系，很多原装蓄电池都是该品牌的特供; 以他们家为参考 Varta (瓦尔塔) 淘宝上有旗舰店 蓄电池的规格 # 如12V69Ah360ADIN，680A，这一串基本涵盖了蓄电池的所有规格。 12V电压，69Ah容量，额定电流360A，DIN为德国标准（买车的时候会听到德标指的就是这个），680A冷启动电流。 其中, 12V电压是不允许有偏差的； 69Ah容量，像我咨询过风帆的电话客服，这种规格一般用于特供的蓄电池，匹配到个人能够购买到的蓄电池型号，对应为70Ah，据说不会对汽车产生不好的影响； 360A额定电流，这个标准不挑； 680A的冷启动电流，主要针对南北气候差异（北方冬天太冷了）, 南方对标680A就可以了，而北方可能会在给定范围内偏上，如700A，具体怎样我不知道，我是南方，可以买到680A的蓄电池且满足要求的较多. 因此, 满足这个规格的风帆的电池为EFB H6（LN3），6-QW-70（680）-L，12V70Ah680A，可以包安装 关于汽车蓄电池亏电 # 在疫情封控期间没办法出门, 在这之前自己对汽车没什么了解, 没有定期发动汽车给蓄电池充电的认知 为了避免汽车亏电，应该每周都把汽车开出来跑跑, 每次使用的时长不能太短，一去一回一个小时比较合适 其实蓄电池也就用了1年半，说坏了真不至于，可能是亏电导致的蓄电池损坏，网上那种亏电-\u0026gt;搭电-\u0026gt;跑个把小时-\u0026gt;第二天无法启动的例子多不胜数. 所以亏电不是小事，远不止搭电那么简单 师傅给搭电时, 可能只保证引擎能够发动，而不会检查蓄电池是否正常，也不会给你把蓄电池充到比较正常的程度（靠谱程度自己衡量）. 如果蓄电池有问题, 或者自己上路跑了一会但蓄电池仍处于亏电的状态, 若这个时候自己关了火, 那可就要倒霉了 一则需要师傅再次搭电, 上回是在车库, 而这回是在马路; 再则, 汽车亏电的时候连后备箱都打不开（机械打开好样的），也就是说, 连三角警示牌都拿不出来（人和车都很不安全） 如果遇到亏电，我的建议是，找个师傅搭电，或者自备搭电宝（前提是自己会操作），等到车子启动后，跑上个把小时, 再去4S店做检查，看看有没有其他问题，蓄电池是否正常，一次搞清楚. 切记, 半路不要关火，不要关火，不要关火，重要的事情讲三遍 如果蓄电池没有问题，只是亏电，建议上路跑3个小时左右 ",content:"2022-04-29 汽车的自动启停功能 # 城市道路会经常遇到红绿灯，这个时候就要一直踩刹车；若开启自动启停功能，踩下刹车至指示灯亮起，这个时候可以松刹车，车仍保持刹车状态. 需要启动时，再踩油门 有自动启停功能的汽车，需要蓄电池提供相应支持，也就是配置支持启停的蓄电池. 价格也会贵一些 支持启停的蓄电池 # 有EFB和AGM两种，AGM的价格更贵一些，二者不一定可以相互替代：EFB的蓄电池具有耐高温的特点，那么汽车原装蓄电池是EFB类型的，就不建议更换为价格更贵的AGM 更换蓄电池 # 方法一: 去4S店 # 原装蓄电池一般只有4S店可以拿到货 方法二: 自己购买对应型号质量好的蓄电池, 去店里找师傅帮忙更换 # - 风帆（Sail） 国产蓄电池品牌，和4S店有合作关系，很多原装蓄电池都是该品牌的特供; 以他们家为参考 Varta (瓦尔塔) 淘宝上有旗舰店 蓄电池的规格 # 如12V69Ah360ADIN，680A，这一串基本涵盖了蓄电池的所有规格。 12V电压，69Ah容量，额定电流360A，DIN为德国标准（买车的时候会听到德标指的就是这个），680A冷启动电流。 其中, 12V电压是不允许有偏差的； 69Ah容量，像我咨询过风帆的电话客服，这种规格一般用于特供的蓄电池，匹配到个人能够购买到的蓄电池型号，对应为70Ah，据说不会对汽车产生不好的影响； 360A额定电流，这个标准不挑； 680A的冷启动电流，主要针对南北气候差异（北方冬天太冷了）, 南方对标680A就可以了，而北方可能会在给定范围内偏上，如700A，具体怎样我不知道，我是南方，可以买到680A的蓄电池且满足要求的较多. 因此, 满足这个规格的风帆的电池为EFB H6（LN3），6-QW-70（680）-L，12V70Ah680A，可以包安装 关于汽车蓄电池亏电 # 在疫情封控期间没办法出门, 在这之前自己对汽车没什么了解, 没有定期发动汽车给蓄电池充电的认知 为了避免汽车亏电，应该每周都把汽车开出来跑跑, 每次使用的时长不能太短，一去一回一个小时比较合适 其实蓄电池也就用了1年半，说坏了真不至于，可能是亏电导致的蓄电池损坏，网上那种亏电-\u0026gt;搭电-\u0026gt;跑个把小时-\u0026gt;第二天无法启动的例子多不胜数. 所以亏电不是小事，远不止搭电那么简单 师傅给搭电时, 可能只保证引擎能够发动，而不会检查蓄电池是否正常，也不会给你把蓄电池充到比较正常的程度（靠谱程度自己衡量）. 如果蓄电池有问题, 或者自己上路跑了一会但蓄电池仍处于亏电的状态, 若这个时候自己关了火, 那可就要倒霉了 一则需要师傅再次搭电, 上回是在车库, 而这回是在马路; 再则, 汽车亏电的时候连后备箱都打不开（机械打开好样的），也就是说, 连三角警示牌都拿不出来（人和车都很不安全） 如果遇到亏电，我的建议是，找个师傅搭电，或者自备搭电宝（前提是自己会操作），等到车子启动后，跑上个把小时, 再去4S店做检查，看看有没有其他问题，蓄电池是否正常，一次搞清楚. 切记, 半路不要关火，不要关火，不要关火，重要的事情讲三遍 如果蓄电池没有问题，只是亏电，建议上路跑3个小时左右 "}),e.add({id:49,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E5%8A%A8%E7%94%BB/animsequencebase%E7%B1%BB/",title:"AnimSequenceBase类",description:"便签 # UE_5.1/Engine/Source/Runtime/Engine/Classes/Animation/AnimSequenceBase.h AnimSequenceBase::Notifies # public 存放通知事件 按时间排序 TArray\u0026lt;struct FAnimNotifyEvent\u0026gt; Notifies; ",content:"便签 # UE_5.1/Engine/Source/Runtime/Engine/Classes/Animation/AnimSequenceBase.h AnimSequenceBase::Notifies # public 存放通知事件 按时间排序 TArray\u0026lt;struct FAnimNotifyEvent\u0026gt; Notifies; "}),e.add({id:50,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/try/",title:"try",description:"试用插件, 重启后删除 try-安装 # (use-package try :ensure t) 尝试使用其他插件 # M-x, 执行try 输入想要尝试的插件名 如果查找不到, 执行package-refresh-contents后再执行try, 或者直接执行try-and-refresh ",content:"试用插件, 重启后删除 try-安装 # (use-package try :ensure t) 尝试使用其他插件 # M-x, 执行try 输入想要尝试的插件名 如果查找不到, 执行package-refresh-contents后再执行try, 或者直接执行try-and-refresh "}),e.add({id:51,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%83%B3%E6%B3%95/%E5%B0%9D%E8%AF%95evil/",title:"尝试Evil",description:"evil ",content:"evil "}),e.add({id:52,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E5%8F%8C%E9%93%BE%E7%AC%94%E8%AE%B0%E6%9C%AC/",title:"双链笔记本",description:"说明 # 不可能在多个地方维护同一个知识点 知识点之间的关联性有多种，方便的组织可以使笔记保持整洁 便签 # 显示引用 需配置roam文件根目录 # ;; (setq my/org-roam-directory \u0026quot;path/to/roam/notes/directory\u0026quot;) 安装org-roam # org-roam-安装 安装org-roam-ui # org-roam-ui-安装 为子树添加roam-id # (global-set-key (kbd \u0026quot;C-c y\u0026quot;) 'org-id-get-create) ",content:"说明 # 不可能在多个地方维护同一个知识点 知识点之间的关联性有多种，方便的组织可以使笔记保持整洁 便签 # 显示引用 需配置roam文件根目录 # ;; (setq my/org-roam-directory \u0026quot;path/to/roam/notes/directory\u0026quot;) 安装org-roam # org-roam-安装 安装org-roam-ui # org-roam-ui-安装 为子树添加roam-id # (global-set-key (kbd \u0026quot;C-c y\u0026quot;) 'org-id-get-create) "}),e.add({id:53,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BBc++/%E5%B0%86actor%E9%99%84%E5%8A%A0%E5%88%B0%E5%8F%AF%E5%8F%98%E6%8D%A2%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%82%E8%BD%BD%E7%82%B9/",title:"将Actor附加到可变换组件的挂载点",description:`说明 # 通过AActor::AttachToComponent将Actor附加到可变换组件的挂载点上, 要求已在组件上添加挂载点, 并提供以下信息 - Actor 可变换组件 挂载规则 挂载点名称 挂载函数 AActor::AttachToComponent # AActor::AttachToComponent 可变换组件: USceneComponent及其派生类 # 基类 UPrimitiveComponent USceneComponent UMeshComponent UPrimitiveComponent USkeletalMeshComponent UMeshComponent UStaticMeshComponent UMeshComponent 挂载规则: FAttachmentTransformRules对象 # FAttachmentTransformRules # 说明 # UE_5.1/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h 如何计算附加Actor的变换属性 数据成员 # LocationRule, RotationRule和ScaleRule
对应变换属性的三个分量 使用EAttachmentRule进行设置 bInWeldSimulatedBodies
Whether to weld simulated bodies together when attaching 不知道效果, 设为false 构造函数 # 对变换属性的分量应用相同规则 FAttachmentTransformRules(EAttachmentRule InRule, bool bInWeldSimulatedBodies) : LocationRule(InRule) , RotationRule(InRule) , ScaleRule(InRule) , bWeldSimulatedBodies(bInWeldSimulatedBodies) {} 为变换属性定制规则 FAttachmentTransformRules(EAttachmentRule InLocationRule, EAttachmentRule InRotationRule, EAttachmentRule InScaleRule, bool bInWeldSimulatedBodies) : LocationRule(InLocationRule) , RotationRule(InRotationRule) , ScaleRule(InScaleRule) , bWeldSimulatedBodies(bInWeldSimulatedBodies) {} EAttachmentRule # 说明 # UE_5.`,content:`说明 # 通过AActor::AttachToComponent将Actor附加到可变换组件的挂载点上, 要求已在组件上添加挂载点, 并提供以下信息 - Actor 可变换组件 挂载规则 挂载点名称 挂载函数 AActor::AttachToComponent # AActor::AttachToComponent 可变换组件: USceneComponent及其派生类 # 基类 UPrimitiveComponent USceneComponent UMeshComponent UPrimitiveComponent USkeletalMeshComponent UMeshComponent UStaticMeshComponent UMeshComponent 挂载规则: FAttachmentTransformRules对象 # FAttachmentTransformRules # 说明 # UE_5.1/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h 如何计算附加Actor的变换属性 数据成员 # LocationRule, RotationRule和ScaleRule
对应变换属性的三个分量 使用EAttachmentRule进行设置 bInWeldSimulatedBodies
Whether to weld simulated bodies together when attaching 不知道效果, 设为false 构造函数 # 对变换属性的分量应用相同规则 FAttachmentTransformRules(EAttachmentRule InRule, bool bInWeldSimulatedBodies) : LocationRule(InRule) , RotationRule(InRule) , ScaleRule(InRule) , bWeldSimulatedBodies(bInWeldSimulatedBodies) {} 为变换属性定制规则 FAttachmentTransformRules(EAttachmentRule InLocationRule, EAttachmentRule InRotationRule, EAttachmentRule InScaleRule, bool bInWeldSimulatedBodies) : LocationRule(InLocationRule) , RotationRule(InRotationRule) , ScaleRule(InScaleRule) , bWeldSimulatedBodies(bInWeldSimulatedBodies) {} EAttachmentRule # 说明 # UE_5.1/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h 如何计算附件Actor的最终变换矩阵 API 枚举成员 # - SnapToTarget Snaps transform to the attach point KeepWorld Automatically calculates the relative transform such that the attached component maintains the same world transform KeepRelative Keeps current relative transform as the relative transform to the new parent 不知道区别, 使用SnapToTarget; 使用KeepRelative可以达到一样的效果 `}),e.add({id:54,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/",title:"Git",description:"代码管理, 版本控制 安装 # macOS 方法一: Xcode自带 # 方法二: 使用homebrew安装较新版本 # brew install git 方法三: 下载源码, 编译安装 # 官网下载git-2.41.0.tar.gz make install 验证 # git -v 配置 # 查看Git配置 # git config --list 配置Git账户 # git config --global user.name \u0026quot;enjoy61\u0026quot; git config --global user.email \u0026quot;enjoy61@protonmail.com\u0026quot; 配置SSH # 生成密钥 ssh-keygen cat ~/.ssh/id_rsa.pub 拷贝公钥到Github 代理 # 设置 # 使用代理端口替换1949 git config --global https.proxy https://localhost:1949 git config --global http.proxy http://localhost:1949 取消 git config --global --unset http.",content:"代码管理, 版本控制 安装 # macOS 方法一: Xcode自带 # 方法二: 使用homebrew安装较新版本 # brew install git 方法三: 下载源码, 编译安装 # 官网下载git-2.41.0.tar.gz make install 验证 # git -v 配置 # 查看Git配置 # git config --list 配置Git账户 # git config --global user.name \u0026quot;enjoy61\u0026quot; git config --global user.email \u0026quot;enjoy61@protonmail.com\u0026quot; 配置SSH # 生成密钥 ssh-keygen cat ~/.ssh/id_rsa.pub 拷贝公钥到Github 代理 # 设置 # 使用代理端口替换1949 git config --global https.proxy https://localhost:1949 git config --global http.proxy http://localhost:1949 取消 git config --global --unset http.proxy git config --global --unset https.proxy 中文乱码 # git config --global core.quotepath false 初始化项目 # 已在Github创建项目 场景一: 从Github克隆项目，上游信息自动配置 # git clone git@github.com:enjoy61/even.git 查看远端信息 # git remote -v 场景二: 手动配置上游信息 # git init git remote add cute git@github.com:enjoy61/even.git # cute为上游别名 git fetch cute # 拉取上游内容，和Github项目同步 场景三: 首次提交本地项目到远端 # git init git add README.md # 添加管理文件 git commit -m \u0026quot;first commit\u0026quot; git branch -M main git remote add origin git@github.com:enjoy61/even.git git push -u origin main 子模块管理 # 添加子模块 # git submodule add git@github.com:enjoy61/hugo-theme-even.git themes/even 从远端拉取项目时亦拉取子模块项目 # git clone --recursive git@github.com:enjoy61/even.git 设置项目同步链接 # SSH git remote set-url cute git@github.com:enjoy61/even.git HTTPS push时需要验证，Github不再支持用户名和密码 git remote set-url cute https://github.com/enjoy61/even.git 文件托管 # 添加 # git add file # 指定文件 git add -A # 所有文件 删除 # git rm file 查看托管文件状态 # git diff 查看项目内文件状态 # git status 提交 # 提交当前改动 # git commit -m \u0026quot;first commit\u0026quot; 推送到远端 # git push 查看提交记录 # git log 删除历史提交 # # 查看提交记录 git log # 最新提交 F E D C B，要删除F和E，记录D # 设置回溯目标 git rebase -i D # 将F E的pick改为drop # 检查设置是否生效 git log # 查看当前提交 D C B # 同步到远端 git push cute master --force # 上游cute 分支master 存在多个文件添加/删除/修改，在上次提交的基础上再次提交 # 不建议如此操作，提交前建议检阅改动 项目文件夹一式两份，A和A.BAK, 项目新版本B 删除文件夹A内所有代码 不会删除.git，提交和同步记录均保留 rm -rf A/* 将B内的所有文件拷贝到A 不会拷贝.git cp -r B A 打开文件夹A, 再次提交 git add -A git commit -m \u0026quot;Comments\u0026quot; git push 提交规范 # \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; \u0026lt;body\u0026gt; \u0026lt;footer\u0026gt; 标题行 # 必填 类型 # type 标识 feat feature 新功能 fix 修复bug docs 文档 style 格式，如.clang-format refactor 重构 test 测试用例 build 项目构建和依赖项 revert 回退 ci 持续集成 perf 性能优化 merge 代码合并 sync 同步主线或分支的bug chore 其他类型 release 新版本发布 workflow 工作流 受到提交影响的范围 # scope 概述 # subject 动词开头 如果用英文，使用第一人称现在时，首字母小写 结尾不加句号 正文 # body 具体修改内容, 可多行 页脚注释 # footer 备注 分支 # 当前分支和分支列表 # git branch -a 切换分支 # git checkout main 创建分支 # git branch master 本地创建新分支后, 同步到远端 # git push --set-upstream origin master 创建并切换 # git checkout -b iss53 删除分支 # 本地 git branch -d iss51 上游 git push origin -d iss51 重命名分支 # 未推送到远端, 重命名即可 # git branch -m oldName newName 已推送过远端 # 重命名本地分支 git branch -m oldName newName 删除远端分支 git push --delete origin oldName 将本地分支推送到远端 git push origin newName 将本地分支和远端分支关联 git branch --set-upstream-to origin/newName 分支合并 # 合并过程中可能会产生冲突 git-scm 在iss53分支上开发新功能 git checkout master # 主分支 git checkout -b iss53 vim index.html git commit -a -m 'added a new footer [issue 53]' 在hotfix分支上解决问题 git checkout master # 主分支 git checkout -b hotfix vim index.html git commit -a -m 'fixed the broken email address' 在主分支上合并解决方案，删除hotfix分支 git checkout master git merge hotfix git branch -d hotfix 继续在分支iss53上开发新功能 git checkout iss53 vim index.html git commit -a -m 'finished the new footer [issue 53]' 合并新功能到主分支，删除iss53分支 git checkout master git merge iss53 git branch -d iss53 "}),e.add({id:55,href:"/docs/build-blog/%E4%BD%BF%E7%94%A8hugo+github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/",title:"使用Hugo+GitHub搭建静态博客",description:"说明 # - Github Pages 使用Github提供的免费服务部署静态博客 Hugo 本地构建静态网页 anubis 主题 安装Hugo # Github 官网 方法一: 使用go安装 # Windows 安装go 官网下载 环境变量 # go export PATH=/usr/local/go/bin:$PATH export GOROOT=/usr/local/go export GOPATH=/Users/USERNAME/go export GOBIN=/Users/USERNAME/go/bin # go安装的软件 export PATH=$GOBIN:$PATH 安装hugo 如若遇上网络不佳, 配置代理 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off 安装并验证 go install github.com/gohugoio/hugo@latest hugo env -v 部分主题需用hugo_extended提供的支持 方法二: 使用homebrew安装 # macOS brew install hugo 创建站点项目 # 新建站点 hugo new site /site/path 站点项目结构 文件 说明 config.",content:"说明 # - Github Pages 使用Github提供的免费服务部署静态博客 Hugo 本地构建静态网页 anubis 主题 安装Hugo # Github 官网 方法一: 使用go安装 # Windows 安装go 官网下载 环境变量 # go export PATH=/usr/local/go/bin:$PATH export GOROOT=/usr/local/go export GOPATH=/Users/USERNAME/go export GOBIN=/Users/USERNAME/go/bin # go安装的软件 export PATH=$GOBIN:$PATH 安装hugo 如若遇上网络不佳, 配置代理 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off 安装并验证 go install github.com/gohugoio/hugo@latest hugo env -v 部分主题需用hugo_extended提供的支持 方法二: 使用homebrew安装 # macOS brew install hugo 创建站点项目 # 新建站点 hugo new site /site/path 站点项目结构 文件 说明 config.toml 配置文件；yaml格式也可以 content 存放blog；支持md和org theme 存放主题 public 生成的静态页面；同步到Github项目 archetypes 文章模版 新建博客 所在目录为 ./content/post hugo new post/first-blog.org 使用主题anubis # anubis on hugo anubis on github 将主题作为项目子模块 git init git submodule add https://github.com/mitrichius/hugo-theme-anubis.git themes/anubis 使用anubis提供的模板 ./themes/anubis/exampleSite/ cp themes/anubis/exampleSite/config.toml . cp themes/anubis/exampleSite/content/. content 主题说明 提供标签(tags)和分类(categories)功能, 提供文章列表(archives) 文章存放到content/post目录下 文章模板 yaml --- author: \u0026quot;author\u0026quot; title: \u0026quot;article title\u0026quot; date: \u0026quot;2023-03-17\u0026quot; description: \u0026quot;article description\u0026quot; tags: [ \u0026quot;tag-1\u0026quot;, \u0026quot;tag-2\u0026quot;, ] categories: [ \u0026quot;category\u0026quot;, ] --- 简单介绍 \u0026lt;!- -more- -\u0026gt; 正文 移除 - - 之间的空格 构建静态网页 # 选项 说明 构建或测试 - -theme=anubis 设置主题 -t anubis both - -watch 修改文件后自动刷新浏览器 -w server - -buildDrafts 包括标记为draft的笔记 -D both - -buildFuture 包括新发布笔记；检查date选项 -F both - -baseUrl=\u0026quot;http://enjoy61.github.io/\u0026quot; 未配置编译，GithubPage部署会丢失样式 both - -cleanDestinationDir 将public文件夹中不再使用的文件删除 hugo 移除 - - 之间的空格 本地测试 # 查询server选项 参考 hugo help server 访问 http://localhost:1313/ hugo server --theme=anubis --watch # hugo server 构建静态页面 # 生成文件路径 ./public/ hugo --theme=anubis --baseUrl=\u0026quot;https://enjoy61.github.io/\u0026quot; # hugo 在Github创建项目 # 创建仓库 仓库名为enjoy61.github.io 使用Github Pages提供的免费服务需公开项目 测试服务: 为github设置主题 添加_config.yaml文件 remote_theme: pages-themes/midnight@v0.2.0 将public文件夹提交到仓库 "}),e.add({id:56,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99/%E4%BB%8B%E7%BB%8D%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F/",title:"介绍游戏模式",description:"Game Mode Overview 注意 # 当前运行游戏, 在地板中心位置会有火花特效, 不知什么原因 说明 # GameModeBase 对游戏进行设置和管理 游戏模式 Game Mode 根据游戏规则计算游戏分数, 调整游戏设置 Gameplay Setting , 玩家个数, AI玩家参与情况, 一个回合的时长, 回合总数, 如何判定游戏结束, 并计算各种游戏统计数据 BP_STUGameModeBase 对关卡各种基础类类型进行设置, 使用基类或覆写后的派生类, 游戏开始运行, 动态创建指定类对象 - Pawn HUD Player Controller Game State Player State Spectator GameMode的应用对象为给关卡 到目前为止, 我们都在使用默认关卡 本节会添加测试关卡 创建关卡 # File \u0026gt; New Level , 选择Basic, 命名为TestLevel, 保存到 Content/Levels 查看世界设置 World Settings , 可以看到各项都是默认设置, 即使用虚幻引擎提供的基类 运行, 世界大纲 World Outliner 中可以看到Actor列表和对应类型 - GameMode GameModeBase Pawn DefaultPawn 将游戏模式 Game Mode 设置为BP_STUGameModeBase, 则出现我们熟悉的游戏角色和HUD等 每个关卡都可以拥有自己的游戏模式, 而基本的游戏逻辑依旧存在 GameMode # GameMode派生自GameModeBase, 并扩展了额外功能 多玩家在游戏中匹配 Match State 逻辑 本课程会创建自己的匹配逻辑, 而不使用 GameModeBase GameModeBase # 会讲解该类的许多函数, 它们如何工作, 以何种顺序调用, 我们可以从游戏状态中获得何种信息, 如何暂停、重启游戏等 ",content:"Game Mode Overview 注意 # 当前运行游戏, 在地板中心位置会有火花特效, 不知什么原因 说明 # GameModeBase 对游戏进行设置和管理 游戏模式 Game Mode 根据游戏规则计算游戏分数, 调整游戏设置 Gameplay Setting , 玩家个数, AI玩家参与情况, 一个回合的时长, 回合总数, 如何判定游戏结束, 并计算各种游戏统计数据 BP_STUGameModeBase 对关卡各种基础类类型进行设置, 使用基类或覆写后的派生类, 游戏开始运行, 动态创建指定类对象 - Pawn HUD Player Controller Game State Player State Spectator GameMode的应用对象为给关卡 到目前为止, 我们都在使用默认关卡 本节会添加测试关卡 创建关卡 # File \u0026gt; New Level , 选择Basic, 命名为TestLevel, 保存到 Content/Levels 查看世界设置 World Settings , 可以看到各项都是默认设置, 即使用虚幻引擎提供的基类 运行, 世界大纲 World Outliner 中可以看到Actor列表和对应类型 - GameMode GameModeBase Pawn DefaultPawn 将游戏模式 Game Mode 设置为BP_STUGameModeBase, 则出现我们熟悉的游戏角色和HUD等 每个关卡都可以拥有自己的游戏模式, 而基本的游戏逻辑依旧存在 GameMode # GameMode派生自GameModeBase, 并扩展了额外功能 多玩家在游戏中匹配 Match State 逻辑 本课程会创建自己的匹配逻辑, 而不使用 GameModeBase GameModeBase # 会讲解该类的许多函数, 它们如何工作, 以何种顺序调用, 我们可以从游戏状态中获得何种信息, 如何暂停、重启游戏等 "}),e.add({id:57,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%9F%E6%88%90%E5%99%A8%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6/",title:"自定义生成器限制条件",description:"说明 # AI / EQS / Custom Test 验证EQS寻找补给时会把不可用补给考虑在内 # 补给不可用逻辑 # 补给被领取后, 设置在碰撞检测中忽略补给, 同时设置补给不可见, 使用定时器恢复碰撞和不可见选项 存在的问题 # 补给虽然无法参与碰撞, 在场景中也不可见, 但仍作为Actor存在于场景中, 于是NPC可以正常捕获 验证 # 初始状态 设置场景中一个补给不可见 选中BP_STUAmmoPickup1 设置CollisionComponent不可见 Details \u0026gt; Rendering \u0026gt; Visible 取消勾选: 注意到, 碰撞胶囊已不可见 设置StaticMesh不可见 Details \u0026gt; Rendering \u0026gt; Visible 取消勾选 移动EQS_TestPawn, 仍可以捕获不可见补给 恢复补给状态 考虑解决方案 # 自定义生成器: 筛选可见Actor 自定义生成器限制条件: 筛选可见Actor 考虑如何实现自定义生成器限制条件 # 判断组件可见性 根组件的选择很灵活, 在一些方案里, 即使根组件不可见, Actor也许能被正常观察; 而根组件可见, Actor也不一定能被正常观察到 为补给添加接口: 判断补给是否可用 相应地, 该限制条件只能用于补给 创建C++类 # - 基类 EnvQueryTest 名称 EnvQueryTest_PickupCouldBeTaken 路径 AI/EQS 属性 Public 学习EnvQueryTest及其派生类 # 派生类命名规则 # 引擎使用该模板识别限制条件在EQS蓝图编辑器的名称 EnvQueryTest_子类别 筛选Actor接口 # EnvQueryTest 每次EQS运行时, 调用该函数; 在该函数中, 对捕获Actor进行筛选 public // Function that does the actual work virtual void RunTest(FEnvQueryInstance\u0026amp; QueryInstance) const { checkNoEntry(); } 筛选Actor逻辑 # 参考限制条件Trace EnvQueryTest_Trace 构造函数 # UEnvQueryTest_Trace::UEnvQueryTest_Trace(const FObjectInitializer\u0026amp; ObjectInitializer) : Super(ObjectInitializer) { Cost = EEnvTestCost::High; ValidItemType = UEnvQueryItemType_VectorBase::StaticClass(); SetWorkOnFloatValues(false); Context = UEnvQueryContext_Querier::StaticClass(); TraceData.",content:"说明 # AI / EQS / Custom Test 验证EQS寻找补给时会把不可用补给考虑在内 # 补给不可用逻辑 # 补给被领取后, 设置在碰撞检测中忽略补给, 同时设置补给不可见, 使用定时器恢复碰撞和不可见选项 存在的问题 # 补给虽然无法参与碰撞, 在场景中也不可见, 但仍作为Actor存在于场景中, 于是NPC可以正常捕获 验证 # 初始状态 设置场景中一个补给不可见 选中BP_STUAmmoPickup1 设置CollisionComponent不可见 Details \u0026gt; Rendering \u0026gt; Visible 取消勾选: 注意到, 碰撞胶囊已不可见 设置StaticMesh不可见 Details \u0026gt; Rendering \u0026gt; Visible 取消勾选 移动EQS_TestPawn, 仍可以捕获不可见补给 恢复补给状态 考虑解决方案 # 自定义生成器: 筛选可见Actor 自定义生成器限制条件: 筛选可见Actor 考虑如何实现自定义生成器限制条件 # 判断组件可见性 根组件的选择很灵活, 在一些方案里, 即使根组件不可见, Actor也许能被正常观察; 而根组件可见, Actor也不一定能被正常观察到 为补给添加接口: 判断补给是否可用 相应地, 该限制条件只能用于补给 创建C++类 # - 基类 EnvQueryTest 名称 EnvQueryTest_PickupCouldBeTaken 路径 AI/EQS 属性 Public 学习EnvQueryTest及其派生类 # 派生类命名规则 # 引擎使用该模板识别限制条件在EQS蓝图编辑器的名称 EnvQueryTest_子类别 筛选Actor接口 # EnvQueryTest 每次EQS运行时, 调用该函数; 在该函数中, 对捕获Actor进行筛选 public // Function that does the actual work virtual void RunTest(FEnvQueryInstance\u0026amp; QueryInstance) const { checkNoEntry(); } 筛选Actor逻辑 # 参考限制条件Trace EnvQueryTest_Trace 构造函数 # UEnvQueryTest_Trace::UEnvQueryTest_Trace(const FObjectInitializer\u0026amp; ObjectInitializer) : Super(ObjectInitializer) { Cost = EEnvTestCost::High; ValidItemType = UEnvQueryItemType_VectorBase::StaticClass(); SetWorkOnFloatValues(false); Context = UEnvQueryContext_Querier::StaticClass(); TraceData.SetGeometryOnly(); } Cost 说明限制条件逻辑的复杂度, 复杂度越高, 开销就越大 使用枚举类型EEnvTestCost对其进行赋值 复杂度参考用于待测试Actor的数学运算 ValidItemType 说明测试对象的数据类别, 数组或者元素 - UEnvQueryItemType_VectorBase 数组 UEnvQueryItemType_ActorBase 元素 SetWorkOnFloatValues 限制条件部分参数的模式由FilterType决定, SetWorkOnFloatValues使用枚举类型EEnvTestFilterType对FilterType进行设置 - Minimum 数值 Maximum 数值 Range 数值 Match 布尔类型 参数为true时, FilterType值为Range; 参数为false, FilterType值为Match: 这两个相当于是两种默认类型 如果FilterType为Range, 通常可以在蓝图编辑器中根据需求设置数值的其他模式Minimum和Maximum void UEnvQueryTest::SetWorkOnFloatValues(bool bWorkOnFloats) { bWorkOnFloatValues = bWorkOnFloats; // Make sure FilterType is set to a valid value. if (bWorkOnFloats) { if (FilterType == EEnvTestFilterType::Match) { FilterType = EEnvTestFilterType::Range; } } else { if (FilterType != EEnvTestFilterType::Match) { FilterType = EEnvTestFilterType::Match; } // Scoring MUST be Constant for boolean tests. ScoringEquation = EEnvTestScoreEquation::Constant; } UpdatePreviewData(); } UEnvQueryTest_Trace::RunTest # FEnvQueryInstance::ItemIterator EQS专用的迭代器类型 获取Actor位置 const FVector ItemLocation = GetItemLocation(QueryInstance, It.GetIndex()) + FVector(0, 0, ItemZ); 通用模板: 遍历捕获目标 for (FEnvQueryInstance::ItemIterator It(this, QueryInstance); It; ++It) { const auto ItemActor = GetItemActor(QueryInstance, It.GetIndex()); // 后续需对ItemActor作出修改时, 移除const限定符 // ... } 设置Actor通过筛选 - TestPurpose 枚举类型TEnumAsByteEEnvTestPurpose, 取值 Filter Only , Score Only , Filter and Score FilterType Score 如果时布尔类型, 为true, 通过筛选; 为false, 未通过. 如果是数值, 为权重值 bExpected 为true, Score决定筛选情况; 为false, 对Score对应的结果取反 It.SetScore(TestPurpose, FilterType, true, true); 设置Actor未通过筛选 - InStatus 使用枚举类型EEnvItemStatus对其赋值, 表示是否通过筛选: Failed 或 Passed Score 使用默认值 It.ForceItemState(EEnvItemStatus::Failed); 修改补给基类 # 提供测试机制: 返回设置值 通过定时器状态判断: 若定时器开启, 认为补给无效 添加属性: 开启测试 # protected ShootThemUp: Pickups/STUBasePickup.h UPROPERTY(EditAnywhere, BlueprintReadWrite) bool EnableTest = true; 添加属性: 测试结果 # protected ShootThemUp: Pickups/STUBasePickup.h UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EditCondition = \u0026quot;EnableTest\u0026quot;)) bool CouldBeTakenTest = true; 添加属性: 存放定时器描述符 # private ShootThemUp: Pickups/STUBasePickup.h FTimerHandle RespawnTimerHandle; 屏蔽定时器描述符变量定义 ShootThemUp: Pickups/STUBasePickup.cpp // PickupWasTaken 添加接口: 判断补给是否可用 # public ShootThemUp: Pickups/STUBasePickup.h bool CouldBeTaken() const; ShootThemUp: Pickups/STUBasePickup.cpp bool ASTUBasePickup::CouldBeTaken() const { if (EnableTest) { return CouldBeTakenTest; } else { return !GetWorldTimerManager().IsTimerActive(RespawnTimerHandle); } } 实现EnvQueryTest_PickupCouldBeTaken # 构造函数 # - 低开销 单个元素 使用布尔类型 public ShootThemUp: AI/EQS/EnvQueryTest_PickupCouldBeTaken.h UEnvQueryTest_PickupCouldBeTaken(const FObjectInitializer \u0026amp;ObjectInitializer); ShootThemUp: AI/EQS/EnvQueryTest_PickupCouldBeTaken.cpp #include \u0026quot;EnvironmentQuery/Items/EnvQueryItemType_ActorBase.h\u0026quot; UEnvQueryTest_PickupCouldBeTaken::UEnvQueryTest_PickupCouldBeTaken(const FObjectInitializer \u0026amp;ObjectInitializer) // : Super (ObjectInitializer) { Cost = EEnvTestCost::Low; ValidItemType = UEnvQueryItemType_ActorBase::StaticClass(); SetWorkOnFloatValues(false); } RunTest # public ShootThemUp: AI/EQS/EnvQueryTest_PickupCouldBeTaken.h virtual void RunTest(FEnvQueryInstance\u0026amp; QueryInstance) const override; ShootThemUp: AI/EQS/EnvQueryTest_PickupCouldBeTaken.cpp #include \u0026quot;Pickups/STUBasePickup.h\u0026quot; void UEnvQueryTest_PickupCouldBeTaken::RunTest(FEnvQueryInstance\u0026amp; QueryInstance) const { for (FEnvQueryInstance::ItemIterator It(this, QueryInstance); It; ++It) { const auto ItemActor = GetItemActor(QueryInstance, It.GetIndex()); const auto PickupActor = Cast\u0026lt;ASTUBasePickup\u0026gt;(ItemActor); if (!PickupActor) continue; const auto CouldBeTaken = PickupActor-\u0026gt;CouldBeTaken(); if (CouldBeTaken) { It.SetScore(TestPurpose, FilterType, true, true); } else { It.ForceItemState(EEnvItemStatus::Failed); } } } 使用PickupCouldBeTaken # 为EQS_FindAmmoPickup的生成器添加PickupCouldBeTaken Add Test \u0026gt; Pickup Could be Taken 选中EQS_TestPawn, 合适补给被标记为绿色 选择一个被标记为绿色的补给, 使之状态无效 勾选 Enable Test , 取消 Could Be Taken Test 勾选 移动EQS_TestPawn, 该补给不再有效 注意 # 通过勾选和取消勾选生成器的限制条件, 可以对若干指定项进行测试, 且立即生效 当前, PickupCouldBeTaken \u0026gt; Details \u0026gt; Filter \u0026gt; Bool Match 是否勾选无区别. 而在限制条件的设计中, 期望其勾选状态的改变应该导致相反的结果 EnvQueryTest取反逻辑 # 获取BoolMatch值: 决定是否对筛选结果取反 EnvQueryTest_Trace BoolValue是一个特殊类型, 通过成员函数GetValue获取布尔值 UObject* DataOwner = QueryInstance.Owner.Get(); BoolValue.BindData(DataOwner, QueryInstance.QueryID); bool BoolMatchValue = BoolValue.GetValue(); 使用SetScore统一设置是否通过筛选 Score 筛选结果 true 通过筛选 false 未通过筛选 Bool Match 是否对结果取反 true false 对结果取反 It.SetScore(TestPurpose, FilterType, Score, BoolMatchValue); 实现EnvQueryTest_PickupCouldBeTaken结果取反 # CouldBeTaken true 可以被拾取 false 无法被拾取 Bool Match - true false 对结果取反 void UEnvQueryTest_PickupCouldBeTaken::RunTest(FEnvQueryInstance\u0026amp; QueryInstance) const { const auto DataOwner = QueryInstance.Owner.Get(); BoolValue.BindData(DataOwner, QueryInstance.QueryID); const auto BoolMatchValue = BoolValue.GetValue(); for (FEnvQueryInstance::ItemIterator It(this, QueryInstance); It; ++It) { const auto ItemActor = GetItemActor(QueryInstance, It.GetIndex()); const auto PickupActor = Cast\u0026lt;ASTUBasePickup\u0026gt;(ItemActor); if (!PickupActor) continue; const auto CouldBeTaken = PickupActor-\u0026gt;CouldBeTaken(); It.SetScore(TestPurpose, FilterType, CouldBeTaken, BoolMatchValue); } } 查看取反效果 # EQS_FindAmmoPickup \u0026gt; PickupCouldBeTaken \u0026gt; Details \u0026gt; Filter \u0026gt; Bool Match 默认勾选 取消勾选 为EQS_FindHealthPickup生成器添加限制条件PickupCouldBeTaken 设置补给默认关闭测试 # 默认关闭测试. 之前默认开启. 不用挨个关闭补给测试 ShootThemUp: Pickups/STUBasePickup.h UPROPERTY(EditAnywhere, BlueprintReadWrite) bool EnableTest = false; "}),e.add({id:58,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E6%8E%A7%E5%88%B6%E5%99%A8/playercontroller%E7%B1%BB/",title:"PlayerController类",description:"APlayerController # APlayerController::GetPlayerViewPoint # 获取摄像机的位置和方向向量 对基类函数进行覆写 AController::GetPlayerViewPoint 在多个游戏角色间切换 # AController::Possess ",content:"APlayerController # APlayerController::GetPlayerViewPoint # 获取摄像机的位置和方向向量 对基类函数进行覆写 AController::GetPlayerViewPoint 在多个游戏角色间切换 # AController::Possess "}),e.add({id:59,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2/actor%E7%B1%BB/",title:"Actor类",description:"虚幻C++基础类型，能放置到世界场景中的物体，具有相同的基类AActor。 所有能添加到世界场景中的物体都可称作Actor，如几何体，特效，声音。Actor对象有无实体均可。 可视化需要USceneComponent组件，模型需要UStaticMeshComponent组件。 可以在虚幻编辑器中往关卡添加Actor对象，也可以在代码中动态生成Actor对象。 Actor对象由各种Component组成，所有组件可以根据需求进行组装，方便重用。 AActor # 头文件 # UE_5.1/Engine/Source/Runtime/Engine/Classes/GameFrameWork/Actor.h 派生关系 # AActor ^ UObject ^ UObjectBaseUtility 构成 # - 构造函数 BeginPlay 出现在场景中 Tick 每秒更新 AActor::AttachToComponent # 将Actor附加到可变换组件的挂载点 声明 # // ** // * Attaches the RootComponent of this Actor to the supplied component, optionally at a named socket. It is not valid to call this on components that are not Registered. // * @param Parent	Parent to attach to. // * @param AttachmentRules	How to handle transforms and welding when attaching.",content:"虚幻C++基础类型，能放置到世界场景中的物体，具有相同的基类AActor。 所有能添加到世界场景中的物体都可称作Actor，如几何体，特效，声音。Actor对象有无实体均可。 可视化需要USceneComponent组件，模型需要UStaticMeshComponent组件。 可以在虚幻编辑器中往关卡添加Actor对象，也可以在代码中动态生成Actor对象。 Actor对象由各种Component组成，所有组件可以根据需求进行组装，方便重用。 AActor # 头文件 # UE_5.1/Engine/Source/Runtime/Engine/Classes/GameFrameWork/Actor.h 派生关系 # AActor ^ UObject ^ UObjectBaseUtility 构成 # - 构造函数 BeginPlay 出现在场景中 Tick 每秒更新 AActor::AttachToComponent # 将Actor附加到可变换组件的挂载点 声明 # // ** // * Attaches the RootComponent of this Actor to the supplied component, optionally at a named socket. It is not valid to call this on components that are not Registered. // * @param Parent	Parent to attach to. // * @param AttachmentRules	How to handle transforms and welding when attaching. // * @param SocketName	Optional socket to attach to on the parent. // * void AttachToComponent(USceneComponent* Parent, const FAttachmentTransformRules\u0026amp; AttachmentRules, FName SocketName = NAME_None); 参数 # - Parent 目标, 可变换组件 AttachmentRules 挂载规则 SocketName 挂载点名字 从属关系 # AActor::SetOwner # public 设置上级 // * // * Set the owner of this Actor, used primarily for network replication. // * @param NewOwner	The Actor who takes over ownership of this Actor // * UFUNCTION(BlueprintCallable, Category=Actor) virtual void SetOwner( AActor* NewOwner ); AActor::GetOwner # public 访问上级 // Get the owner of this Actor, used primarily for network replication UFUNCTION(BlueprintCallable, Category=Actor) AActor* GetOwner() const; AActor::GetOwner\u0026lt;T\u0026gt; # public 访问上级 // Templated version of GetOwner(), will return nullptr if cast fails template\u0026lt; class T \u0026gt; T* GetOwner() const { return Cast\u0026lt;T\u0026gt;(GetOwner()); } "}),e.add({id:60,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/npc%E8%A1%8C%E4%B8%BA/npc%E7%A7%BB%E5%8A%A8/",title:"NPC移动",description:"设置NPC # 蓝图 # BP_STUAICharacter Details \u0026gt; Pawn 勾选 Auto Possess AI 设置 AI Controller Class C++ # STUAICharacter #include \u0026quot;AI/STUAIController.h\u0026quot; ASTUAICharacter::ASTUAICharacter(const FObjectInitializer \u0026amp;ObjInit) : Super(ObjInit) { AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned; AIControllerClass = ASTUAIController::StaticClass(); } 囊括NPC移动范围 # 使用NavMeshBoundsVolume标识NPC可移动区域 Place Actors \u0026gt; Volumes \u0026gt; NavMeshBoundsVolume 设置NavMeshBoundsVolume体积: 长宽高均要考虑设置 Details \u0026gt; Brush Settings 查看 按下 P 显示 / 隐藏 在 Unreal Editor \u0026gt; Preference \u0026gt; General \u0026gt; Keyboard Shortcuts \u0026gt; Show Flags Menu \u0026gt; Show Navigation 修改快捷键 方法一: 在AIController中使NPC移动 # 添加节点 AIMoveTo , 在 BeginPlay 后执行 方法二: 使用行为树和黑板资产 # 添加黑板变量 # BB_STUCharacter 添加Vector变量Location1和Location2 设置行为树 # BT_STUCharacter 设置匹配的黑板资产 # Details \u0026gt; BehaviorTree \u0026gt; Blackboard Asset 添加Sequence节点 # 为Sequence添加任务MoveTo 设置 Details \u0026gt; Blackboard \u0026gt; Blackboard Key 为 Location1 为Sequence添加任务Wait 设置 Details \u0026gt; Wait \u0026gt; Wait Time 为2 为Sequence添加任务MoveTo 设置 Details \u0026gt; Blackboard \u0026gt; Blackboard Key 为 Location2 为Sequence添加任务Wait 设置 Details \u0026gt; Wait \u0026gt; Wait Time 为2 设置黑板变量 # BP_STUAIController 添加节点: SetValueAsVector 添加节点: GetBlackboard; 获取黑板资产, 连到 SetValueAsVector \u0026gt; Target 添加节点: MakeLiteralName; 传入黑板变量名, 连到 SetValueAsVector \u0026gt; Key Name 设置Vector值 运行行为树 # 蓝图 # BP_STUAIController 添加节点: RunBehaviorTree; 在BeginPlay之后执行; 需设置BTAsset C++ # 添加属性: 保存行为树信息 STUAICharacter class UBehaviorTree; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) UBehaviorTree *BehaviorTreeAsset; 运行行为树 控制器每次切换控制Pawn, 执行对应的行为树 STUAIController #include \u0026quot;AI/STUAICharacter.",content:"设置NPC # 蓝图 # BP_STUAICharacter Details \u0026gt; Pawn 勾选 Auto Possess AI 设置 AI Controller Class C++ # STUAICharacter #include \u0026quot;AI/STUAIController.h\u0026quot; ASTUAICharacter::ASTUAICharacter(const FObjectInitializer \u0026amp;ObjInit) : Super(ObjInit) { AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned; AIControllerClass = ASTUAIController::StaticClass(); } 囊括NPC移动范围 # 使用NavMeshBoundsVolume标识NPC可移动区域 Place Actors \u0026gt; Volumes \u0026gt; NavMeshBoundsVolume 设置NavMeshBoundsVolume体积: 长宽高均要考虑设置 Details \u0026gt; Brush Settings 查看 按下 P 显示 / 隐藏 在 Unreal Editor \u0026gt; Preference \u0026gt; General \u0026gt; Keyboard Shortcuts \u0026gt; Show Flags Menu \u0026gt; Show Navigation 修改快捷键 方法一: 在AIController中使NPC移动 # 添加节点 AIMoveTo , 在 BeginPlay 后执行 方法二: 使用行为树和黑板资产 # 添加黑板变量 # BB_STUCharacter 添加Vector变量Location1和Location2 设置行为树 # BT_STUCharacter 设置匹配的黑板资产 # Details \u0026gt; BehaviorTree \u0026gt; Blackboard Asset 添加Sequence节点 # 为Sequence添加任务MoveTo 设置 Details \u0026gt; Blackboard \u0026gt; Blackboard Key 为 Location1 为Sequence添加任务Wait 设置 Details \u0026gt; Wait \u0026gt; Wait Time 为2 为Sequence添加任务MoveTo 设置 Details \u0026gt; Blackboard \u0026gt; Blackboard Key 为 Location2 为Sequence添加任务Wait 设置 Details \u0026gt; Wait \u0026gt; Wait Time 为2 设置黑板变量 # BP_STUAIController 添加节点: SetValueAsVector 添加节点: GetBlackboard; 获取黑板资产, 连到 SetValueAsVector \u0026gt; Target 添加节点: MakeLiteralName; 传入黑板变量名, 连到 SetValueAsVector \u0026gt; Key Name 设置Vector值 运行行为树 # 蓝图 # BP_STUAIController 添加节点: RunBehaviorTree; 在BeginPlay之后执行; 需设置BTAsset C++ # 添加属性: 保存行为树信息 STUAICharacter class UBehaviorTree; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) UBehaviorTree *BehaviorTreeAsset; 运行行为树 控制器每次切换控制Pawn, 执行对应的行为树 STUAIController #include \u0026quot;AI/STUAICharacter.h\u0026quot; void ASTUAIController::OnPossess(APawn *InPawn) { Super::OnPossess(InPawn); const auto STUCharacter = Cast\u0026lt;ASTUAICharacter\u0026gt;(InPawn); if (STUCharacter) { RunBehaviorTree(STUCharacter-\u0026gt;BehaviorTreeAsset); } } 查看AI调试信息 # 按下 ' 显示 / 隐藏 界面 按下小写键盘数字 关闭 / 打开 指定类别调试信息 建议在新窗口运行游戏, Character Preview无阻挡 Modes \u0026gt; New Editor Window(PIE) "}),e.add({id:61,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E8%AE%A9npc%E7%A7%BB%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/",title:"让NPC移动到指定位置",description:"说明 # AI Character / Controller / Navmesh 创建类 # NPC游戏角色 - 基类 STUBaseCharacter Public 路径 AI/ STUAICharacter 相应控制器 - 基类 AIController Public 路径 AI/ STUAIController 添加到头文件搜索路径 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon/Components\u0026quot;, \u0026quot;ShootThemUp/Public/AI\u0026quot; }); 创建文件夹 Content/AI 创建基于STUAICharacter和STUAIController的蓝图类, 添加前缀BP_ 配置BP_STUAICharacter # 参照BP_STUBaseCharacter 显示修改过的属性 设置属性时善用复制粘贴 对BP_AIBaseCharacter进行修改 生命值文本 网格体 设置动画蓝图类 健康组件 武器组件 为NPC使能AI # BP_STUAICharacter 允许该游戏角色直接添加到场景中或动态生成; 设置控制器类型 移除添加到场景中的BP_STUBaseCharacter, 添加BP_AIBaseCharacter 运行游戏, 正常生成NPC和AI控制器 让NPC移动到指定位置 # 设置地板大小 添加Actor到场景一角 Place Actors \u0026gt; Basic \u0026gt; Actor 双击打开BP_STUAIController 添加节点AIMoveTo, 在BeginPlay之后执行: 将控制器当前控制的游戏角色移动到目的地, 通过给出目的地座标或指示Actor 添加NavMeshBoundsVolume: 覆盖NPC移动区域 Place Actors \u0026gt; Volumes \u0026gt; NavMeshBoundsVolume 设置NavMeshBoundsVolume大小: 高度管控层级; 与场景中的其他网格体有交互 Details \u0026gt; Brush Settings 绿色高亮显示导航网格体的覆盖区域, 按下 P 显示 / 隐藏 Unreal Editor \u0026gt; Preference \u0026gt; General \u0026gt; Keyboard Shortcuts 优化榴弹爆炸特效 # Content/VFX/Projectile 烟雾和火球无法扩散, 将烟雾效果扩大, 火球效果缩小 NE_Burst NE_Fireball NE_Flash NE_Smoke Properties使能Local Space NE_Fireball # 分布半径 NE_Smoke # 粒子数 分布半径 NS_ProjectileExplosion # 优化步枪击中特效 # NE_CoreFast # NE_ShortBurst1 # NE_ShortBurst2 # ",content:"说明 # AI Character / Controller / Navmesh 创建类 # NPC游戏角色 - 基类 STUBaseCharacter Public 路径 AI/ STUAICharacter 相应控制器 - 基类 AIController Public 路径 AI/ STUAIController 添加到头文件搜索路径 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon/Components\u0026quot;, \u0026quot;ShootThemUp/Public/AI\u0026quot; }); 创建文件夹 Content/AI 创建基于STUAICharacter和STUAIController的蓝图类, 添加前缀BP_ 配置BP_STUAICharacter # 参照BP_STUBaseCharacter 显示修改过的属性 设置属性时善用复制粘贴 对BP_AIBaseCharacter进行修改 生命值文本 网格体 设置动画蓝图类 健康组件 武器组件 为NPC使能AI # BP_STUAICharacter 允许该游戏角色直接添加到场景中或动态生成; 设置控制器类型 移除添加到场景中的BP_STUBaseCharacter, 添加BP_AIBaseCharacter 运行游戏, 正常生成NPC和AI控制器 让NPC移动到指定位置 # 设置地板大小 添加Actor到场景一角 Place Actors \u0026gt; Basic \u0026gt; Actor 双击打开BP_STUAIController 添加节点AIMoveTo, 在BeginPlay之后执行: 将控制器当前控制的游戏角色移动到目的地, 通过给出目的地座标或指示Actor 添加NavMeshBoundsVolume: 覆盖NPC移动区域 Place Actors \u0026gt; Volumes \u0026gt; NavMeshBoundsVolume 设置NavMeshBoundsVolume大小: 高度管控层级; 与场景中的其他网格体有交互 Details \u0026gt; Brush Settings 绿色高亮显示导航网格体的覆盖区域, 按下 P 显示 / 隐藏 Unreal Editor \u0026gt; Preference \u0026gt; General \u0026gt; Keyboard Shortcuts 优化榴弹爆炸特效 # Content/VFX/Projectile 烟雾和火球无法扩散, 将烟雾效果扩大, 火球效果缩小 NE_Burst NE_Fireball NE_Flash NE_Smoke Properties使能Local Space NE_Fireball # 分布半径 NE_Smoke # 粒子数 分布半径 NS_ProjectileExplosion # 优化步枪击中特效 # NE_CoreFast # NE_ShortBurst1 # NE_ShortBurst2 # "}),e.add({id:62,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E5%88%9D%E8%AF%86cascade%E5%92%8Cniagara/",title:"初识Cascade和Niagara",description:"说明 # VFX 视觉特效 Visual Effects 的缩写 Niagara 和 Cascade 虚幻引擎提供的两个特效编辑器, Niagara较新 从ShooterGame导出资产 # 选中 Content/Effects/ParticleSystems/Weapon , 右键, Migrate 导出文件夹Effects包含4个子文件夹 导入到ShootThemUp # 移动到 Content/ExternalContent/ 为Pickup和Effects文件夹设置颜色 熟悉Cascade # 创建文件夹 Content/VFX 空白处右键, 命名为PS_Test 双击打开: 视口在左侧, 显示粒子系统; 发射器 Emitter 在右侧, 对粒子系统进行设置 选择设置项类别, 去到 Details 进行设置 设置每帧生成粒子数 # Emitters \u0026gt; Spawn , Details \u0026gt; Spawn \u0026gt; Rate \u0026gt; Distribution \u0026gt; Constant , 由20改为200: 视口粒子数便多 设置粒子生存时间 # Emitters \u0026gt; Lifetime , Details \u0026gt; Lifetime \u0026gt; Distribution \u0026gt; Max , 由1.",content:"说明 # VFX 视觉特效 Visual Effects 的缩写 Niagara 和 Cascade 虚幻引擎提供的两个特效编辑器, Niagara较新 从ShooterGame导出资产 # 选中 Content/Effects/ParticleSystems/Weapon , 右键, Migrate 导出文件夹Effects包含4个子文件夹 导入到ShootThemUp # 移动到 Content/ExternalContent/ 为Pickup和Effects文件夹设置颜色 熟悉Cascade # 创建文件夹 Content/VFX 空白处右键, 命名为PS_Test 双击打开: 视口在左侧, 显示粒子系统; 发射器 Emitter 在右侧, 对粒子系统进行设置 选择设置项类别, 去到 Details 进行设置 设置每帧生成粒子数 # Emitters \u0026gt; Spawn , Details \u0026gt; Spawn \u0026gt; Rate \u0026gt; Distribution \u0026gt; Constant , 由20改为200: 视口粒子数便多 设置粒子生存时间 # Emitters \u0026gt; Lifetime , Details \u0026gt; Lifetime \u0026gt; Distribution \u0026gt; Max , 由1.0改为10.0: 粒子上升得更高 使粒子分布在圆柱体中 # 添加其他设置项 空白处右键 设置圆柱体半径 添加粒子发射器 # 空白处右键 设置材质 Emitter \u0026gt; Required , Details \u0026gt; Emitter \u0026gt; Material 查看 # 添加到关卡: 多个粒子发射器组合的效果 在Cascade编辑器中查看粒子特效 # ExternalContent \u0026gt; Effects 过滤资产 双击打开 P_Launcher_IH 榴弹爆炸特效. 可以看到一组配置好的粒子发射器, 共同构成爆炸 查看单个粒子发射器效果: 点击 S Solo 熟悉Niagara # 创建Niagara粒子发射器 # Content/VFX 空白处右键 使用模板 选择 Upward Mesh Burst, 命名为NE_BaseImpact 之后会根据子弹击中的表面创建不同的冲击特效 Niagara编辑器 # 双击打开NE_BaseImpact 预览窗口在左侧, 中间对粒子系统进行设置, 底部有时间线 设置每次生成的粒子个数 # NE_BaseImpact \u0026gt; Emitter Update \u0026gt; Spawn Burst Instantaneous , Selection \u0026gt; Spawn Count, 由80改为10 设置粒子颜色 # NE_BaseImpact \u0026gt; Particle Spawn \u0026gt; Initialize Particle , Selection \u0026gt; Point Attribute \u0026gt; Color Mode 添加Niagara粒子发射器 # 将NE_BaseImpact拖到到视口, 添加失败. 原因在于PS_Test可以包含多个粒子发射器, 将其拖动到视口时, 创建对应Actor. 而一个Niagara粒子发射器就是一个资产, 通常会将多个Niagara粒子发射器组合起来使用, 而Niagara粒子发射器可用于多个组合. 创建Niagara粒子系统 # Content/VFX 空白处右键 创建空的粒子系统, 命名为NS_BaseImpact 如果选择 New system from selected emitter(s) , 可以选择 NE_BaseImpact 添加粒子发射器 # 双击打开 NS_BaseImpact 空白处右键 添加NE_BaseImpact 修改NE_BaseImpact在NS_BaseImpact中的设置而不影响NE_BaseImpact本身的设置 添加Niagara粒子系统 # "}),e.add({id:63,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A1%A5%E7%BB%99/%E8%A1%A5%E7%BB%99%E5%9F%BA%E7%B1%BB%E7%94%9F%E5%91%BD%E8%A1%A5%E7%BB%99%E5%92%8C%E5%BC%B9%E8%8D%AF%E8%A1%A5%E7%BB%99/",title:"补给基类、生命补给和弹药补给",description:"为地板和楼梯添加材质 # 从ShooterGame导出材质 # Content/Environment/Materials - M_FFA_Floor_02_Dark 地板 M_FFA_Wall_04 楼梯 导出 相关资产 导入到ShootThemUp # 创建文件夹 Content/ExternalContent/Pickup , 保存到此处 设置地板 # 应用材质 设置变换 设置楼梯 # 移除楼梯 添加楼梯 Place Actors \u0026gt; Geometry \u0026gt; Box 设置纹理 设置变换 设置规格 一共四级台阶 按下Option键, 延Z轴拖动台阶; Z方向按80递增, X方向按250递增 创建所需静态网格体和材质 # 创建材质类 # Content/Materials 创建材质, 命名为M_BaseGlow 两个参数: Color和Glow 发光参数默认值设为10 创建材质实例 MI_BlueGlow MI_GreenGlow 如图 创建静态网格体 # 新建文件夹 Content/Pickups/StaticMeshes 创建生命补给 # Place Actors \u0026gt; Geometry \u0026gt; Box , 添加 设置 Details \u0026gt; Brush Settings , X = 40, Y = 80, Z = 40 按下E, 切换到旋转模式 按下Option, 绕X轴旋转90渡 按下Command, 选中两个笔刷 Brush , Details \u0026gt; Brush Settings \u0026gt; Create Static Mesh 保存到 Content/Pickups/StaticMeshes , 命名为S_Health 双击打开, 应用材质 创建弹药补给 # Place Actors \u0026gt; Geometry \u0026gt; Cylinder , 添加 设置基准 Transform \u0026gt; Location : X = 1000, Y = 2000, Z = 50 圆柱有三个参数, 高度, 半径和分片 按下Option, 向上拖动, 设置参数 按下Option, 向上拖动, 设置参数 Place Actors \u0026gt; Geometry \u0026gt; Sphere , 添加 球体有两个参数, 半径和细分 按下Command, 选中三个圆柱和球体, 拖动, 二者间隔50 选中6个圆柱体, 2个球体, Details \u0026gt; Brush Settings \u0026gt; Create Static Mesh 命名为S_Rockets 应用材质 创建补给类 # 基类 上级文件夹 属性 STUBasePickup Actor Pickups Public STUAmmoPickup STUBasePickup STUHealthPickup STUBasePickup 创建派生类 C++ Classes \u0026gt; ShootThemUp \u0026gt; Public \u0026gt; Pickups \u0026gt; STUBasePickup 添加头文件搜索路径 ShootThemUp: ShootThemUp.",content:"为地板和楼梯添加材质 # 从ShooterGame导出材质 # Content/Environment/Materials - M_FFA_Floor_02_Dark 地板 M_FFA_Wall_04 楼梯 导出 相关资产 导入到ShootThemUp # 创建文件夹 Content/ExternalContent/Pickup , 保存到此处 设置地板 # 应用材质 设置变换 设置楼梯 # 移除楼梯 添加楼梯 Place Actors \u0026gt; Geometry \u0026gt; Box 设置纹理 设置变换 设置规格 一共四级台阶 按下Option键, 延Z轴拖动台阶; Z方向按80递增, X方向按250递增 创建所需静态网格体和材质 # 创建材质类 # Content/Materials 创建材质, 命名为M_BaseGlow 两个参数: Color和Glow 发光参数默认值设为10 创建材质实例 MI_BlueGlow MI_GreenGlow 如图 创建静态网格体 # 新建文件夹 Content/Pickups/StaticMeshes 创建生命补给 # Place Actors \u0026gt; Geometry \u0026gt; Box , 添加 设置 Details \u0026gt; Brush Settings , X = 40, Y = 80, Z = 40 按下E, 切换到旋转模式 按下Option, 绕X轴旋转90渡 按下Command, 选中两个笔刷 Brush , Details \u0026gt; Brush Settings \u0026gt; Create Static Mesh 保存到 Content/Pickups/StaticMeshes , 命名为S_Health 双击打开, 应用材质 创建弹药补给 # Place Actors \u0026gt; Geometry \u0026gt; Cylinder , 添加 设置基准 Transform \u0026gt; Location : X = 1000, Y = 2000, Z = 50 圆柱有三个参数, 高度, 半径和分片 按下Option, 向上拖动, 设置参数 按下Option, 向上拖动, 设置参数 Place Actors \u0026gt; Geometry \u0026gt; Sphere , 添加 球体有两个参数, 半径和细分 按下Command, 选中三个圆柱和球体, 拖动, 二者间隔50 选中6个圆柱体, 2个球体, Details \u0026gt; Brush Settings \u0026gt; Create Static Mesh 命名为S_Rockets 应用材质 创建补给类 # 基类 上级文件夹 属性 STUBasePickup Actor Pickups Public STUAmmoPickup STUBasePickup STUHealthPickup STUBasePickup 创建派生类 C++ Classes \u0026gt; ShootThemUp \u0026gt; Public \u0026gt; Pickups \u0026gt; STUBasePickup 添加头文件搜索路径 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot; }); 补给基类 # STUBasePickup 添加碰撞组件 ShootThemUp: Pickups/STUBasePickup.h protected class USphereComponent; UPROPERTY(VisibleAnywhere) USphereComponent *CollisionComponent; 触发重叠事件 ShootThemUp: Pickups/STUBasePickup.cpp #include \u0026quot;Components/SphereComponent.h\u0026quot; DEFINE_LOG_CATEGORY_STATIC(LogBasePickup, All, All); // Constructor CollisionComponent = CreateDefaultSubobject\u0026lt;USphereComponent\u0026gt;(\u0026quot;SphereComponent\u0026quot;); CollisionComponent-\u0026gt;InitSphereRadius(50.0f); CollisionComponent-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly); CollisionComponent-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap); SetRootComponent(CollisionComponent); 覆写NotifyActorBeginOverlap函数, 发生重叠事件时调用 ShootThemUp: Pickups/STUBasePickup.h protected virtual void NotifyActorBeginOverlap(AActor *OtherActor) override; 重叠后销毁Actor ShootThemUp: Pickups/STUBasePickup.cpp void ASTUBasePickup::NotifyActorBeginOverlap(AActor *OtherActor) { Super::NotifyActorBeginOverlap(OtherActor); UE_LOG(LogBasePickup, Display, TEXT(\u0026quot;Pickups was taken\u0026quot;)); Destroy(); } 创建蓝图类 # 创建基于STUAmmoPickup和STUHealthPickup的蓝图类, 保存到 Content/Pickups 为蓝图类添加静态网格体组件, 绑定 Content/Pickups/StaticMeshes 下的静态网格体 弹药补给 生命补给 查看 # 日志 "}),e.add({id:64,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%99%9A%E5%B9%BB%E8%BF%90%E5%8A%A8%E5%9B%BE%E8%A1%A8/%E5%9C%A8%E8%93%9D%E5%9B%BE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%94%9F%E5%91%BD%E6%9D%A1/",title:"在蓝图中使用窗口部件实现游戏角色生命条",description:"说明 # 了解如何在UE中实现用户接口 了解窗口部件, 用来显示游戏角色生命值 Widget Health Bar 纯蓝图 概览 # 在C++中返回生命值百分比 创建窗口部件蓝图 WBP 在HUD类中创建窗口部件并添加到关卡 实现窗口部件: 添加进度条 便签 # 命名规范 实现接口: 返回生命值百分比 # C++ ShootThemUp: Components/STUHealthComponent.h public UFUNCTION(BlueprintCallable) float GetHealthPercent() const { return Health / MaxHealth; } 要求MaxHealth大于0 # ShootThemUp: Components/STUHealthComponent.cpp // BeginPlay checkf(MaxHealth \u0026gt; 0, TEXT(\u0026quot;MaxHealth must more than 0\u0026quot;)); 了解用户接口 # 虚幻编辑器 创建UI文件夹 # Content/UI 创建窗口蓝图 # 去到UI文件夹, 在空白处右键 User Interface \u0026gt; Widget Blueprint 设置基类: 选择 Common \u0026gt; User Widget 命名为WBP_PlayerHUD 虚幻用户接口编辑器 # 双击WBP_PlayerHUD 模式 # 在右上角进行切换 - 设计 Designer Blueprint Designer Mode 图表 Graph Graph Editing Mode 和EventGraph类似, 根据游戏事件实现用户接口 设计模式 # 层级结构窗口",content:`说明 # 了解如何在UE中实现用户接口 了解窗口部件, 用来显示游戏角色生命值 Widget Health Bar 纯蓝图 概览 # 在C++中返回生命值百分比 创建窗口部件蓝图 WBP 在HUD类中创建窗口部件并添加到关卡 实现窗口部件: 添加进度条 便签 # 命名规范 实现接口: 返回生命值百分比 # C++ ShootThemUp: Components/STUHealthComponent.h public UFUNCTION(BlueprintCallable) float GetHealthPercent() const { return Health / MaxHealth; } 要求MaxHealth大于0 # ShootThemUp: Components/STUHealthComponent.cpp // BeginPlay checkf(MaxHealth \u0026gt; 0, TEXT(\u0026quot;MaxHealth must more than 0\u0026quot;)); 了解用户接口 # 虚幻编辑器 创建UI文件夹 # Content/UI 创建窗口蓝图 # 去到UI文件夹, 在空白处右键 User Interface \u0026gt; Widget Blueprint 设置基类: 选择 Common \u0026gt; User Widget 命名为WBP_PlayerHUD 虚幻用户接口编辑器 # 双击WBP_PlayerHUD 模式 # 在右上角进行切换 - 设计 Designer Blueprint Designer Mode 图表 Graph Graph Editing Mode 和EventGraph类似, 根据游戏事件实现用户接口 设计模式 # 层级结构窗口
Hierarchy 左侧; 对元素按照双亲 Parent 和后继者 Inheritor 关系进行分组 添加Canvas Panel
作为所有元素的根组件 在选项板搜索框输入 Canvas Panel , 拖入添加 选项板窗口
Palette 左侧; 包含各种窗口元素, 拖入元素到视口实现元素添加; 如按钮 Button , 文本框 Text , 复选框 Check Box 等 元素的细节面板在右侧 按钮
Common \u0026gt; Button 文本框
Common \u0026gt; Text 可以在细节面板设置文本的内容和颜色等 水平对齐盒
Horizontal Box 对元素进行分组, 并使之水平对齐; 孩子元素的变换依赖于双亲元素的变换 添加下级元素, 可设置元素的填充方式
按钮和文本框作为其下属元素 按钮的填充方式默认为Auto, 设置为Fill 在层级结构选中按钮元素, 去到细节面板, Slot(Horizontal Box Slot) \u0026gt; Size 在虚幻编辑器视口添加窗口部件 # 让STUGameHUD类作为用户接口的控制器 Controller 创建基于STUGameHUD的蓝图类 # 命名为BP_STUGameHUD, 保存到Content/UI 设置关卡使用BP_STUGameHUD # 在BP_STUGameHUD中实现 # 去到 EventGraph 在BeginPlay中完成 创建窗口部件 # 添加节点 User Interface \u0026gt; Create Widget 设置窗口部件类型为 WBP_PlayerHUD 在视口中添加窗口部件 # 添加节点 User Interface \u0026gt; Viewport \u0026gt; Add to Viewport , 刚创建的窗口部件作为其输入 查看效果 # 按下 Shift+F1 释放鼠标 实现生命条 # WBP_PlayerHUD 移除 Canvas Panel 外的所有元素 添加进度条 进度条 # Progress Bar 由两张图片组成: 一个作为背景, 一个对进度条进行填充; 后者的大小根据进度改变 修改进度查看效果 # 选中进度条, 去到细节面板, 拖动以修改 Progress \u0026gt; Percent , 查看不同 设置进度条颜色 # ProgressBar \u0026gt; Details \u0026gt; Style \u0026gt; Fill Image \u0026gt; Tint 设置为绿色 属性: 绑定 # Bind 虚幻动作图表中不可忽视的一个属性, 呈现为下拉框 Drop-down Box 支持将更新函数绑定到数值 为生命条绑定更新函数 # 创建蓝图函数: Get_Health_Percent
ProgressBar \u0026gt; Details \u0026gt; Progress \u0026gt; Percent \u0026gt; Bind \u0026gt; Create Binding 在图表模式中查看 重命名为 Get_Health_Percent 实现Get_Health_Percent逻辑
获取Pawn实例 添加节点 Player \u0026gt; Get Owning Player Pawn 获取健康组件 添加节点 Actor \u0026gt; Get Components by Class 设置组件类型为 STUHealthComponent 调用健康组件提供的函数 GetHealthPercent 检查Pawn实例和健康组件的返回指针的有效性 添加节点 IsValid 若均有效, 返回值来自 GetHealthPercent ; 否则, 返回0 查看 # 修改生命值恢复频率 # BP_STUBaseCharacter 设置为0.03; 生命值恢复时, 进度条变化较圆滑, 相应地, 速度变快 `}),e.add({id:65,href:"/docs/%E5%B0%8F%E8%BD%A6%E8%BD%A6/",title:"🚗",description:"",content:""}),e.add({id:66,href:"/docs/%E5%B0%8F%E8%BD%A6%E8%BD%A6/%E6%8D%A2%E9%9B%A8%E5%88%AE/",title:"换雨刮",description:"2023-09-14 雨刮条掉着摆有一段时间了, 某日下雨, 心思一动, 便在网上找准型号下单了雨刮 注意: 车里的玻璃水有够 # 买回来的雨刮 # 有两条, 长度不一样, 长的那个在驾驶位那侧 胶条外可能有保护套, 取下 让雨刮竖起来 # 雨刮待工时, 受车盖限制, 无法拉离车玻璃 去到驾驶室, 点火, 关火, 向下按动雨刷档. 雨刷弹起 换雨刮 # 雨刮中间点可以看到一个方形的卡扣, 不是那么容易就可以分离骨架和雨刮, 我用钥匙怼卡扣 骨架和雨刮都是比较软的塑料(硬塑料也不建议, 会留下痕迹), 怼雨刮可以, 因为换下来就没用了, 注意不要怼到骨架, 会上火 换另一边雨刮时, 人还是站在驾驶位这边 欣赏成果 # 如果玻璃水不够的话, 就看不到新换的雨刮把玻璃擦干净的样子了 ",content:"2023-09-14 雨刮条掉着摆有一段时间了, 某日下雨, 心思一动, 便在网上找准型号下单了雨刮 注意: 车里的玻璃水有够 # 买回来的雨刮 # 有两条, 长度不一样, 长的那个在驾驶位那侧 胶条外可能有保护套, 取下 让雨刮竖起来 # 雨刮待工时, 受车盖限制, 无法拉离车玻璃 去到驾驶室, 点火, 关火, 向下按动雨刷档. 雨刷弹起 换雨刮 # 雨刮中间点可以看到一个方形的卡扣, 不是那么容易就可以分离骨架和雨刮, 我用钥匙怼卡扣 骨架和雨刮都是比较软的塑料(硬塑料也不建议, 会留下痕迹), 怼雨刮可以, 因为换下来就没用了, 注意不要怼到骨架, 会上火 换另一边雨刮时, 人还是站在驾驶位这边 欣赏成果 # 如果玻璃水不够的话, 就看不到新换的雨刮把玻璃擦干净的样子了 "}),e.add({id:67,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E5%8A%A8%E7%94%BB/animmontage%E7%B1%BB/",title:"AnimMontage类",description:"便签 # UE_5.1/Engine/Source/Runtime/Engine/Classes/Animation/AnimMontage.h 派生关系 # UAnimSequenceBase ^ UAnimCompositeBase ^ UAnimMontage ",content:"便签 # UE_5.1/Engine/Source/Runtime/Engine/Classes/Animation/AnimMontage.h 派生关系 # UAnimSequenceBase ^ UAnimCompositeBase ^ UAnimMontage "}),e.add({id:68,href:"/docs/%E5%88%86%E4%BA%AB/macos%E5%BA%94%E7%94%A8/%E8%B0%83%E5%BA%A6%E4%B8%AD%E5%BF%83/",title:"调度中心",description:"键盘操作 # 可以在 系统偏好设置 \u0026gt; 键盘 \u0026gt; 快捷键 \u0026gt; 调度中心 中设置快捷键 - Control-Up 进入调度中心：查看当前桌面内应用程序和桌面选项 按Control-Up / Control-Down返回 Control-Down 列出当前应用的所有窗口 同上 - Control-Left / Control-Right 左右切换桌面 Control-NUM 切换到指定桌面 触控板操作 # 可以在 系统偏好设置 \u0026gt; 触控板 \u0026gt; 更多手势 中进行设置 - 三指 向上轻扫 进入调度中心 三指 向下轻扫 列出当前应用的所有窗口 三指 左右轻扫 左右切换桌面 ",content:"键盘操作 # 可以在 系统偏好设置 \u0026gt; 键盘 \u0026gt; 快捷键 \u0026gt; 调度中心 中设置快捷键 - Control-Up 进入调度中心：查看当前桌面内应用程序和桌面选项 按Control-Up / Control-Down返回 Control-Down 列出当前应用的所有窗口 同上 - Control-Left / Control-Right 左右切换桌面 Control-NUM 切换到指定桌面 触控板操作 # 可以在 系统偏好设置 \u0026gt; 触控板 \u0026gt; 更多手势 中进行设置 - 三指 向上轻扫 进入调度中心 三指 向下轻扫 列出当前应用的所有窗口 三指 左右轻扫 左右切换桌面 "}),e.add({id:69,href:"/docs/brick/windows%E4%B8%8A%E4%BD%BF%E7%94%A8sublime%E8%BF%9B%E8%A1%8Cunreal%E5%BC%80%E5%8F%91/",title:"Windows上使用Sublime进行Unreal开发",description:"便签 # Unreal Engine C++ Project Setup, From Scratch 说明 # - Cmder 终端模拟器 Sublime 虚幻引擎5.1版本说明: 依赖.NET 6.0 概览 # 从零创建Unreal项目 在命令行编译和运行项目, 封装在脚本中 创建Actor派生类 查看引擎代码 Cmder # 显示/隐藏窗口: C-` 在文件资源管理器打开Cmder当前路径 cd /d C:\\Dirk explorer . Sublime # 使用以下插件 - Project Manager Switch File Deluxe 在源文件和头文件之间切换; Windows Alt-O ; macOS Option-Command-UP Unreal Snippets UP主提供 从零创建Unreal项目 # 创建项目文件夹Dirk 创建项目 # Sublime \u0026gt; 命令行 \u0026gt; Project Manager: Add New Project 命名为Dirk 添加文件夹 # Sublime \u0026gt; 命令行 \u0026gt; Project: Add Folder 选择Dirk 创建Unreal项目文件 # Dirk/Dirk.",content:"便签 # Unreal Engine C++ Project Setup, From Scratch 说明 # - Cmder 终端模拟器 Sublime 虚幻引擎5.1版本说明: 依赖.NET 6.0 概览 # 从零创建Unreal项目 在命令行编译和运行项目, 封装在脚本中 创建Actor派生类 查看引擎代码 Cmder # 显示/隐藏窗口: C-` 在文件资源管理器打开Cmder当前路径 cd /d C:\\Dirk explorer . Sublime # 使用以下插件 - Project Manager Switch File Deluxe 在源文件和头文件之间切换; Windows Alt-O ; macOS Option-Command-UP Unreal Snippets UP主提供 从零创建Unreal项目 # 创建项目文件夹Dirk 创建项目 # Sublime \u0026gt; 命令行 \u0026gt; Project Manager: Add New Project 命名为Dirk 添加文件夹 # Sublime \u0026gt; 命令行 \u0026gt; Project: Add Folder 选择Dirk 创建Unreal项目文件 # Dirk/Dirk.uproject 包含项目对应的引擎版本, 以及打开该项目所需的动态库 插入代码段: uuproj \u0026gt; TAB 修改 Modules \u0026gt; Name { \u0026quot;FileVersion\u0026quot;: 3, \u0026quot;EngineAssociation\u0026quot;: \u0026quot;4.25\u0026quot;, \u0026quot;Category\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;Description\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;Modules\u0026quot;: [ { \u0026quot;Name\u0026quot;: \u0026quot;DirkCore\u0026quot;, \u0026quot;Type\u0026quot;: \u0026quot;Runtime\u0026quot;, \u0026quot;LoadingPhase\u0026quot;: \u0026quot;Default\u0026quot; } ] } 创建Target文件 # 指示如何编译Target Target Rules Definition 有两个Target, 游戏实例和虚幻编辑器 游戏实例 # Dirk/Source/Dirk.Target.cs 插入代码段: umt \u0026gt; TAB 给出需要构造的模块 using UnrealBuildTool; public class DirkTarget : TargetRules { public DirkTarget(TargetInfo Target) : base(Target) { Type = TargetType.Game; DefaultBuildSettings = BuildSettingsVersion.V2; ExtraModuleNames.AddRange( new string[] { \u0026quot;DirkCore\u0026quot; } ); } } 虚幻编辑器 # Dirk/Source/DirkEditor.Target.cs 插入代码段: umt \u0026gt; TAB 填写Target类型为Editor 给出需要构造的模块 using UnrealBuildTool; public class DirkEditorTarget : TargetRules { public DirkEditorTarget(TargetInfo Target) : base(Target) { Type = TargetType.Editor; DefaultBuildSettings = BuildSettingsVersion.V2; ExtraModuleNames.AddRange( new string[] { \u0026quot;DirkCore\u0026quot; } ); } } 创建游戏主模块DirkCore # Primary Game Module 一个项目只有一个游戏主模块; 创建文件夹Dirk/Source/DirkCore 创建源码文件夹 # - Dirk/Source/DirkCore/Public 存放对其他模块可见的头文件 Dirk/Source/DirkCore/Private 存放实现 Implementataion 和模块内部逻辑 模块编译规则 # Module Build Rules Dirk/Source/DirkCore/DirkCore.Build.cs 插入代码段: umb \u0026gt; TAB 填写依赖模块: 已填写最少依赖 - Core CoreUObject Engine using UnrealBuildTool; public class DirkCore : ModuleRules { public DirkCore(ReadOnlyTargetRules Target) : base(Target) { PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; bEnforceIWYU = true; PublicDependencyModuleNames.AddRange(new string[] { \u0026quot;Core\u0026quot;, \u0026quot;CoreUObject\u0026quot;, \u0026quot;Engine\u0026quot; }); PrivateDependencyModuleNames.AddRange(new string[] { }); } } 虚幻引擎由各个模块组成\n查看 Epic Games\\UE_5.1\\Engine\\Source ，组织方式为模块类型 Runtime模块：引擎代码，不包含虚幻编辑器和开发工具; 包含各种运行时模块, 如Core、CoreUObject和Engine 如果想要开发VR游戏, 则需添加依赖模块HeadMountedDisplay 模块实现 # 模块定义和模块同名 DirkCore.h\nDirk/Source/DirkCore/Public/DirkCore.h 插入代码段: umh \u0026gt; TAB 定义了模块入口 加载模块之后, 调用StartupModule; 卸载模块之前, 调用ShutdownModule #pragma once #include \u0026quot;CoreMinimal.h\u0026quot; #include \u0026quot;Modules/ModuleInterface.h\u0026quot; class FDirkCore : public IModuleInterface { public: static inline FDirkCore\u0026amp; Get() { return FModuleManager::LoadModuleChecked\u0026lt;FDirkCore\u0026gt;(\u0026quot;DirkCore\u0026quot;); } static inline bool IsAvailable() { return FModuleManager::Get().IsModuleLoaded(\u0026quot;DirkCore\u0026quot;); } virtual void StartupModule() override; virtual void ShutdownModule() override; }; DirkCore.cpp\nDirk/Source/DirkCore/Private/DirkCore.cpp 插入代码段: umcp \u0026gt; TAB #include \u0026quot;DirkCore.h\u0026quot; #include \u0026quot;Modules/ModuleManager.h\u0026quot; #include \u0026quot;Log.h\u0026quot; void FDirkCore::StartupModule() { UE_LOG(LogDirkCore, Log, TEXT(\u0026quot;DirkCore module starting up\u0026quot;)); } void FDirkCore::ShutdownModule() { UE_LOG(LogDirkCore, Log, TEXT(\u0026quot;DirkCore module shutting down\u0026quot;)); } IMPLEMENT_PRIMARY_GAME_MODULE(FDirkCore, DirkCore, \u0026quot;DirkCore\u0026quot;); 创建日志类别 # 只在DirkCore内部使用, 头文件和源文件均存放在Dirk/Source/DirkCore/Private中 Log.h 插入代码段: ulh \u0026gt; TAB #pragma once #include \u0026quot;Logging/LogMacros.h\u0026quot; DECLARE_LOG_CATEGORY_EXTERN(LogDirkCore, All, All); Log.cpp 插入代码段: ulc \u0026gt; TAB #include \u0026quot;Log.h\u0026quot; DEFINE_LOG_CATEGORY(LogDirkCore); 插入日志语句: ull \u0026gt; TAB 编译项目 # 虚幻引擎有自己的交叉编译系统 Cross-Platform , 我们通过C#文件配置Target和模块的编译规则 编译虚幻编辑器使用的动态库 # 脚本路径 Windows Epic Games\\UE_5.1\\Engine\\Build\\BatchFiles\\Build.bat macOS Epic Games\\UE_5.1\\Engine\\Build\\BatchFiles\\Mac\\Build.sh Build脚本包括UnrealBuildTool的调用, 和一些参数配置 运行Build脚本, 指定Target、Platform和Build Configuration, 给出uproject文件路径 最终, 模块被链接成动态库, 供虚幻编辑器加载 - Target DirkEditor 平台 Mac 编译配置 Development, 介于Debug和Shipping之间 Windows # \u0026quot;C:\\Epic Games\\UE_5.1\\Engine\\Build\\BatchFiles\\Build.bat\u0026quot; DirkEditor Win64 Development \u0026quot;C:\\Dirk\\Dirk.uproject\u0026quot; -waitmutex -NoHotReload macOS # #!/bin/bash Project=\u0026quot;Dirk/Dirk.uproject\u0026quot; BuildScript=\u0026quot;UE_5.1/Engine/Build/BatchFiles/Mac/Build.sh\u0026quot; Target=\u0026quot;DirkEditor\u0026quot; $BuildScript $Target Mac Development $Project -waitmutex -NoHotReload 虚幻头文件工具 # Unreal Header Tool 虚幻引擎源码里使用了很多宏，在编译之前，需要进行解析，在源码文件中进行替换 新增文件夹 # - Binaries Intermediate 生成文件 - Dirk/Binaries/Mac/UnrealEditor.modules 元数据 Meta Data , 说明该模块所需的动态库文件, 和引擎版本 打开虚幻编辑器, 会比对引擎版本和项目对应的引擎版本是否一致 Dirk/Binaries/Mac/DirkEditor.target 元数据 Windows - Dirk/Binaries/Win64/UnrealEditor-DirkCore.dll 模块动态库 Dirk/Binaries/Win64/UnrealEditor-DirkCore.pdb 存放调试信息 macOS - Dirk/Binaries/Mac/UnrealEditor-DirkCore.dylib 模块动态库 使用虚幻编辑器打开项目 # Windows # \u0026quot;C:\\Epic Games\\UE_5.1\\Engine\\Binaries\\Win64\\UnrealEditor.exe\u0026quot; \u0026quot;C:\\Dirk\\Dirk.uproject\u0026quot; -log macOS # #!/bin/bash Project=\u0026quot;Dirk/Dirk.uproject\u0026quot; UnrealEditor=\u0026quot;UE_5.1/Engine/Binaries/Mac/UnrealEditor.app\u0026quot; open -a $UnrealEditor $Project 新增文件夹 # - Saved 存放日志和运行时 Runtime 生成 DerivedDataCache 虚幻编辑器导入资产时的缓存 Content 存放各种资产 Config 项目配置 使用虚幻编辑器运行游戏实例, 不加载编辑器本身 # 使用-game选项 Windows # \u0026quot;C:\\Epic Games\\UE_5.1\\Engine\\Binaries\\Win64\\UnrealEditor.exe\u0026quot; \u0026quot;C:\\Dirk\\Dirk.uproject\u0026quot; -game -log -windowed -resx=1280 -rexy=720 macOS # #!/bin/bash Project=\u0026quot;Dirk/Dirk.uproject\u0026quot; UnrealEditor=\u0026quot;UE_5.1/Engine/Binaries/Mac/UnrealEditor.app/Contents/MacOS/UnrealEditor\u0026quot; $UnrealEditor $Project -game -log -windowed -resx=1280 -rexy=720 编译游戏实例 # 编译游戏实例 # 使用游戏实例Target, 得到项目的独立运行版本 Standalone Version 不再把模块链接成动态库, 将项目和引擎源码链接在一起, 生成一个可执行游戏, 不包含虚幻编辑器的特定功能 Windows\n\u0026quot;C:\\Epic Games\\UE_5.1\\Engine\\Build\\BatchFiles\\build.bat\u0026quot; Dirk Win64 Development \u0026quot;C:\\Dirk\\Dirk.uproject\u0026quot; -waitmutex -NoHotReload macOS\n#!/bin/bash Project=\u0026quot;Dirk/Dirk.uproject\u0026quot; BuildScript=\u0026quot;UE_5.1/Engine/Build/BatchFiles/Mac/Build.sh\u0026quot; Target=\u0026quot;Dirk\u0026quot; $BuildScript $Target Mac Development $Project -waitmutex -NoHotReload 烘培资产 # Windows Cook Content 虚幻编辑器使用未烘培资产, 而游戏实例直接将压缩纹理加载到GPU Saved/Cooked存放游戏实例运行时所需资产 macOS无UnrealEditor-cmd程序 \u0026quot;C:\\Epic Games\\UE_5.1\\Engine\\Binaries\\Win64\\UnrealEditor-cmd.exe\u0026quot; \u0026quot;C:\\Dirk\\Dirk.uproject\u0026quot; -run=cook -targetplatform=Windows 运行游戏实例 # Windows 构建时使用了Development参数, 运行时可以使用开发工具 \u0026quot;C:\\Dirk\\Binaries\\Win64\\Dirk.exe\u0026quot; -log -windowed -resx=1280 -resy=720 运行脚本 # Windows 和Dirk文件夹同级 变量 # vars.bat @echo off Rem 不打印命令 set ROOTDIR=%~dp0 Rem ~dp0为脚本所在目录 set ROOTDIR=%ROOTDIR:~0,-1% Rem ~0,-1% 去除目录最后的/ set PROJECT=Dirk set PROJECT_DIR=%ROOTDIR%\\%PROJECT% set UPROJECT_PATH=%PROJECT_DIR%\\%PROJECT%.uproject set UE5_DIR=C:\\Epic Games\\UE_5.1 set UE5EDITOR_EXE=%UE5_DIR%\\Engine\\Binaries\\Win64\\UnrealEditor.exe set BUILD_BAT=%UE5_DIR%\\Engine\\Build\\BatchFiles\\Build.bat 编译 # build.bat @echo off call %~dp0\\vars.bat call \u0026quot;%BUILD_BAT%\u0026quot; %PROJECT%Editor Win64 Development \u0026quot;%UPROJECT_PATH%\u0026quot; -waitmutex -NoHotReload 在虚幻编辑器中打开项目 # editor.bat @echo off call %~dp0\\vars.bat start \u0026quot;%UE5EDITOR_EXE%\u0026quot; \u0026quot;%UPROJECT_PATH%\u0026quot; %* 运行脚本 # 在虚幻编辑器中打开项目 editor editor -log 编译成功则在虚幻编辑器中打开 build \u0026amp;\u0026amp; editor 创建C++类 # TestActor.h # Dirk/Source/DirkCore/Public/TestActor.h 插入代码段\n定义Actor派生类: uca \u0026gt; TAB 添加组件: upc \u0026gt; TAB protected class UBillboardComponent; UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\u0026quot;Components\u0026quot;) class UBillboardComponent* BillboardComponentSprite;	添加蓝图可编辑属性: upe \u0026gt; TAB protected UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\u0026quot;Test\u0026quot;) int32 Value; 覆写BeginPlay public virtual void BeginPlay() override; 构造函数: ufc \u0026gt; TAB public ATestActor(const FObjectInitializer\u0026amp; ObjectInitializer); 完整代码\n#pragma once #include \u0026quot;CoreMinimal.h\u0026quot; #include \u0026quot;GameFramework/Actor.h\u0026quot; #include \u0026quot;TestActor.generated.h\u0026quot; class UBillboardComponent; UCLASS() class ATestActor : public AActor { GENERATED_BODY() public: ATestActor(const FObjectInitializer\u0026amp; ObjectInitializer); virtual void BeginPlay() override; protected: UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\u0026quot;Components\u0026quot;) class UBillboardComponent* Sprite;	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\u0026quot;Test\u0026quot;) int32 Value; }; TestActor.cpp # Dirk/Source/DirkCore/Private/TestActor.cpp #include \u0026quot;TestActor.h\u0026quot; #include \u0026quot;Components/SceneComponent.h\u0026quot; #include \u0026quot;Components/BillboardComponent.h\u0026quot; #include \u0026quot;Log.h\u0026quot; ATestActor::ATestActor(const FObjectInitializer\u0026amp; ObjectInitializer) : Super(ObjectInitializer) { Value = 42; RootComponent = ObjectInitializer.CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(this, TEXT(\u0026quot;RootComponent\u0026quot;)); Sprite = ObjectInitializer.CreateDefaultSubobject\u0026lt;UBillboardComponent\u0026gt;(this, TEXT(\u0026quot;Sprite\u0026quot;)); Sprite-\u0026gt;SetupAttachment(RootComponent); } void ATestActor::BeginPlay() { Super::BeginPlay(); UE_LOG(LogDirkCore, Log, TEXT(\u0026quot;%s: on BeginPlay, Value is %d\u0026quot;), *GetName(), Value); } 查看引擎代码 # 添加引擎源码文件夹 命令行 \u0026gt; Project: Add Folder \u0026gt; Epic Games\\UE_5.1\\Engine\\Source\\Runtime 项目内查找: 查找派生类 Find : public FPrimitiveSceneProxy Where C:\\Epic Games\\UE_5.1\\Engine\\Plugins,*.h,*.cpp,*.inl 文件内查找 支持正则匹配 去到文件Actor.h Set.*Tranform 总结 # Visual Studio # MSVC++提供cl.exe和link.exe, 作为编译器 Compiler 和链接器 Linker Unreal Engine # 提供UnrealBuildTool.exe, UnrealHeaderTool.exe和UnrealEditor.exe 虚幻引擎项目 # 项目文件: Dirk.uproject 蓝图项目: 没有模块项 { \u0026quot;FileVersion\u0026quot;: 3, \u0026quot;EngineAssociation\u0026quot;: \u0026quot;5.1\u0026quot;, \u0026quot;Category\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;Description\u0026quot;: \u0026quot;\u0026quot; } C++项目: 虚幻编辑器需加载指定模块 { \u0026quot;FileVersion\u0026quot;: 3, \u0026quot;EngineAssociation\u0026quot;: \u0026quot;5.1\u0026quot;, \u0026quot;Category\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;Description\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;Modules\u0026quot;: [ { \u0026quot;Name\u0026quot;: \u0026quot;DirkCore\u0026quot;, \u0026quot;Type\u0026quot;: \u0026quot;Runtime\u0026quot;, \u0026quot;LoadingPhase\u0026quot;: \u0026quot;Default\u0026quot; } ] } 项目编译 # 模块定义在Dirk/Source, 每个模块的构造规则在Build.cs文件中说明 每个项目有两个Target.cs文件, 说明其依赖的模块 UnrealBuildTool根据Target构造规则编译依赖模块, 模块编译则依据模块编译规则 模块编译 # 解析头文件得到生成代码，保存在Intermediate文件夹 Unreal Header Tool DirkCore.init.gen.cpp TestActor.gen.cpp TestActor.generated.h 编译解析完的单元, 生成目标文件 Unreal Build Tool DirkCore.cpp.obj DirkCore.init.gen.cpp.obj TestActor.cpp.obj TestActor.gen.cpp.obj 将代码链接到一起，根据编译规则 Build Rules 提供的依赖名单解决模块见交叉引用 Unreal Build Tool 最后, 得到编辑器所需的动态库 UEEditor-DirkCore.dll UEEditor-DirCore.pdb 给出uproject文件，可以在编辑器中编辑或运行未烘培资产的项目 也可以使用编辑器为项目烘培资产, 之后, 可以运行独立游戏 "}),e.add({id:70,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/exec-path-from-shell/",title:"exec-path-from-shell",description:"为在Emacs中执行Shell命令提供支持 说明 # Shell可执行的命令，因为环境变量的缺失，在Emacs中无法正确执行；除非从终端运行Emacs，继承Shell环境变量 作者Purcell是Emacs博主, 很多人参考他的Emacs配置 exec-path-from-shell-安装 # (use-package exec-path-from-shell :ensure t :init (when (memq window-system '(mac ns x)) (exec-path-from-shell-initialize)) ) ",content:"为在Emacs中执行Shell命令提供支持 说明 # Shell可执行的命令，因为环境变量的缺失，在Emacs中无法正确执行；除非从终端运行Emacs，继承Shell环境变量 作者Purcell是Emacs博主, 很多人参考他的Emacs配置 exec-path-from-shell-安装 # (use-package exec-path-from-shell :ensure t :init (when (memq window-system '(mac ns x)) (exec-path-from-shell-initialize)) ) "}),e.add({id:71,href:"/docs/build-blog/%E5%9B%BE%E7%89%87%E6%B0%B4%E5%B9%B3%E5%BE%AA%E7%8E%AF%E6%BB%9A%E5%8A%A8/",title:"图片水平循环滚动",description:"便签 # - 环状滚动 1. html格式 2. css样式 3. transform: translateX 多个li显示在一行 display: inline-block 基础html格式+css样式 通过js设置css参数 1. element.style.setProperty(\u0026rsquo;transform\u0026rsquo;, \u0026rsquo;translateX(1px)') 2. element.style.getPropertyValue(\u0026rsquo;transform') 3. element.style.cssText = \u0026rsquo;left: 10px' 4. 猜测：通过js获取的css参数, 不来自css文件, 而是html代码的设置 css Position 1. li标签不自动换行: absolute, fixed 2. 计算绝对位置 样式 # css - imageList height 滚动框高度, 滚动框之间的边界 overflow 向右滚动时, 溢出不触发滚动条 perspective 1. 滚动框左右的边界 2. 垂直滚动时, 滚动框跟随滚动 li width 图片宽度 padding 第一个参数: top边界, 滚动框之间的间隔 第二个参数: 嵌套时长宽边界 position 1. 多个li不自动换行 2. 采用绝对位置 3. fixed或absolute都可 display li显示在一行 .",content:`便签 # - 环状滚动 1. html格式 2. css样式 3. transform: translateX 多个li显示在一行 display: inline-block 基础html格式+css样式 通过js设置css参数 1. element.style.setProperty(\u0026rsquo;transform\u0026rsquo;, \u0026rsquo;translateX(1px)') 2. element.style.getPropertyValue(\u0026rsquo;transform') 3. element.style.cssText = \u0026rsquo;left: 10px' 4. 猜测：通过js获取的css参数, 不来自css文件, 而是html代码的设置 css Position 1. li标签不自动换行: absolute, fixed 2. 计算绝对位置 样式 # css - imageList height 滚动框高度, 滚动框之间的边界 overflow 向右滚动时, 溢出不触发滚动条 perspective 1. 滚动框左右的边界 2. 垂直滚动时, 滚动框跟随滚动 li width 图片宽度 padding 第一个参数: top边界, 滚动框之间的间隔 第二个参数: 嵌套时长宽边界 position 1. 多个li不自动换行 2. 采用绝对位置 3. fixed或absolute都可 display li显示在一行 .imageList { height: 158px; overflow: hidden; perspective: 2000px; ul li { width: 200px; padding: 2px 2px; position: fixed; display: inline-block; // 去除小黑点 // overflow: hidden; // 四个角圆润 // border-radius: 5px; } } 图片存放在无序列表, 使用id标识 # html scrollpic1向右滚动, scrollpic2向左滚动 \u0026lt;div class=\u0026quot;imageList\u0026quot; id=\u0026quot;scrollpic1\u0026quot;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;1.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;2.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;3.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;4.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;5.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;6.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;1.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;2.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;3.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;4.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;5.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;6.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;imageList\u0026quot; id=\u0026quot;scrollpic2\u0026quot;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;7.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;8.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;9.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;10.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;11.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;12.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;7.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;8.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;9.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;10.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;11.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;12.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 图片水平循环滚动 # 进入判断 # document.addEventListener('DOMContentLoaded', () =\u0026gt; { const pics1 = document.querySelectorAll('#scrollpic1 li'); const pics2 = document.querySelectorAll('#scrollpic2 li'); if (!pics1.length || !pics2.length) return; // 后续处理 }); 图片组规格 # 单张图片宽度200px(ul li width) 考虑到图片间隔: const PicWidth = 205; 一组12张图, 实际滚动框宽度: 205px * 12 = 2460px 考虑到左右溢出和窗口宽度, 图片水平位移范围: const FrontEnd = 2000; // \u0026gt; window.innerWidth const BackEnd = -460; 步长 # const Step = 0.2; 游标 # 范围 向右滚动 0 ~ (FrontEnd - BackEnd) 向左滚动 (BackEnd - FrontEnd) ~ 0 定义游标 # 全局变量 let Cur1 = 0; let Cur2 = 0; 开启循环定时器, 更新游标 # const ScrollTimerInterval = 5; const scrollTimer = window.setInterval(function () { Cur1 = (Cur1 + Step) % (FrontEnd - BackEnd); // 向右滚动 Cur2 = (Cur2 - Step) % (FrontEnd - BackEnd); // 向左滚动 }, ScrollTimerInterval); 实现函数: 根据游标实时位置, 平移图片组成员 # translatePic 参数 # - pics 图片组 cur 游标 遍历图片组 # function translatePic(pics, cur) { for (let i = 0; i \u0026lt; pics.length; ++i) { // 处理成员 } } 根据成员的相对位置计算平移 # - 向右滚动 cur 0 ~ (FrontEnd - BackEnd) 成员偏移 0 ~ (FrontEnd - BackEnd) thisCur 0 ~ 2 * (FrontEnd - BackEnd) 向左滚动 cur (BackEnd - FrontEnd) ~ 0 成员偏移 0 ~ (FrontEnd - BackEnd) thisCur (BackEnd - FrontEnd) ~ (FrontEnd - BackEnd) 控制成员平移范围
thisCur范围应该为BackEnd ~ FrontEnd let thisCur = cur + i * PicWidth; if (thisCur \u0026gt; FrontEnd) thisCur -= FrontEnd - BackEnd; else if (thisCur \u0026lt; BackEnd) thisCur += FrontEnd - BackEnd; 平移成员
const value = 'translateX(' + thisCur + 'px)'; pics[i].style.setProperty('transform', value); 完整代码 # const PicWidth = 205; const FrontEnd = 2000; const BackEnd = -460; const Step = 0.2; const ScrollTimerInterval = 5; function translatePic(pics, cur) { for (let i = 0; i \u0026lt; pics.length; ++i) { let thisCur = cur + i * PicWidth; if (thisCur \u0026gt; FrontEnd) thisCur -= FrontEnd - BackEnd; else if (thisCur \u0026lt; BackEnd) thisCur += FrontEnd - BackEnd; const value = 'translateX(' + thisCur + 'px)'; pics[i].style.setProperty('transform', value); } } let Cur1 = 0; let Cur2 = 0; document.addEventListener('DOMContentLoaded', () =\u0026gt; { const pics1 = document.querySelectorAll('#scrollpic1 li'); const pics2 = document.querySelectorAll('#scrollpic2 li'); if (!pics1.length || !pics2.length) return; const scrollTimer = window.setInterval(function () { Cur1 = (Cur1 + Step) % (FrontEnd - BackEnd); // 0 ~ (FrontEnd - BackEnd) Cur2 = (Cur2 - Step) % (FrontEnd - BackEnd); // (BackEnd - FrontEnd) ~ 0 translatePic(pics1, Cur1); translatePic(pics2, Cur2); }, ScrollTimerInterval); }); `}),e.add({id:72,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E8%B7%B3%E8%BD%AC/",title:"虚幻引擎项目源码跳转",description:"项目源码路径样式 # 无! ![[uep:Public/Weapon/STUBaseWeapon.h][ShootThemUp:Weapon/STUBaseWeapon.h]] 需设置项目文件夹 # ;; (setq my/ue-project-path \u0026quot;path/to/ue/project\u0026quot;) 插入项目源码链接 # (defun my/insert-ue-project-source-path () (interactive) (let ((proj (read-string \u0026quot;Project: (Default - ShootThemUp)\u0026quot;)) (type (read-string \u0026quot;Category: \u0026quot;)) (file (read-string \u0026quot;File: \u0026quot;)) (path) (attr)) (if (string= \u0026quot;\u0026quot; proj) (setq proj \u0026quot;ShootThemUp\u0026quot;)) (when (string= \u0026quot;\u0026quot; type) (insert (format (concat \u0026quot;[[\u0026quot; \u0026quot;uep:%s][%s:%s]]\u0026quot;) file proj file))) (unless (string= type \u0026quot;\u0026quot;) (if (string-suffix-p \u0026quot;.h\u0026quot; file) (setq attr \u0026quot;Public\u0026quot;) (setq attr \u0026quot;Private\u0026quot;)) (setq path (format \u0026quot;%s/%s/%s\u0026quot; attr type file)) (insert (format (concat \u0026quot;[[\u0026quot; \u0026quot;uep:%s][%s:%s/%s]]\u0026quot;) path proj type file))))) (global-set-key (kbd \u0026quot;C-c u p\u0026quot;) 'my/insert-ue-project-source-path) 打开源码文件 # (defun my/go-to-ue-project-source () (interactive) (when (search-backward (concat \u0026quot;[[\u0026quot; \u0026quot;uep:\u0026quot;) nil t) (when (re-search-forward (rx \u0026quot;[[\u0026quot; \u0026quot;uep:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;:\u0026quot;))) \u0026quot;:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1)))) (proj (string-join (mapcar #'string (match-string 2))))) (org-open-file (format \u0026quot;%s/%s/Source/%s/%s\u0026quot; my/ue-project-path proj proj file)))))) (global-set-key (kbd \u0026quot;C-c u l\u0026quot;) 'my/go-to-ue-project-source) ",content:"项目源码路径样式 # 无! ![[uep:Public/Weapon/STUBaseWeapon.h][ShootThemUp:Weapon/STUBaseWeapon.h]] 需设置项目文件夹 # ;; (setq my/ue-project-path \u0026quot;path/to/ue/project\u0026quot;) 插入项目源码链接 # (defun my/insert-ue-project-source-path () (interactive) (let ((proj (read-string \u0026quot;Project: (Default - ShootThemUp)\u0026quot;)) (type (read-string \u0026quot;Category: \u0026quot;)) (file (read-string \u0026quot;File: \u0026quot;)) (path) (attr)) (if (string= \u0026quot;\u0026quot; proj) (setq proj \u0026quot;ShootThemUp\u0026quot;)) (when (string= \u0026quot;\u0026quot; type) (insert (format (concat \u0026quot;[[\u0026quot; \u0026quot;uep:%s][%s:%s]]\u0026quot;) file proj file))) (unless (string= type \u0026quot;\u0026quot;) (if (string-suffix-p \u0026quot;.h\u0026quot; file) (setq attr \u0026quot;Public\u0026quot;) (setq attr \u0026quot;Private\u0026quot;)) (setq path (format \u0026quot;%s/%s/%s\u0026quot; attr type file)) (insert (format (concat \u0026quot;[[\u0026quot; \u0026quot;uep:%s][%s:%s/%s]]\u0026quot;) path proj type file))))) (global-set-key (kbd \u0026quot;C-c u p\u0026quot;) 'my/insert-ue-project-source-path) 打开源码文件 # (defun my/go-to-ue-project-source () (interactive) (when (search-backward (concat \u0026quot;[[\u0026quot; \u0026quot;uep:\u0026quot;) nil t) (when (re-search-forward (rx \u0026quot;[[\u0026quot; \u0026quot;uep:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;:\u0026quot;))) \u0026quot;:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1)))) (proj (string-join (mapcar #'string (match-string 2))))) (org-open-file (format \u0026quot;%s/%s/Source/%s/%s\u0026quot; my/ue-project-path proj proj file)))))) (global-set-key (kbd \u0026quot;C-c u l\u0026quot;) 'my/go-to-ue-project-source) "}),e.add({id:73,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/markdown/",title:"Markdown",description:"便签 # - 表格 runoob 代码框 # ```elisp ``` 插入图片 # ![img](/pic/在本地运行ShooterGame示例项目/运行效果.png) 插入连接 # [参考](https://learn.microsoft.com/zh-cn/cpp/cpp/conditional-operator-q?view=msvc-170) 下划线 # \u0026lt;u\u0026gt;Content\u0026lt;/u\u0026gt; 文本块 # `text` 换行 # \u0026lt;br\u0026gt; 分隔线 # --- 注释 # \u0026lt;!--哈哈我是注释，不会在浏览器中显示。--\u0026gt; Todo List # - [ ] - [x] 表格 # | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | ",content:"便签 # - 表格 runoob 代码框 # ```elisp ``` 插入图片 # ![img](/pic/在本地运行ShooterGame示例项目/运行效果.png) 插入连接 # [参考](https://learn.microsoft.com/zh-cn/cpp/cpp/conditional-operator-q?view=msvc-170) 下划线 # \u0026lt;u\u0026gt;Content\u0026lt;/u\u0026gt; 文本块 # `text` 换行 # \u0026lt;br\u0026gt; 分隔线 # --- 注释 # \u0026lt;!--哈哈我是注释，不会在浏览器中显示。--\u0026gt; Todo List # - [ ] - [x] 表格 # | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | "}),e.add({id:74,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/sublime/",title:"Sublime",description:"便签 # Sublime配色方案 打开命令行 # - Windows Control-Shift-P macOS Command-Shift-P 插件管理 # 安装Package Controll # 打开命令行 选择Install Package Controll 无法使用Package Controll # macOS 环境: Monterey 参考 解决方法 ln -sf /usr/local/Cellar/openssl@1.1/1.1.1u/lib/libcrypto.dylib /usr/local/lib/ 安装插件 # 打开命令行 输入Package Controll: Install Package 输入插件名 - Project Manager 创建项目 Switch File Deluxe 头文件和源文件之间切换 查看已安装插件 # 打开命令行 输入Package Controll: List Packages 删除插件 # 打开命令行 输入Package Controll: Remove Package 设置UI主题 # 打开命令行 选择UI: Select Theme 选择主题 设置配色方案 # 打开命令行 选择UI: Select Color Scheme 选择配色方案 分屏 # 复原: Option-Command-1 左右分屏和上下分屏不能同时进行 田字型 Grid : Option-Command-5 左右分屏 # 方法一: View \u0026gt; Layout, 默认Single，选择Columns: 2 方法二: Option-Command-N；2-4 上下分屏 # Option-Command-Shift-N；2-3 行号跳转 # Control-G 语法高亮 # 打开命令行 选择SetSyntax: + 指定语言 项目管理 # 关闭所有文件 # 命令行 \u0026gt; File: Close All 打开项目 # 命令行 \u0026gt; Project Manager: Open Project 添加文件夹 # 命令行 \u0026gt; Project: Add Folder 查看定义 # F12 打开项目内文件 # Command-P \u0026gt; 文件名 文件内查找 # Command-F 项目内查找 # Command-Shift-F 头文件和源文件之间切换 # Switch File Deluxe - Windows Alt-O macOS Option-Command-UP ",content:"便签 # Sublime配色方案 打开命令行 # - Windows Control-Shift-P macOS Command-Shift-P 插件管理 # 安装Package Controll # 打开命令行 选择Install Package Controll 无法使用Package Controll # macOS 环境: Monterey 参考 解决方法 ln -sf /usr/local/Cellar/openssl@1.1/1.1.1u/lib/libcrypto.dylib /usr/local/lib/ 安装插件 # 打开命令行 输入Package Controll: Install Package 输入插件名 - Project Manager 创建项目 Switch File Deluxe 头文件和源文件之间切换 查看已安装插件 # 打开命令行 输入Package Controll: List Packages 删除插件 # 打开命令行 输入Package Controll: Remove Package 设置UI主题 # 打开命令行 选择UI: Select Theme 选择主题 设置配色方案 # 打开命令行 选择UI: Select Color Scheme 选择配色方案 分屏 # 复原: Option-Command-1 左右分屏和上下分屏不能同时进行 田字型 Grid : Option-Command-5 左右分屏 # 方法一: View \u0026gt; Layout, 默认Single，选择Columns: 2 方法二: Option-Command-N；2-4 上下分屏 # Option-Command-Shift-N；2-3 行号跳转 # Control-G 语法高亮 # 打开命令行 选择SetSyntax: + 指定语言 项目管理 # 关闭所有文件 # 命令行 \u0026gt; File: Close All 打开项目 # 命令行 \u0026gt; Project Manager: Open Project 添加文件夹 # 命令行 \u0026gt; Project: Add Folder 查看定义 # F12 打开项目内文件 # Command-P \u0026gt; 文件名 文件内查找 # Command-F 项目内查找 # Command-Shift-F 头文件和源文件之间切换 # Switch File Deluxe - Windows Alt-O macOS Option-Command-UP "}),e.add({id:75,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E7%BB%84%E4%BB%B6/%E6%A3%8B%E5%AD%90%E8%BF%90%E5%8A%A8%E7%BB%84%E4%BB%B6/",title:"棋子运动组件",description:"Pawn Movement UPawnMovementComponent # UPawnMovementComponent::GetPawnOwner # 获取组件上级 // Return the Pawn that owns UpdatedComponent UFUNCTION(BlueprintCallable, Category=\u0026quot;Pawn|Components|PawnMovement\u0026quot;) class APawn* GetPawnOwner() const; ",content:"Pawn Movement UPawnMovementComponent # UPawnMovementComponent::GetPawnOwner # 获取组件上级 // Return the Pawn that owns UpdatedComponent UFUNCTION(BlueprintCallable, Category=\u0026quot;Pawn|Components|PawnMovement\u0026quot;) class APawn* GetPawnOwner() const; "}),e.add({id:76,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E7%BB%84%E4%BB%B6/%E5%9B%BE%E5%85%83%E7%BB%84%E4%BB%B6/",title:"图元组件",description:"PrimitiveComponent UPrimitiveComponent # UPrimitiveComponent::SetOwnerNoSee # Owner无法看见本组件的渲染，可以看见别家的 ",content:"PrimitiveComponent UPrimitiveComponent # UPrimitiveComponent::SetOwnerNoSee # Owner无法看见本组件的渲染，可以看见别家的 "}),e.add({id:77,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E6%8E%A7%E5%88%B6%E5%99%A8/aicontroller%E7%B1%BB/",title:"AIController类",description:"NPC的控制器 AAIController # AAIController::SetPerceptionComponent # 设置感知组件, 传参 引用 void SetPerceptionComponent(UAIPerceptionComponent\u0026amp; InPerceptionComponent); AAIController::RunBehaviorTree # 运行行为树 // Starts executing behavior tree UFUNCTION(BlueprintCallable, Category = \u0026quot;AI\u0026quot;) virtual bool RunBehaviorTree(UBehaviorTree* BTAsset); 访问当前Pawn # AController::GetPawn 运行行为树 # 在下列函数中实现 AController::OnPossess ",content:"NPC的控制器 AAIController # AAIController::SetPerceptionComponent # 设置感知组件, 传参 引用 void SetPerceptionComponent(UAIPerceptionComponent\u0026amp; InPerceptionComponent); AAIController::RunBehaviorTree # 运行行为树 // Starts executing behavior tree UFUNCTION(BlueprintCallable, Category = \u0026quot;AI\u0026quot;) virtual bool RunBehaviorTree(UBehaviorTree* BTAsset); 访问当前Pawn # AController::GetPawn 运行行为树 # 在下列函数中实现 AController::OnPossess "}),e.add({id:78,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2/pawn%E7%B1%BB/",title:"Pawn类",description:"玩家所操作的角色，提供键位绑定 由PlayerController控制，可在多个Pawn之间进行切换 APawn # 构成 # APawn::SetupPlayerInputComponent # 配置用户输入: 在该函数内绑定键位 APawn::StaticClass # 静态成员 返回指向UClass的指针 在GENERATED_BODY宏中定义 UObject也有StaticClass，UObjectBaseUtility没有 控制器 # 访问Controller对象 # APawn::GetController # 获取指向AController的指针 可以是PlayerController，也可以是AIController, 自行转换 APawn::Controller # public 使用指向AController的指针 APawn::GetController\u0026lt;T\u0026gt; # 获取指定类型控制器 // Returns controller for this actor cast to the template type. May return NULL is the cast fails template \u0026lt; class T \u0026gt; T* GetController() const { return Cast\u0026lt;T\u0026gt;(GetController()); } 控制状态 # APawn::IsControlled # 是否被PlayerController接管 APawn::IsPawnControlled # 是否被Controller接管: AIController或PlayerController 受控于AI控制器 # APawn::AIControllerClass # 设置AIController类型 // Default class to use when pawn is controlled by AI UPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(DisplayName=\u0026quot;AI Controller Class\u0026quot;), Category=Pawn) TSubclassOf\u0026lt;AController\u0026gt; AIControllerClass; APawn::AutoPossessAI # 设置Pawn被创建和被AI控制器接管的条件 // * // * Determines when the Pawn creates and is possessed by an AI Controller (on level start, when spawned, etc).",content:"玩家所操作的角色，提供键位绑定 由PlayerController控制，可在多个Pawn之间进行切换 APawn # 构成 # APawn::SetupPlayerInputComponent # 配置用户输入: 在该函数内绑定键位 APawn::StaticClass # 静态成员 返回指向UClass的指针 在GENERATED_BODY宏中定义 UObject也有StaticClass，UObjectBaseUtility没有 控制器 # 访问Controller对象 # APawn::GetController # 获取指向AController的指针 可以是PlayerController，也可以是AIController, 自行转换 APawn::Controller # public 使用指向AController的指针 APawn::GetController\u0026lt;T\u0026gt; # 获取指定类型控制器 // Returns controller for this actor cast to the template type. May return NULL is the cast fails template \u0026lt; class T \u0026gt; T* GetController() const { return Cast\u0026lt;T\u0026gt;(GetController()); } 控制状态 # APawn::IsControlled # 是否被PlayerController接管 APawn::IsPawnControlled # 是否被Controller接管: AIController或PlayerController 受控于AI控制器 # APawn::AIControllerClass # 设置AIController类型 // Default class to use when pawn is controlled by AI UPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(DisplayName=\u0026quot;AI Controller Class\u0026quot;), Category=Pawn) TSubclassOf\u0026lt;AController\u0026gt; AIControllerClass; APawn::AutoPossessAI # 设置Pawn被创建和被AI控制器接管的条件 // * // * Determines when the Pawn creates and is possessed by an AI Controller (on level start, when spawned, etc). // * Only possible if AIControllerClassRef is set, and ignored if AutoPossessPlayer is enabled. // * @see AutoPossessPlayer // * UPROPERTY(EditAnywhere, Category=Pawn) EAutoPossessAI AutoPossessAI; "}),e.add({id:79,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/npc%E8%A1%8C%E4%B8%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%E6%A0%91%E4%BB%BB%E5%8A%A1/",title:"自定义行为树任务",description:"生成随机点, 并设置到黑板变量 说明 # 派生自C++类BTTaskNode 依赖模块 GameplayTasks 和 NavigationSystem 在构造函数中设置任务名 # STUNextLocationTask USTUNextLocationTask::USTUNextLocationTask() { NodeName = \u0026quot;Next Location\u0026quot;; } 任务逻辑 # 原型 # virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent\u0026amp; OwnerComp, uint8* NodeMemory); 返回值 # 成功 return EBTNodeResult::Succeeded; 失败 return EBTNodeResult::Failed; 生成随机点 # #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;NavigationSystem.h\u0026quot; const auto Controller = OwnerComp.GetAIOwner(); if (!Controller) return EBTNodeResult::Failed; const auto Pawn = Controller-\u0026gt;GetPawn(); if (!Pawn) return EBTNodeResult::Failed; const auto NavSys = UNavigationSystemV1::GetCurrent(Pawn); if (!NavSys) return EBTNodeResult::Failed; FNavLocation NavLocation; const auto Found = NavSys-\u0026gt;GetRandomReachablePointInRadius(Pawn-\u0026gt;GetActorLocation(), 1000, NavLocation); if (!",content:"生成随机点, 并设置到黑板变量 说明 # 派生自C++类BTTaskNode 依赖模块 GameplayTasks 和 NavigationSystem 在构造函数中设置任务名 # STUNextLocationTask USTUNextLocationTask::USTUNextLocationTask() { NodeName = \u0026quot;Next Location\u0026quot;; } 任务逻辑 # 原型 # virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent\u0026amp; OwnerComp, uint8* NodeMemory); 返回值 # 成功 return EBTNodeResult::Succeeded; 失败 return EBTNodeResult::Failed; 生成随机点 # #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;NavigationSystem.h\u0026quot; const auto Controller = OwnerComp.GetAIOwner(); if (!Controller) return EBTNodeResult::Failed; const auto Pawn = Controller-\u0026gt;GetPawn(); if (!Pawn) return EBTNodeResult::Failed; const auto NavSys = UNavigationSystemV1::GetCurrent(Pawn); if (!NavSys) return EBTNodeResult::Failed; FNavLocation NavLocation; const auto Found = NavSys-\u0026gt;GetRandomReachablePointInRadius(Pawn-\u0026gt;GetActorLocation(), 1000, NavLocation); if (!Found) return EBTNodeResult::Failed; 设置黑板变量 # 添加属性: 存放黑板变量信息 UPROPERTY(EditAnywhere, BlueprintReadWrite) FBlackboardKeySelector AimLocationKey; 设置黑板变量 #include \u0026quot;BehaviorTree/BlackboardComponent.h\u0026quot; const auto Blackboard = OwnerComp.GetBlackboardComponent(); if (!Blackboard) return EBTNodeResult::Failed; Blackboard-\u0026gt;SetValueAsVector(AimLocationKey.SelectedKeyName, NavLocation.Location); 完整实现 # #include \u0026quot;BehaviorTree/BlackboardComponent.h\u0026quot; #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;NavigationSystem.h\u0026quot; EBTNodeResult::Type USTUNextLocationTask::ExecuteTask(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory) { const auto Controller = OwnerComp.GetAIOwner(); const auto Blackboard = OwnerComp.GetBlackboardComponent(); if (!Controller || !Blackboard) return EBTNodeResult::Failed; const auto Pawn = Controller-\u0026gt;GetPawn(); if (!Pawn) return EBTNodeResult::Failed; const auto NavSys = UNavigationSystemV1::GetCurrent(Pawn); if (!NavSys) return EBTNodeResult::Failed; FNavLocation NavLocation; const auto Found = NavSys-\u0026gt;GetRandomReachablePointInRadius(Pawn-\u0026gt;GetActorLocation(), 1000, NavLocation); if (!Found) return EBTNodeResult::Failed; Blackboard-\u0026gt;SetValueAsVector(AimLocationKey.SelectedKeyName, NavLocation.Location); return EBTNodeResult::Succeeded; } 在行为树中使用该任务 # 添加黑板变量 # BB_STUCharacter 设置行为树 # 添加节点: Next Location ; 设置待设置黑板变量 添加节点: Move To ; 设置目的黑板变量 完整行为树 "}),e.add({id:80,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%88%9D%E8%AF%86%E8%A1%8C%E4%B8%BA%E6%A0%91%E5%92%8C%E9%BB%91%E6%9D%BF/",title:"初识行为树和黑板",description:"说明 # Behavior Tree / Blackboard 在控制器对游戏角色行为逻辑进行描述 数学建模, 直接 非循环 图表, 可能的行为作为节点 虚幻引擎提供行为树编辑器使数学模型可视化 行为树是游戏角色的大脑: 设置了一系列的规则, 迁移条件 Transition , 和NPC状态 黑板作为数据库: 一系列变量, 当我们在代码中将其设置为不同值, 行为树会作出对应反应 创建行为树资产和黑板资产 # Content/AI 右键, Artificial Intelligence \u0026gt; Behavior Tree , 命名为BT_STUCharacter 右键, Artificial Intelligence \u0026gt; Blackboard , 命名为BB_STUCharacter 介绍行为树资产 # 双击打开BT_STUCharacter, 对游戏角色行为逻辑进行配置 行为树由控制节点组成, 任务作为叶子节点; 任务即游戏角色的直接动作 初始只有一个根节点, 作为行为树的入口 第二层有三个选项 - Sequence 按次序执行的多个任务序列 Selector Simple Parallel 第三层可以选任务 - MoveTo 找到路径去到指定位置; MoveAITo的另一种表示 Wait 游戏角色暂停指定秒数 MoveTo任务 # 在细节面板进行配置 Blackboard \u0026gt; Blackboard Key : 决定世界座标系的某个位置, 或者游戏角色将要移动到的Actor 使用黑板资产 # 通过 New Key 按钮添加各种类型变量 添加两个 Vector 类型变量: Location1和Location2; 将在这两点间移动 配置行为树资产 # 点击图表的空白处会显示细节面板, 设置黑板资产 添加节点: Sequence 添加任务: MoveTo 选中 MoveTo 节点, 可以在 Details \u0026gt; Blackboard \u0026gt; Blackboard Key 看到刚刚添加的变量, 选择Location1作为目的地 添加任务: Wait; 设置秒数为2 添加任务: MoveTo; 选择Location2作为目的地 添加任务: Wait; 设置秒数为2 当前NPC逻辑: \u0026gt; 去到Location1 \u0026gt; 等待2s \u0026gt; 去到Location2 \u0026gt; 等待2s; 循环 行为树从上到下、从左到右顺序执行; 左边的优先级更高 任务具有执行状态: 是否成功完成; 成功则运行下一个任务, 否则中止 设置AIController # 运行行为树 # 移除BP_STUAIController蓝图中的逻辑 添加节点: RunBehaviorTree; 在BeginPlay之后执行; 设置行为树资产 设置黑板中变量的位置值 # 在场景另一角添加Actor, 指示Location2 设置变量值: 对Location1和Location2进行设置 添加节点: GetBlackboard; 获取黑板指针 添加节点: SetValueAsVector; 对黑板中的变量进行设置 添加节点: MakeLiteralName; 给出变量名 根据两个指示Actor的座标, 填写到Location1和Location2 查看 # 保持行为树资产打开, 可以看见行为树逻辑执行的过程 按下 ' 显示调试信息; 按下小写键盘的数字关闭 / 打开AI该类别调试信息 切换到NPC # Shift-F1 释放鼠标 在世界大纲选中BP_STUAICharacter 按下 ' Active Task : NPC当前执行的任务 设置AI调试信息相关热键 # Hotkey 显示 / 关闭AI调试窗口 : Project Settings \u0026gt; Engine \u0026gt; Gameplay Debugger \u0026gt; Input \u0026gt; Activation Key ; 可以更换为F10 显示 / 关闭调试信息: Project Settings \u0026gt; Engine \u0026gt; Gameplay Debugger \u0026gt; Extensions \u0026gt; ToggleMessages ; 设置为Ctrl + Z; 原先和切换应用快捷键重复, 因而无法生效 释放鼠标 # 当运行模式为视口和新建编辑器窗口时, 可按下F8释放鼠标控制 ",content:"说明 # Behavior Tree / Blackboard 在控制器对游戏角色行为逻辑进行描述 数学建模, 直接 非循环 图表, 可能的行为作为节点 虚幻引擎提供行为树编辑器使数学模型可视化 行为树是游戏角色的大脑: 设置了一系列的规则, 迁移条件 Transition , 和NPC状态 黑板作为数据库: 一系列变量, 当我们在代码中将其设置为不同值, 行为树会作出对应反应 创建行为树资产和黑板资产 # Content/AI 右键, Artificial Intelligence \u0026gt; Behavior Tree , 命名为BT_STUCharacter 右键, Artificial Intelligence \u0026gt; Blackboard , 命名为BB_STUCharacter 介绍行为树资产 # 双击打开BT_STUCharacter, 对游戏角色行为逻辑进行配置 行为树由控制节点组成, 任务作为叶子节点; 任务即游戏角色的直接动作 初始只有一个根节点, 作为行为树的入口 第二层有三个选项 - Sequence 按次序执行的多个任务序列 Selector Simple Parallel 第三层可以选任务 - MoveTo 找到路径去到指定位置; MoveAITo的另一种表示 Wait 游戏角色暂停指定秒数 MoveTo任务 # 在细节面板进行配置 Blackboard \u0026gt; Blackboard Key : 决定世界座标系的某个位置, 或者游戏角色将要移动到的Actor 使用黑板资产 # 通过 New Key 按钮添加各种类型变量 添加两个 Vector 类型变量: Location1和Location2; 将在这两点间移动 配置行为树资产 # 点击图表的空白处会显示细节面板, 设置黑板资产 添加节点: Sequence 添加任务: MoveTo 选中 MoveTo 节点, 可以在 Details \u0026gt; Blackboard \u0026gt; Blackboard Key 看到刚刚添加的变量, 选择Location1作为目的地 添加任务: Wait; 设置秒数为2 添加任务: MoveTo; 选择Location2作为目的地 添加任务: Wait; 设置秒数为2 当前NPC逻辑: \u0026gt; 去到Location1 \u0026gt; 等待2s \u0026gt; 去到Location2 \u0026gt; 等待2s; 循环 行为树从上到下、从左到右顺序执行; 左边的优先级更高 任务具有执行状态: 是否成功完成; 成功则运行下一个任务, 否则中止 设置AIController # 运行行为树 # 移除BP_STUAIController蓝图中的逻辑 添加节点: RunBehaviorTree; 在BeginPlay之后执行; 设置行为树资产 设置黑板中变量的位置值 # 在场景另一角添加Actor, 指示Location2 设置变量值: 对Location1和Location2进行设置 添加节点: GetBlackboard; 获取黑板指针 添加节点: SetValueAsVector; 对黑板中的变量进行设置 添加节点: MakeLiteralName; 给出变量名 根据两个指示Actor的座标, 填写到Location1和Location2 查看 # 保持行为树资产打开, 可以看见行为树逻辑执行的过程 按下 ' 显示调试信息; 按下小写键盘的数字关闭 / 打开AI该类别调试信息 切换到NPC # Shift-F1 释放鼠标 在世界大纲选中BP_STUAICharacter 按下 ' Active Task : NPC当前执行的任务 设置AI调试信息相关热键 # Hotkey 显示 / 关闭AI调试窗口 : Project Settings \u0026gt; Engine \u0026gt; Gameplay Debugger \u0026gt; Input \u0026gt; Activation Key ; 可以更换为F10 显示 / 关闭调试信息: Project Settings \u0026gt; Engine \u0026gt; Gameplay Debugger \u0026gt; Extensions \u0026gt; ToggleMessages ; 设置为Ctrl + Z; 原先和切换应用快捷键重复, 因而无法生效 释放鼠标 # 当运行模式为视口和新建编辑器窗口时, 可按下F8释放鼠标控制 "}),e.add({id:81,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%92%9E%E5%87%BB%E7%89%B9%E6%95%88%E7%BB%84%E4%BB%B6/",title:"撞击特效组件",description:"说明 # 子弹和榴弹击中时, 生成特效 创建VFX组件 # 武器的下级组件 - 基类 ActorComponent STUWeaponFXComponent Weapon/Components 添加到头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon/Components\u0026quot; }); 添加依赖模块 # ShootThemUp: ShootThemUp.Build.cs PublicDependencyModuleNames.AddRange(new string[] { \u0026quot;Core\u0026quot;, \u0026quot;CoreUObject\u0026quot;, \u0026quot;Engine\u0026quot;, \u0026quot;InputCore\u0026quot;, \u0026quot;Niagara\u0026quot; }); 编译项目 实现撞击特效组件 # ShootThemUp: Weapon/Components/STUWeaponFXComponent.h class UNiagaraSystem; // public void PlayImpactFX(const FHitResult \u0026amp;Hit); // protected UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) UNiagaraSystem *Effect; 碰撞信息结构体包含生成特效的所有信息: 位置, 法向量等 ShootThemUp: Weapon/Components/STUWeaponFXComponent.cpp #include \u0026quot;NiagaraFunctionLibrary.h\u0026quot; void USTUWeaponFXComponent::PlayImpactFX(const FHitResult \u0026amp;Hit) { UNiagaraFunctionLibrary::SpawnSystemAtLocation(GetWorld(), Effect, Hit.",content:"说明 # 子弹和榴弹击中时, 生成特效 创建VFX组件 # 武器的下级组件 - 基类 ActorComponent STUWeaponFXComponent Weapon/Components 添加到头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon/Components\u0026quot; }); 添加依赖模块 # ShootThemUp: ShootThemUp.Build.cs PublicDependencyModuleNames.AddRange(new string[] { \u0026quot;Core\u0026quot;, \u0026quot;CoreUObject\u0026quot;, \u0026quot;Engine\u0026quot;, \u0026quot;InputCore\u0026quot;, \u0026quot;Niagara\u0026quot; }); 编译项目 实现撞击特效组件 # ShootThemUp: Weapon/Components/STUWeaponFXComponent.h class UNiagaraSystem; // public void PlayImpactFX(const FHitResult \u0026amp;Hit); // protected UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) UNiagaraSystem *Effect; 碰撞信息结构体包含生成特效的所有信息: 位置, 法向量等 ShootThemUp: Weapon/Components/STUWeaponFXComponent.cpp #include \u0026quot;NiagaraFunctionLibrary.h\u0026quot; void USTUWeaponFXComponent::PlayImpactFX(const FHitResult \u0026amp;Hit) { UNiagaraFunctionLibrary::SpawnSystemAtLocation(GetWorld(), Effect, Hit.ImpactPoint, Hit.ImpactNormal.Rotation()); } UNiagaraFunctionLibrary::SpawnSystemAtLocation # Engine/Plugins static UNiagaraComponent* SpawnSystemAtLocation(const UObject* WorldContextObject, class UNiagaraSystem* SystemTemplate, FVector Location, FRotator Rotation = FRotator::ZeroRotator, FVector Scale = FVector(1.f), bool bAutoDestroy = true, bool bAutoActivate = true, ENCPoolMethod PoolingMethod = ENCPoolMethod::None, bool bPreCullCheck = true); 在指定位置生成特效 会检查粒子系统指针和上下文指针 - WorldContentObject 上下文, 传入GetWorld()或this SystemTemplate 指向Niagara System的指针 SpawnLocation 生成地点 Rotation 朝向 bAutoDestroy 为true时, 粒子系统特效结束即从世界中移除 为步枪添加碰撞特效组件 # ShootThemUp: Weapon/STURifleWeapon.h class USTUWeaponFXComponent; // protected UPROPERTY(VisibleAnywhere) USTUWeaponFXComponent *WeaponFXComponent; // public ASTURifleWeapon(); // protected virtual void BeginPlay() override; ShootThemUp: Weapon/STURifleWeapon.cpp 屏蔽绘制子弹轨迹和击中点 #include \u0026quot;Weapon/Components/STUWeaponFXComponent.h\u0026quot; ASTURifleWeapon::ASTURifleWeapon() { WeaponFXComponent = CreateDefaultSubobject\u0026lt;USTUWeaponFXComponent\u0026gt;(\u0026quot;WeaponFXComponent\u0026quot;); } void ASTURifleWeapon::BeginPlay() { Super::BeginPlay(); check(WeaponFXComponent); } // MakeShot if (HitResult.bBlockingHit) { // ... WeaponFXComponent-\u0026gt;PlayImpactFX(HitResult); } 为榴弹添加碰撞特效组件 # ShootThemUp: Weapon/STUProjectile.h class USTUWeaponFXComponent; // protected UPROPERTY(VisibleAnywhere) USTUWeaponFXComponent *WeaponFXComponent; ShootThemUp: Weapon/STUProjectile.cpp #include \u0026quot;Weapon/Components/STUWeaponFXComponent.h\u0026quot; // ASTUProjectile WeaponFXComponent = CreateDefaultSubobject\u0026lt;USTUWeaponFXComponent\u0026gt;(\u0026quot;WeaponFXComponent\u0026quot;); // BeginPlay check(WeaponFXComponent); // OnProjectileHit WeaponFXComponent-\u0026gt;PlayImpactFX(Hit); 查看 # 设置步枪和榴弹的粒子系统指针类型 步枪 榴弹 设置粒子系统 NS_BaseImpact 粒子个数 颜色 方向: 修改速度方向 "}),e.add({id:82,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A1%A5%E7%BB%99/%E6%8C%81%E7%BB%AD%E6%8F%90%E4%BE%9B%E8%A1%A5%E7%BB%99/",title:"持续提供补给",description:"说明 # 拾取补给后开启定时器 实现 # 添加属性: 拾取后, 给定时长后可再次拾取补给 # ShootThemUp: Pickups/STUBasePickup.h protected UPROPERTY(EditAnywhere, BlueprintReadWrite) float RespawnTime = 5.0f; 添加函数: 拾取补给后, 关闭碰撞并隐藏补给, 开启定时器; 在定时器中开启碰撞再次显示补给 # ShootThemUp: Pickups/STUBasePickup.h private void PickupWasTaken(); void Respawn(); ShootThemUp: Pickups/STUBasePickup.cpp #include \u0026quot;TimerManager.h\u0026quot; // BeginPlay check(CollisionComponent); // NotifyActorBeginOverlap // Destroy PickupWasTaken(); void ASTUBasePickup::PickupWasTaken() { CollisionComponent-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore); if (GetRootComponent()) { GetRootComponent()-\u0026gt;SetVisibility(false, true); } FTimerHandle RespawnTimerHandle; GetWorldTimerManager().SetTimer(RespawnTimerHandle, this, \u0026amp;ASTUBasePickup::Respawn, RespawnTime); } void ASTUBasePickup::Respawn() { CollisionComponent-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap); if (GetRootComponent()) { GetRootComponent()-\u0026gt;SetVisibility(true, true); } } 隐藏补给 # SetVisibility 第一个参数决定当前组件是否被渲染; 第二个参数决定其下级组件的渲染设置是否与该组件一致 查看 # 运行游戏实例, 按下 ` 打开终端, 输入 show collision 拾取补给后, 碰撞胶囊仍在, 若干秒后补给再次出现, 可反复领取 考虑到补给可能会导致用户数据的修改 # 实现接口 GivePickupTo 通过Pawn对象获取组件, 修改用户数据 private 基类实现 # 返回false ShootThemUp: Pickups/STUBasePickup.",content:"说明 # 拾取补给后开启定时器 实现 # 添加属性: 拾取后, 给定时长后可再次拾取补给 # ShootThemUp: Pickups/STUBasePickup.h protected UPROPERTY(EditAnywhere, BlueprintReadWrite) float RespawnTime = 5.0f; 添加函数: 拾取补给后, 关闭碰撞并隐藏补给, 开启定时器; 在定时器中开启碰撞再次显示补给 # ShootThemUp: Pickups/STUBasePickup.h private void PickupWasTaken(); void Respawn(); ShootThemUp: Pickups/STUBasePickup.cpp #include \u0026quot;TimerManager.h\u0026quot; // BeginPlay check(CollisionComponent); // NotifyActorBeginOverlap // Destroy PickupWasTaken(); void ASTUBasePickup::PickupWasTaken() { CollisionComponent-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore); if (GetRootComponent()) { GetRootComponent()-\u0026gt;SetVisibility(false, true); } FTimerHandle RespawnTimerHandle; GetWorldTimerManager().SetTimer(RespawnTimerHandle, this, \u0026amp;ASTUBasePickup::Respawn, RespawnTime); } void ASTUBasePickup::Respawn() { CollisionComponent-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap); if (GetRootComponent()) { GetRootComponent()-\u0026gt;SetVisibility(true, true); } } 隐藏补给 # SetVisibility 第一个参数决定当前组件是否被渲染; 第二个参数决定其下级组件的渲染设置是否与该组件一致 查看 # 运行游戏实例, 按下 ` 打开终端, 输入 show collision 拾取补给后, 碰撞胶囊仍在, 若干秒后补给再次出现, 可反复领取 考虑到补给可能会导致用户数据的修改 # 实现接口 GivePickupTo 通过Pawn对象获取组件, 修改用户数据 private 基类实现 # 返回false ShootThemUp: Pickups/STUBasePickup.h virtual bool GivePickupTo(APawn *PlayerPawn); ShootThemUp: Pickups/STUBasePickup.cpp bool ASTUBasePickup::GivePickupTo(APawn *PlayerPawn) { return false; } 发生重叠事件并导致用户数据修改时, 认为补给被拾取 # 屏蔽日志打印 ShootThemUp: Pickups/STUBasePickup.cpp // NotifyActorBeginOverlap const auto Pawn = Cast\u0026lt;APawn\u0026gt;(OtherActor); if (GivePickupTo(Pawn)) { PickupWasTaken(); } 生命补给和武器补给的初步实现 # ShootThemUp: Pickups/STUHealthPickup.h ShootThemUp: Pickups/STUAmmoPickup.h virtual bool GivePickupTo(APawn *PlayerPawn) override; ShootThemUp: Pickups/STUHealthPickup.cpp DEFINE_LOG_CATEGORY_STATIC(LogHealthPickup, All, All); bool ASTUHealthPickup::GivePickupTo(APawn *PlayerPawn) { UE_LOG(LogHealthPickup, Display, TEXT(\u0026quot;Health was taken\u0026quot;)); return true; } ShootThemUp: Pickups/STUAmmoPickup.cpp DEFINE_LOG_CATEGORY_STATIC(LogAmmoPickup, All, All); bool ASTUAmmoPickup::GivePickupTo(APawn *PlayerPawn) { UE_LOG(LogAmmoPickup, Display, TEXT(\u0026quot;Ammo was taken\u0026quot;)); return true; } "}),e.add({id:83,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%99%9A%E5%B9%BB%E8%BF%90%E5%8A%A8%E5%9B%BE%E8%A1%A8/%E4%BD%BF%E7%94%A8c++%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%94%9F%E5%91%BD%E6%9D%A1/",title:"使用C++实现游戏角色生命条",description:"概览 # 创建C++类: 窗口部件; 返回生命值百分比 在STUGameHUD中创建并添加窗口部件 修改WBP_PlayerHUD基类; 使用STUPlayerHUDWidget提供的接口获取生命值百分比 移除BP_STUGameHUD中创建并添加窗口部件逻辑; 配置窗口部件类属性 C++类: 窗口部件 # 在虚幻编辑器中创建C++类 # - 基类 UserWidget 名称 STUPlayerHUDWidget 路径 UI/ Public 添加接口: 获取生命值百分比 # ShootThemUp: UI/STUPlayerHUDWidget.h public UFUNCTION(BlueprintCallable) float GetHealthPercent() const; ShootThemUp: UI/STUPlayerHUDWidget.cpp 使用Cast转换空指针得到空指针 #include \u0026quot;Components/STUHealthComponent.h\u0026quot; float USTUPlayerHUDWidget::GetHealthPercent() const { const auto Player = GetOwningPlayerPawn(); if (!Player) return 0.0f; const auto Component = Player-\u0026gt;GetComponentByClass(USTUHealthComponent::StaticClass()); const auto HealthComponent = Cast\u0026lt;USTUHealthComponent\u0026gt;(Component); if (!HealthComponent) return 0.0f; return HealthComponent-\u0026gt;GetHealthPercent(); } 在STUGameHUD中创建并添加窗口部件 # 添加数据成员: 保存窗口部件类 # ShootThemUp: UI/STUGameHUD.",content:"概览 # 创建C++类: 窗口部件; 返回生命值百分比 在STUGameHUD中创建并添加窗口部件 修改WBP_PlayerHUD基类; 使用STUPlayerHUDWidget提供的接口获取生命值百分比 移除BP_STUGameHUD中创建并添加窗口部件逻辑; 配置窗口部件类属性 C++类: 窗口部件 # 在虚幻编辑器中创建C++类 # - 基类 UserWidget 名称 STUPlayerHUDWidget 路径 UI/ Public 添加接口: 获取生命值百分比 # ShootThemUp: UI/STUPlayerHUDWidget.h public UFUNCTION(BlueprintCallable) float GetHealthPercent() const; ShootThemUp: UI/STUPlayerHUDWidget.cpp 使用Cast转换空指针得到空指针 #include \u0026quot;Components/STUHealthComponent.h\u0026quot; float USTUPlayerHUDWidget::GetHealthPercent() const { const auto Player = GetOwningPlayerPawn(); if (!Player) return 0.0f; const auto Component = Player-\u0026gt;GetComponentByClass(USTUHealthComponent::StaticClass()); const auto HealthComponent = Cast\u0026lt;USTUHealthComponent\u0026gt;(Component); if (!HealthComponent) return 0.0f; return HealthComponent-\u0026gt;GetHealthPercent(); } 在STUGameHUD中创建并添加窗口部件 # 添加数据成员: 保存窗口部件类 # ShootThemUp: UI/STUGameHUD.h protected class UUserWidget; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) TSubclassOf\u0026lt;UUserWidget\u0026gt; PlayerHUDWidgetClass; 创建窗口部件并添加到视口 # 通常, 在蓝图中使用的函数和C++中提供同样功能的函数一一对应, 甚至同名 创建窗口部件 # 头文件 Blueprint/UserWidget.h 提供CreateWidget函数 添加到视口 # 使用AddToViewport函数 添加到视口时可以设置景深 Z-order 参数, 涉及到窗口部件的渲染顺序, 默认为0 在BeginPlay中完成 # ShootThemUp: UI/STUGameHUD.h protected virtual void BeginPlay() override; ShootThemUp: UI/STUGameHUD.cpp #include \u0026quot;Blueprint/UserWidget.h\u0026quot; // Provide CreateWidget: Template function void ASTUGameHUD::BeginPlay() { Super::BeginPlay(); auto PlayerHUDWidget = CreateWidget\u0026lt;UUserWidget\u0026gt;(GetWorld(), PlayerHUDWidgetClass); if (PlayerHUDWidget) { PlayerHUDWidget-\u0026gt;AddToViewport(); } } 修改WBP_PlayerHUD # 将基类从UserWidget改为STUPlayerHUDWidget # 打开WBP_PlayerHUD, File \u0026gt; Reparent Blueprint 选择STUPlayerHUDWidget 右上角查看当前基类 修改蓝图GetHealthPercent实现 # 去到 Graph 添加节点: GetHealthPercent 蓝图实现 窗口部件的逻辑和功能封装在C++中, 在虚幻运动图表编辑器, 我们可以从设计的角度装饰窗口部件 修改BP_STUGameHUD # 已在C++中实现创建并添加窗口部件到关卡, 移除 Event Graph 操作 点击按钮 Class Defaults 设置PlayerHUDWidgetClass为WBP_PlayerHUD "}),e.add({id:84,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E6%89%93%E5%8C%85/",title:"打包",description:"在代码中添加检查 # 使用 checkf , 和 check 相比, 可以设置提示信息 使用 checkNoEntry , 等价于调用 check 返回false; 立即触发断言 assertion STUBaseWeapon # ShootThemUp: Weapon/STUBaseWeapon.cpp 检查蓝图中设置的子弹数, 要求大于等于0 可以使用ClampMin和ClampMax进行元信息 meta information 检查 之后在蓝图设置错误数值触发检查 // BeginPlay checkf(DefaultAmmo.Bullets \u0026gt; 0, TEXT(\u0026quot;Bullets count couldn't be less or equal zero\u0026quot;)); checkf(DefaultAmmo.Clips \u0026gt; 0, TEXT(\u0026quot;Clips count couldn't be less or equal zero\u0026quot;)); STUWeaponComponent # ShootThemUp: Components/STUWeaponComponent.cpp 定义常量, 检查蓝图中配置的武器个数 constexpr static int32 WeaponNum = 2; // BeginPlay checkf(WeaponData.Num() == 2, TEXT(\u0026quot;Our character can hold only %d weapon items\u0026quot;), WeaponNum); AnimNotify # ShootThemUp: Components/STUWeaponComponent.",content:"在代码中添加检查 # 使用 checkf , 和 check 相比, 可以设置提示信息 使用 checkNoEntry , 等价于调用 check 返回false; 立即触发断言 assertion STUBaseWeapon # ShootThemUp: Weapon/STUBaseWeapon.cpp 检查蓝图中设置的子弹数, 要求大于等于0 可以使用ClampMin和ClampMax进行元信息 meta information 检查 之后在蓝图设置错误数值触发检查 // BeginPlay checkf(DefaultAmmo.Bullets \u0026gt; 0, TEXT(\u0026quot;Bullets count couldn't be less or equal zero\u0026quot;)); checkf(DefaultAmmo.Clips \u0026gt; 0, TEXT(\u0026quot;Clips count couldn't be less or equal zero\u0026quot;)); STUWeaponComponent # ShootThemUp: Components/STUWeaponComponent.cpp 定义常量, 检查蓝图中配置的武器个数 constexpr static int32 WeaponNum = 2; // BeginPlay checkf(WeaponData.Num() == 2, TEXT(\u0026quot;Our character can hold only %d weapon items\u0026quot;), WeaponNum); AnimNotify # ShootThemUp: Components/STUWeaponComponent.cpp 未在轨道中添加AnimNotify事件(找不到Notify)时, 输出日志, 并调用宏 checkNoEntry // InitAnimations if (EquipFinishedNotify) { // ... } else { UE_LOG(LogWeaponComponent, Error, TEXT(\u0026quot;Equip anim notify is forgetten to set\u0026quot;)); checkNoEntry(); } if (ReloadFinishedNotify) { // ... } else { UE_LOG(LogWeaponComponent, Error, TEXT(\u0026quot;Reload anim notify is forgetten to set\u0026quot;)); checkNoEntry(); } 添加头文件AnimUtils.h # 在Public/Animations/添加AnimUtils.h 纯辅助, 实用类, 供动画相关类使用 屏蔽FindNotifyByClass的定义和相关头文件 # ShootThemUp: Components/STUWeaponComponent.h #include \u0026quot;Animation/AnimSequenceBase.h\u0026quot; 定义AnimUtils类 # ShootThemUp: Animations/AnimUtils.h 声明为静态函数(不依赖具体类对象) #pragma once #include \u0026quot;Animation/AnimSequenceBase.h\u0026quot; class AnimUtils { public: template\u0026lt;typename T\u0026gt; static T* FindNotifyByClass(UAnimSequenceBase *Animation) { if (!Animation) return nullptr; const auto NotifyEvents = Animation-\u0026gt;Notifies; for (auto NotifyEvent : NotifyEvents) { auto AnimNotify = Cast\u0026lt;T\u0026gt;(NotifyEvent.Notify); if (AnimNotify) { return AnimNotify; } } return nullptr; } }; 使用 # ShootThemUp: Components/STUWeaponComponent.cpp 添加头文件 #include \u0026quot;Animations/AnimUtils.h\u0026quot; 使用FindNotifyByClass时给出所属类名 添加头文件STUCoreTypes.h # 在Public/添加STUCoreTypes.h 将别处定义的数据结构和委托类型整合, 标注使用的地方; 可以按WeaponTypes, HealthTypes进行分类 修改后在头文件中包含STUCoreTypes.h STUBaseWeapon # ShootThemUp: Weapon/STUBaseWeapon.h FOnClipEmptySignature FAmmoData STUWeaponComponent # ShootThemUp: Components/STUWeaponComponent.h FWeaponData #include \u0026quot;Templates/SubclassOf.h\u0026quot; class ASTUBaseWeapon; class UAnimMontage; STUHealthComponent # ShootThemUp: Components/STUHealthComponent.h FOnDeathSignature FOnHealthChangedSignature 为了让UHT正确生成数据结构、委托类型宏相关的所有代码, 添加头文件声明 # 格式 \u0026ldquo;filename.generated.h\u0026rdquo; ShootThemUp:STUCoreTypes.h #include \u0026quot;STUCoreTypes.generated.h\u0026quot; 验证 # 将Content/Weapon/BP_STURifleWeapon \u0026gt; Default Ammo \u0026gt; Bullets设-1 # =\u0026gt; 程序崩溃: 触发断言并输出日志 恢复 删除Content/Player/Animations/AM_Equip中的STUEquipFinishedAnimNotify # =\u0026gt; 程序崩溃: 触发checkNoEntry 恢复 打包游戏 # 工具栏 \u0026gt; Platforms \u0026gt; Mac, 选择DebugGame, 可以看见日志 工具栏 \u0026gt; Platforms \u0026gt; Mac \u0026gt; Package Project "}),e.add({id:85,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE/%E4%B8%BA%E8%BD%A8%E9%81%93%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB%E9%80%9A%E7%9F%A5/",title:"为轨道添加动画通知",description:"Track Animation Notify 便签 # - AnimNotify类 动画通知 AnimSequenceBase类 动画 动画通知 # 通常在动画通知中, 对事件进行处理 实现委托机制, 在AnimNotify中定义委托, 添加委托对象, 在Notify函数中通知客户端 ShootThemUp: Animations/STUAnimNotify.h DECLARE_MULTICAST_DELEGATE_OneParam(FOnNotifiedSignature, USkeletalMeshComponent*); UCLASS() class SHOOTTHEMUP_API USTUAnimNotify : public UAnimNotify { GENERATED_BODY() public: FOnNotifiedSignature OnNotified; virtual void Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference\u0026amp; EventReference) override;	}; ShootThemUp: Animation/STUAnimNotify.cpp void USTUAnimNotify::Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference\u0026amp; EventReference) { OnNotified.Broadcast(MeshComp); Super::Notify(MeshComp, Animation, EventReference); } 在轨道中添加通知事件 # 以动画剪辑为例 在通知所属轨道的合适位置右键, 添加指定类型通知 动画剪辑播放到事件所在帧时, 调用UAnimNotify::Notify 订阅委托服务 # 遍历给定动画的通知事件, 获取指针, 指向指定类型的通知对象 # ShootThemUp: Components/STUWeaponComponent.",content:"Track Animation Notify 便签 # - AnimNotify类 动画通知 AnimSequenceBase类 动画 动画通知 # 通常在动画通知中, 对事件进行处理 实现委托机制, 在AnimNotify中定义委托, 添加委托对象, 在Notify函数中通知客户端 ShootThemUp: Animations/STUAnimNotify.h DECLARE_MULTICAST_DELEGATE_OneParam(FOnNotifiedSignature, USkeletalMeshComponent*); UCLASS() class SHOOTTHEMUP_API USTUAnimNotify : public UAnimNotify { GENERATED_BODY() public: FOnNotifiedSignature OnNotified; virtual void Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference\u0026amp; EventReference) override;	}; ShootThemUp: Animation/STUAnimNotify.cpp void USTUAnimNotify::Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference\u0026amp; EventReference) { OnNotified.Broadcast(MeshComp); Super::Notify(MeshComp, Animation, EventReference); } 在轨道中添加通知事件 # 以动画剪辑为例 在通知所属轨道的合适位置右键, 添加指定类型通知 动画剪辑播放到事件所在帧时, 调用UAnimNotify::Notify 订阅委托服务 # 遍历给定动画的通知事件, 获取指针, 指向指定类型的通知对象 # ShootThemUp: Components/STUWeaponComponent.h template\u0026lt;typename T\u0026gt; T* FindFirstNotifyByClass(UAnimSequenceBase *Animation) { if (!Animation) return nullptr; const auto NotifyEvents = Animation-\u0026gt;Notifies; for (auto NotifyEvent : NotifyEvents) { auto AnimNotify = Cast\u0026lt;T\u0026gt;(NotifyEvent.Notify); if (AnimNotify) { return AnimNotify; } } return nullptr; } 注册处理函数 # ShootThemUp: Components/STUWeaponComponent.cpp auto EquipFinishedNotify = FindFirstNotifyByClass\u0026lt;USTUEquipFinishedAnimNotify\u0026gt;(EquipAnimMontage); if (EquipFinishedNotify) { EquipFinishedNotify-\u0026gt;OnNotified.AddUObject(this, \u0026amp;USTUWeaponComponent::OnEquipFinished); } "}),e.add({id:86,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E5%8A%A8%E7%94%BB/animnotify%E7%B1%BB/",title:"AnimNotify类",description:"便签 # UE_5.1/Engine/Source/Runtime/Engine/Classes/Animation/AnimNotifies/AnimNotify.h - API - UAnimNotify 派生关系 # UObject ^ UAnimNotify AnimNotify::Notify # public 事件发生时, 调用Notify函数 参数 MeshComp 动画绑定的骨骼网格体 Animation 轨道信息 virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference\u0026amp; EventReference); ",content:"便签 # UE_5.1/Engine/Source/Runtime/Engine/Classes/Animation/AnimNotifies/AnimNotify.h - API - UAnimNotify 派生关系 # UObject ^ UAnimNotify AnimNotify::Notify # public 事件发生时, 调用Notify函数 参数 MeshComp 动画绑定的骨骼网格体 Animation 轨道信息 virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference\u0026amp; EventReference); "}),e.add({id:87,href:"/docs/brick/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D%E5%88%86%E5%8C%BA/",title:"记一次重装系统后的恢复分区",description:"好用的写镜像工具 # - Rufus Windows 写镜像到U盘 Ventoy Linux, Windows 将镜像拷贝到U盘即可 老毛桃 Windows 以上两种均可 常见的数据恢复软件 # - EaseUS EasyRecovery DiskGenius 概览 # 我重装系统时, 都会使用DiskGenius重新分区, 这回碰到个使用习惯完全不一样的, 捅了个大篓子 整盘扫描 # EaseUS和EasyRecovery Professional均提供该功能, 但找回的文件没有层级结构, 使用编号命名 按现有分区搜索 # 因为与原分区不同, 找回的文件有限 搜索分区表 # DiskGenius提供该功能 我对硬盘一无所知, 知道分区表这个概念, 但不知道如何实现 联系DiskGenius客服后, 要我搜索分区表, 当前分区 120 + \u0026hellip;, 原分区50 + \u0026hellip;, DiskGenius按扇柱搜索, 正好 当前扇柱/总扇柱=50/465 时找到原分区表, 至此可以打开重装系统前硬盘上的文件 DiskGenius # 其搜索分区表的优势在于, 找到所需的分区表后, 可以立即应用; 在此之前按扇柱搜索, 不会有所遗漏 连接机械硬盘 # SATA 3.5英寸机械硬盘(主机用)需购买电源线, 2.5英寸机械硬盘(笔记本用)只需转换线 接入顺序: 给硬盘通上电, 再连接到USB接口 拔出顺序: 安全弹出后, 先断掉USB接口, 再关闭电源 ",content:"好用的写镜像工具 # - Rufus Windows 写镜像到U盘 Ventoy Linux, Windows 将镜像拷贝到U盘即可 老毛桃 Windows 以上两种均可 常见的数据恢复软件 # - EaseUS EasyRecovery DiskGenius 概览 # 我重装系统时, 都会使用DiskGenius重新分区, 这回碰到个使用习惯完全不一样的, 捅了个大篓子 整盘扫描 # EaseUS和EasyRecovery Professional均提供该功能, 但找回的文件没有层级结构, 使用编号命名 按现有分区搜索 # 因为与原分区不同, 找回的文件有限 搜索分区表 # DiskGenius提供该功能 我对硬盘一无所知, 知道分区表这个概念, 但不知道如何实现 联系DiskGenius客服后, 要我搜索分区表, 当前分区 120 + \u0026hellip;, 原分区50 + \u0026hellip;, DiskGenius按扇柱搜索, 正好 当前扇柱/总扇柱=50/465 时找到原分区表, 至此可以打开重装系统前硬盘上的文件 DiskGenius # 其搜索分区表的优势在于, 找到所需的分区表后, 可以立即应用; 在此之前按扇柱搜索, 不会有所遗漏 连接机械硬盘 # SATA 3.5英寸机械硬盘(主机用)需购买电源线, 2.5英寸机械硬盘(笔记本用)只需转换线 接入顺序: 给硬盘通上电, 再连接到USB接口 拔出顺序: 安全弹出后, 先断掉USB接口, 再关闭电源 "}),e.add({id:88,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/org-bullets/",title:"org-bullets",description:"大纲样式 org-bullets-安装 # ;; (use-package org-bullets ;; :ensure t ;; :config (add-hook 'org-mode-hook 'org-bullets-mode)) ",content:"大纲样式 org-bullets-安装 # ;; (use-package org-bullets ;; :ensure t ;; :config (add-hook 'org-mode-hook 'org-bullets-mode)) "}),e.add({id:89,href:"/docs/%E5%88%86%E4%BA%AB/emacs/elisp/",title:"elisp",description:"便签 # - Manual 李杀-Buffer 文件 # 打开文件 # (find-file \u0026quot;path/to/file\u0026quot;) 使用打开链接的方式，打开指定文件 # (org-open-file \u0026quot;path/to/file\u0026quot;) 打开链接 # C-c C-o (org-open-at-point) 文本 # 在光标处插入 # (insert \u0026quot;Hello\u0026quot;) 读取输入 # (read-string \u0026quot;Promots: \u0026quot;) 搜索并替换 # 字符串replace-string # replace-string会跳过链接匹配 全文搜索并替换 # (while (search-forward \u0026quot;file:tt.txt\u0026quot; nil t) (replace-match \u0026quot;file:pp.txt\u0026quot; nil t)) 字符串查找 # search-backward # (search-backward \u0026quot;test\u0026quot;) ;; 查找成功返回t (search-backward \u0026quot;test\u0026quot; nil t) 正则查找 # re-search-forward # 目的字符串 ![[ue:UE_5.1/Engine/Source/Runtime/Core/Public/Math/Interval.h][虚幻引擎:Interval.h]] 正则匹配 (re-search-forward (rx \u0026quot;[[\u0026quot; \u0026quot;ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; )) ;; 匹配返回t (re-search-forward (rx \u0026quot;[[\u0026quot; \u0026quot;ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) 复制 # (copy-region-as-kill (point-min) (point-max)) 光标 # 光标所在位置 # (point) 去到指定位置 # (goto-char (point)) 光标信息 # (what-cursor-position) 记忆光标位置, 处理结束恢复 # (save-excursion (insert \u0026quot;hello\u0026quot;)) 获取光标间字符串 # (buffer-substring-no-properties (point-min) (point-max)) 缓冲区 # 获取buffer内容 # (buffer-string) 创建buffer # (generate-new-buffer \u0026quot;test\u0026quot;) 返回已有buffer或创建新buffer # (get-buffer-create \u0026quot;test\u0026quot;) 在指定buffer中处理 # (with-current-buffer (get-buffer-create \u0026quot;test\u0026quot;) (insert \u0026quot;hello\u0026quot;) ) 在临时buffer中处理 # (with-temp-buffer (insert \u0026quot;hello\u0026quot;)) 保存buffer # (save-buffer) 关闭buffer # (kill-buffer) 获取buffer对应的文件名 # (buffer-name) 获取buffer对应文件的完整路径 # (buffer-file-name) 获取给定文件的buffer # (get-buffer (buffer-name)) 控制语句 # 条件控制语句 # if # 缩进作为true和false的分支 各一条语句 (if (= 3 5) (message \u0026quot;equal\u0026quot;) (message \u0026quot;not equal\u0026quot;)) when：cond为true时继续 # (when (\u0026lt; 3 5) (setq ooout '(\u0026quot;less\u0026quot;)) (message \u0026quot;%s\u0026quot; (cons \u0026quot;multi\u0026quot; ooout))) unless：cond为false时继续 # (unless (\u0026gt; 3 4) (setq ooout '(\u0026quot;false\u0026quot; \u0026quot;3 \u0026lt; 4\u0026quot; \u0026quot;is\u0026quot; \u0026quot;true\u0026quot; \u0026quot;!",content:`便签 # - Manual 李杀-Buffer 文件 # 打开文件 # (find-file \u0026quot;path/to/file\u0026quot;) 使用打开链接的方式，打开指定文件 # (org-open-file \u0026quot;path/to/file\u0026quot;) 打开链接 # C-c C-o (org-open-at-point) 文本 # 在光标处插入 # (insert \u0026quot;Hello\u0026quot;) 读取输入 # (read-string \u0026quot;Promots: \u0026quot;) 搜索并替换 # 字符串replace-string # replace-string会跳过链接匹配 全文搜索并替换 # (while (search-forward \u0026quot;file:tt.txt\u0026quot; nil t) (replace-match \u0026quot;file:pp.txt\u0026quot; nil t)) 字符串查找 # search-backward # (search-backward \u0026quot;test\u0026quot;) ;; 查找成功返回t (search-backward \u0026quot;test\u0026quot; nil t) 正则查找 # re-search-forward # 目的字符串 ![[ue:UE_5.1/Engine/Source/Runtime/Core/Public/Math/Interval.h][虚幻引擎:Interval.h]] 正则匹配 (re-search-forward (rx \u0026quot;[[\u0026quot; \u0026quot;ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; )) ;; 匹配返回t (re-search-forward (rx \u0026quot;[[\u0026quot; \u0026quot;ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) 复制 # (copy-region-as-kill (point-min) (point-max)) 光标 # 光标所在位置 # (point) 去到指定位置 # (goto-char (point)) 光标信息 # (what-cursor-position) 记忆光标位置, 处理结束恢复 # (save-excursion (insert \u0026quot;hello\u0026quot;)) 获取光标间字符串 # (buffer-substring-no-properties (point-min) (point-max)) 缓冲区 # 获取buffer内容 # (buffer-string) 创建buffer # (generate-new-buffer \u0026quot;test\u0026quot;) 返回已有buffer或创建新buffer # (get-buffer-create \u0026quot;test\u0026quot;) 在指定buffer中处理 # (with-current-buffer (get-buffer-create \u0026quot;test\u0026quot;) (insert \u0026quot;hello\u0026quot;) ) 在临时buffer中处理 # (with-temp-buffer (insert \u0026quot;hello\u0026quot;)) 保存buffer # (save-buffer) 关闭buffer # (kill-buffer) 获取buffer对应的文件名 # (buffer-name) 获取buffer对应文件的完整路径 # (buffer-file-name) 获取给定文件的buffer # (get-buffer (buffer-name)) 控制语句 # 条件控制语句 # if # 缩进作为true和false的分支 各一条语句 (if (= 3 5) (message \u0026quot;equal\u0026quot;) (message \u0026quot;not equal\u0026quot;)) when：cond为true时继续 # (when (\u0026lt; 3 5) (setq ooout '(\u0026quot;less\u0026quot;)) (message \u0026quot;%s\u0026quot; (cons \u0026quot;multi\u0026quot; ooout))) unless：cond为false时继续 # (unless (\u0026gt; 3 4) (setq ooout '(\u0026quot;false\u0026quot; \u0026quot;3 \u0026lt; 4\u0026quot; \u0026quot;is\u0026quot; \u0026quot;true\u0026quot; \u0026quot;!\u0026quot;)) (pop ooout) (message \u0026quot;%s\u0026quot; ooout)) 循环while # break # Catch-and-Throw (let ((cnt 0)) (catch 'break (while t (setq cnt (+ cnt 1)) (sleep-for 1) (if (= cnt 5) (throw 'break t) ) ) ) ) 功能函数 # 等待 # (sleep-for 2) 执行shell命令 # (shell-command \u0026quot;ps\u0026quot;) hook # 添加hook # (add-hook 'emms-player-started-hook (lambda () (emms-seek-to \u0026quot;05:05\u0026quot;) (emms-pause))) 移除hook # (remove-hook 'emms-player-started-hook (lambda () (emms-seek-to \u0026quot;05:05\u0026quot;) (emms-pause))) 函数调用 # funcall # 第一个参数是函数，之后的组成参数列表，传入第一个参数对应的函数 (funcall (emms-player-get player 'start) track) ;; (emms-player-get player 'start) 查dictionary得到emms-player-mpv-start ;; (emms-player-mpv-start track) apply-partially # 类似C++的bind，预设函数调用的参数 使用时，根据需求传入剩余参数 返回函数
将args作为func的前n个参数传入，调用函数时，和实际传参拼接，传给func (defun apply-partially (func \u0026amp;rest args) ;;... ) 定义函数
(defun emms-player-mpv-cmd (cmd \u0026amp;optional handler) ;;... ) (setq func (apply-partially 'emms-player-mpv-cmd play-cmd (lambda (_mpv-data mpv-error) (when (eq mpv-error 'connection-error) (emms-player-mpv-cmd play-cmd))))) (funcall func) 定义变量 # 使用let定义局部变量 # (let ((x 10) (y 20) (z 30)) (message (format \u0026quot;%d %d %d\u0026quot; x y z))) 变量之间存在引用 # (let* ((x 10) (y (+ x 10))) (message (format \u0026quot;%d %d\u0026quot; x y))) 使用setq对局部变量值进行修改 # 使用setq定义全局变量 # 可以使用 C-h v 查看变量值 buffer-local变量 # buffer内设置变量使用setq, 所有buffer生效使用setq-default 函数 # 返回值 # 函数最后一条语句的执行结果作为返回值 定义 # 可选参数：传参时，arg1必须匹配，arg2可选 # (defun test-func (arg1 \u0026amp;option arg2) ;;... ) 可变参数：传参时，arg1必须匹配，之后传入参数个数可变 # 必须放在参数列表最后 (defun test-func (arg1 \u0026amp;rest args) ;;... ) 数据结构 # string # 删除空格 # (string-trim \u0026quot; Hello \u0026quot;) 切分字符串成列表 # (split-string opath \u0026quot;/\u0026quot;) ;; 不包含为空的元素 (split-string opath \u0026quot;/\u0026quot; t) 判等 # (string= \u0026quot;hello\u0026quot; \u0026quot;Hello\u0026quot;) 不改变字符串, 返回去除前缀结果 # (string-remove-prefix \u0026quot;/\u0026quot; slot) list # 构造list # (setq slotlist '()) 元素操作 # 将元素添加到列表(头插)
(add-to-list 'slotlist export-name) 删除首元素
(pop list) 获取指定元素
(nth N list) list操作 # 长度
(length list) 打印
(print list) 返回头插的新list
(cons x list) 返回拼接后的新list
(append list1 list2) 将list转换为字符串
(format \u0026quot;%s\u0026quot; list) 遍历列表
(dolist (item the-list) ;; 操作item ) 将末尾元素组成列表
(last list) 获取首元素
(car list) 返回反转列表拷贝
(reverse slotlist) alist # Associate List (setq list '((\u0026quot;mary\u0026quot; . 23) (\u0026quot;john\u0026quot; . 24) (\u0026quot;smith\u0026quot; . 33))) 通过key获取键值对 # (assoc \u0026quot;john\u0026quot; list) 通过value获取键值对 # (rassoc 24 list) 获取键值对的key # (car (assoc \u0026quot;john\u0026quot; x)) 获取键值对的value # (cdr (assoc \u0026quot;john\u0026quot; x)) 运算符 # 不等 # /= `}),e.add({id:90,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E8%B7%B3%E8%BD%AC/",title:"虚幻引擎源码跳转",description:"说明 # API会标注类源码路径 源码路径样式 # 无! ![[file:file.cpp][源码:name]] 需设置引擎源码文件夹 # ;; (setq my/ue-source-path \u0026quot;path/to/ue/source\u0026quot;) 插入源码路径 # (defun my/insert-ue-source-path () (interactive) (let* ((path (read-string \u0026quot;Path: UE_5.1/Engine/Source/\u0026quot;)) (file (car (last (split-string path \u0026quot;/\u0026quot; t))))) (insert (format (concat \u0026quot;[[\u0026quot; \u0026quot;ue:UE_5.1/Engine/Source/%s][虚幻引擎:%s]]\u0026quot;) path file)))) (global-set-key (kbd \u0026quot;C-c u e\u0026quot;) 'my/insert-ue-source-path) 打开源码文件 # (defun my/go-to-ue-source () (interactive) (when (search-backward (concat \u0026quot;[[\u0026quot; \u0026quot;ue:\u0026quot;) nil t) (when (re-search-forward (rx \u0026quot;[[\u0026quot; \u0026quot;ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1))))) (org-open-file (concat my/ue-source-path \u0026quot;/\u0026quot; file)))))) (global-set-key (kbd \u0026quot;C-c u g\u0026quot;) 'my/go-to-ue-source) ",content:"说明 # API会标注类源码路径 源码路径样式 # 无! ![[file:file.cpp][源码:name]] 需设置引擎源码文件夹 # ;; (setq my/ue-source-path \u0026quot;path/to/ue/source\u0026quot;) 插入源码路径 # (defun my/insert-ue-source-path () (interactive) (let* ((path (read-string \u0026quot;Path: UE_5.1/Engine/Source/\u0026quot;)) (file (car (last (split-string path \u0026quot;/\u0026quot; t))))) (insert (format (concat \u0026quot;[[\u0026quot; \u0026quot;ue:UE_5.1/Engine/Source/%s][虚幻引擎:%s]]\u0026quot;) path file)))) (global-set-key (kbd \u0026quot;C-c u e\u0026quot;) 'my/insert-ue-source-path) 打开源码文件 # (defun my/go-to-ue-source () (interactive) (when (search-backward (concat \u0026quot;[[\u0026quot; \u0026quot;ue:\u0026quot;) nil t) (when (re-search-forward (rx \u0026quot;[[\u0026quot; \u0026quot;ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1))))) (org-open-file (concat my/ue-source-path \u0026quot;/\u0026quot; file)))))) (global-set-key (kbd \u0026quot;C-c u g\u0026quot;) 'my/go-to-ue-source) "}),e.add({id:91,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%BB%98%E5%88%B6%E7%9E%84%E5%87%86%E5%8D%81%E5%AD%97/",title:"绘制瞄准十字",description:"概览 # 瞄准十字：垂直的两条线，处于屏幕正中间 创建抬头显示类STUGameHUD 设置关卡使用STUGameHUD, 绘制瞄准十字 调整SpringArm组件的Camera偏移, 使得游戏角色在瞄准十字左侧 调整HealthText组件, 生命值对敌人可见, 对自己不可见 在代码中设置SpringArm组件Socket偏移和TextRender组件渲染标志位的方法 HUD # Head-Up Display 抬头显示, 包含一些常用信息 用得不多, 很多功能使用Widget替换完成 AHUD 创建抬头显示类 # 创建C++类: UI/STUGameHUD # 虚幻编辑器 Actor \u0026gt; AHUD 公有类 更新头文件搜索路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot; }); 绘制瞄准十字 # 虚幻C++ 设置关卡使用STUGameHUD # AGameModeBase::HUDClass ShootThemUp: STUGameModeBase.cpp #include \u0026quot;UI/STUGameHUD.h\u0026quot; // ASTUGameModeBase HUDClass = ASTUGameHUD::StaticClass(); 获取屏幕中心位置 # 通过AHUD::Canvas获取屏幕长和宽，中心点保存到TInterval类型变量 AHUD::Canvas UCanvas UCanvas::SizeX 和 UCanvas::SizeY TInterval #include \u0026quot;Engine/Canvas.",content:"概览 # 瞄准十字：垂直的两条线，处于屏幕正中间 创建抬头显示类STUGameHUD 设置关卡使用STUGameHUD, 绘制瞄准十字 调整SpringArm组件的Camera偏移, 使得游戏角色在瞄准十字左侧 调整HealthText组件, 生命值对敌人可见, 对自己不可见 在代码中设置SpringArm组件Socket偏移和TextRender组件渲染标志位的方法 HUD # Head-Up Display 抬头显示, 包含一些常用信息 用得不多, 很多功能使用Widget替换完成 AHUD 创建抬头显示类 # 创建C++类: UI/STUGameHUD # 虚幻编辑器 Actor \u0026gt; AHUD 公有类 更新头文件搜索路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot; }); 绘制瞄准十字 # 虚幻C++ 设置关卡使用STUGameHUD # AGameModeBase::HUDClass ShootThemUp: STUGameModeBase.cpp #include \u0026quot;UI/STUGameHUD.h\u0026quot; // ASTUGameModeBase HUDClass = ASTUGameHUD::StaticClass(); 获取屏幕中心位置 # 通过AHUD::Canvas获取屏幕长和宽，中心点保存到TInterval类型变量 AHUD::Canvas UCanvas UCanvas::SizeX 和 UCanvas::SizeY TInterval #include \u0026quot;Engine/Canvas.h\u0026quot; // DrawCrossHair const TInterval\u0026lt;float\u0026gt; Center(Canvas-\u0026gt;SizeX * 0.5f, Canvas-\u0026gt;SizeY * 0.5f); 线条参数 # - 长度 HalfLineSize * 2 颜色 LineColor 粗细 LineThickness const float HalfLineSize = 10.0f; const float LineThickness = 2.0f; const FLinearColor LineColor = FLinearColor::Green; 以中心点为基准, 得到横竖两条线的起点和终点 # TInterval::Min 和 TInterval::Max 起点 终点 横 (Center.Min - HalfLineSize, Center.Max) (Center.Min + HalfLineSize, Center.Max) 竖 (Center.Min, Center.Max - HalfLineSize) (Center.Min, Center.Max + HalfLineSize) 使用AHUD::DrawLine绘制线条 # AHUD::DrawLine DrawLine(Center.Min, Center.Max - HalfLineSize, Center.Min, Center.Max + HalfLineSize, LineColor, LineThickness); DrawLine(Center.Min - HalfLineSize, Center.Max, Center.Min + HalfLineSize, Center.Max, LineColor, LineThickness); 完整实现: DrawCrossHair # ShootThemUp: UI/STUGameHUD.h private void DrawCrossHair(); ShootThemUp: UI/STUGameHUD.cpp void ASTUGameHUD::DrawCrossHair() { const TInterval\u0026lt;float\u0026gt; Center(Canvas-\u0026gt;SizeX * 0.5f, Canvas-\u0026gt;SizeY * 0.5f); const float HalfLineSize = 10.0f; const float LineThickness = 2.0f; const FLinearColor LineColor = FLinearColor::Green; DrawLine(Center.Min, Center.Max - HalfLineSize, Center.Min, Center.Max + HalfLineSize, LineColor, LineThickness); DrawLine(Center.Min - HalfLineSize, Center.Max, Center.Min + HalfLineSize, Center.Max, LineColor, LineThickness); } 覆写AHUD::DrawHUD，调用DrawCorssHair # AHUD对象每帧都会调用DrawHUD函数 AHUD::DrawHUD ShootThemUp: UI/STUGameHUD.h public virtual void DrawHUD() override; ShootThemUp: UI/STUGameHUD.cpp void ASTUGameHUD::DrawHUD() { Super::DrawHUD(); DrawCrossHair(); } 查看 # 虚幻编辑器 关卡使用STUGameHUD 操控游戏角色移动, 或者调整屏幕大小，绿色十字总在屏幕中心位置 设置SpringArm组件的Camera偏移: 使得游戏角色在瞄准十字左侧 # 虚幻编辑器 打开BP_STUBaseCharacter，选中SpringArmComponent \u0026gt; Details \u0026gt; Camera \u0026gt; Socket Offset，设置Y偏移100 效果图: Camera组件在游戏角色的右·上·后方 设置HealthText组件: 生命值对敌人可见, 对自己不可见 # 虚幻编辑器 渲染标志位 Owner No See 玩家可以看见他人游戏角色的生命值，看不见自己的 渲染别人家的TextComponent，不渲染自家的 Only Owner See 玩家只能看见自己游戏角色的生命值 渲染自家的TextComponent 设置标志位 # 打开BP_STUBaseCharacter，选中HealthTextComponent, 去到Details 搜索Owner，勾选 Owner No See 旋转文本, 显示给敌人看 # 在关卡中添加BP_STUBaseCharacter对象，查看效果 # 在代码中设置SpringArm组件Socket偏移和TextRender组件渲染标志位的方法 # C++ ShootThemUp: Player/STUBaseCharacter.cpp 设置SpringArm组件的Camera偏移 # USpringArmComponent::SocketOffset // 构造函数 SpringArmComponent-\u0026gt;SocketOffset = FVector(0.0f, 100.0f, 80.0f); 设置TextRender组件的OwnerNoSee标志位 # UPrimitiveComponent::SetOwnerNoSee // 构造函数 HealthTextComponent-\u0026gt;SetOwnerNoSee(true); "}),e.add({id:92,href:"/docs/build-blog/%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E6%A0%87%E9%A2%98%E9%AB%98%E4%BA%AE/",title:"文章目录标题高亮",description:"说明 # 设置高亮样式 css 使用Intersection Observer实现 JavaScript 文章目录设置 config/_default/markup.toml - startLevel 2 endLevel 3 另一个实现思路为Scrollspy 移植到Doks主题 便签 # - 文章目录滚动高亮 1. 为文章目录设置类 2. 高亮样式 3. 提供一种实现 高亮样式 当前标题底部加横线 滚动高亮 设置元素的父元素 滚动高亮 option和intersectionObserver的callback IntersectionObserver API 1. 添加观察元素: observe 2. intersectionRatio 3. target querySelectorAll用法 1. 获取有指定属性的元素: \u0026ldquo;a[target]\u0026rdquo; 2. 获取指定父元素的元素: \u0026ldquo;div \u0026gt; p\u0026rdquo; 3. 获取多个分类元素: \u0026ldquo;h2[id], h3[id]\u0026rdquo; 获取元素的方式 1. id: getElementById, 上下文要求是documnet 2. name: getElementsByName, 一组 将NodeList转换为数组 apply 从数组中移除元素 filter 设置数组初始值 fill 文章目录 # Doks主题通过设置startLevel和endLevel限制ToC显示的标题。endLevel上限为4，startLevel一般从2开始 高亮的是ToC中的链接 高亮样式 # 设置颜色 加粗 过渡 暗色主题 assets/scss/common/_global.",content:"说明 # 设置高亮样式 css 使用Intersection Observer实现 JavaScript 文章目录设置 config/_default/markup.toml - startLevel 2 endLevel 3 另一个实现思路为Scrollspy 移植到Doks主题 便签 # - 文章目录滚动高亮 1. 为文章目录设置类 2. 高亮样式 3. 提供一种实现 高亮样式 当前标题底部加横线 滚动高亮 设置元素的父元素 滚动高亮 option和intersectionObserver的callback IntersectionObserver API 1. 添加观察元素: observe 2. intersectionRatio 3. target querySelectorAll用法 1. 获取有指定属性的元素: \u0026ldquo;a[target]\u0026rdquo; 2. 获取指定父元素的元素: \u0026ldquo;div \u0026gt; p\u0026rdquo; 3. 获取多个分类元素: \u0026ldquo;h2[id], h3[id]\u0026rdquo; 获取元素的方式 1. id: getElementById, 上下文要求是documnet 2. name: getElementsByName, 一组 将NodeList转换为数组 apply 从数组中移除元素 filter 设置数组初始值 fill 文章目录 # Doks主题通过设置startLevel和endLevel限制ToC显示的标题。endLevel上限为4，startLevel一般从2开始 高亮的是ToC中的链接 高亮样式 # 设置颜色 加粗 过渡 暗色主题 assets/scss/common/_global.scss .my-toc a.active { color: $primary; font-weight: 800; transition: all .25s ease-in-out } assets/scss/common/_dark.scss [data-dark-mode] .my-toc a.active { // color: $link-color-dark; color: $zdoc-highlight-dark; } 为ToC设置类 # layouts/partials/sidebar/docs-toc.html:23 \u0026lt;nav class=\u0026quot;my-toc\u0026quot;\u0026gt; {{ .TableOfContents }} \u0026lt;/nav\u0026gt; 进入判断 # document.addEventListener('DOMContentLoaded', () =\u0026gt; { const toc = document.querySelector('.my-toc'); if (!toc) return; // 后续处理 }); 文章目录标题 # 获取有类my-toc的元素的链接 const tocHeadings = toc.querySelectorAll('a'); 正文标题 # 只关注显示在文章目录的标题, 筛选时, 要求标题的下级链接有类anchor const headings = Array.apply(null, document.querySelectorAll('h2[id], h3[id]')).filter(function (value, index, arr) { return arr[index].querySelector('.anchor'); }); 将文章目录标题和正文标题关联 # 当二者标题数一致时, 认为一一对应, 设置标号; 否则就此结束 function addHeadingIdx(list) { let i = 0; list.forEach((item) =\u0026gt; { item.setAttribute('headingIdx', i++); }); } if (tocHeadings.length !== headings.length) return; addHeadingIdx(tocHeadings); addHeadingIdx(headings); 搭建交叉观察框架 # 触发条件：当标题的intersectionRatio变为threshold，或者不再为threshold时，对标题进行处理 const intersectionOptions = { threshold: 1.0 } 创建观察器 const headingObserver = new IntersectionObserver(headings =\u0026gt; { headings.forEach(heading =\u0026gt; { // 处理标题 }) }, intersectionOptions); 将正文标题添加到观察列表 headings.forEach((heading) =\u0026gt; { headingObserver.observe(heading); }); 为标题添加/移除高亮 # 标题的intersectionRatio满足阈值，isIntersecting为true，intersectionRatio不满足阈值，为false 根据isIntersecting更新标题高亮状态 新增高亮标题, 或者有多个标题高亮时移除高亮: 根据高亮状态刷新, 更新高亮标题个数 添加全局数组，保存标题高亮状态，初始值为false # let HeadingFlag; HeadingFlag = new Array(headings.length).fill(false); 添加变量，保存高亮标题个数, 初始值为0 # let HeadingCnt; HeadingCnt = 0; 进入观察器回调函数: 更新标题高亮状态; 新增高亮, 或者有多个标题高亮时移除高亮, 根据高亮状态设置标题，更新高亮个数 # function refreshHighlight() { HeadingCnt = 0; for (let i = 0; i \u0026lt; HeadingFlag.length; ++i) { if (HeadingFlag[i]) { ++HeadingCnt; document.querySelector(`.my-toc a[headingIdx=\u0026quot;${i}\u0026quot;]`).classList.add('active'); } else { document.querySelector(`.my-toc a[headingIdx=\u0026quot;${i}\u0026quot;]`).classList.remove('active'); } } } const idx = heading.target.getAttribute('headingIdx'); if ((HeadingFlag[idx] = heading.isIntersecting) || (HeadingCnt !== 1)) { refreshHighlight(); } 完整JavaScript代码 # assets/js/toc.js let HeadingFlag; let HeadingCnt; function addHeadingIdx(list) { let i = 0; list.forEach((item) =\u0026gt; { item.setAttribute('headingIdx', i++); }); } function refreshHighlight() { HeadingCnt = 0; for (let i = 0; i \u0026lt; HeadingFlag.length; ++i) { if (HeadingFlag[i]) { ++HeadingCnt; document.querySelector(`.my-toc a[headingIdx=\u0026quot;${i}\u0026quot;]`).classList.add('active'); } else { document.querySelector(`.my-toc a[headingIdx=\u0026quot;${i}\u0026quot;]`).classList.remove('active'); } } } document.addEventListener('DOMContentLoaded', () =\u0026gt; { const toc = document.querySelector('.my-toc'); if (!toc) return; const tocHeadings = toc.querySelectorAll('a'); const headings = Array.apply(null, document.querySelectorAll('h2[id], h3[id]')).filter(function (value, index, arr) { return arr[index].querySelector('.anchor'); }); if (tocHeadings.length !== headings.length) return; addHeadingIdx(tocHeadings); addHeadingIdx(headings); HeadingFlag = new Array(headings.length).fill(false); HeadingCnt = 0; const intersectionOptions = { threshold: 1.0 }; const headingObserver = new IntersectionObserver(headings =\u0026gt; { headings.forEach(heading =\u0026gt; { // console.log('ratio', heading.target.getAttribute('id'), heading.intersectionRatio, heading.isIntersecting, HeadingCnt); const idx = heading.target.getAttribute('headingIdx'); if ((HeadingFlag[idx] = heading.isIntersecting) || (HeadingCnt !== 1)) { refreshHighlight(); } }); }, intersectionOptions); headings.forEach((heading) =\u0026gt; { headingObserver.observe(heading); }); }); Doks主题执行JavaScript脚本 # 参照assets/highlight.js的执行 layouts/partials/footer/script-footer.html 10 {{ $toc := resources.Get \u0026quot;js/toc.js\u0026quot; -}} {{ $toc := $toc | js.Build -}} 86 \u0026lt;script src=\u0026quot;{{ $toc.RelPermalink }}\u0026quot; defer\u0026gt;\u0026lt;/script\u0026gt; 103 {{ $toc := $toc | minify | fingerprint \u0026quot;sha512\u0026quot; -}} 113 \u0026lt;script src=\u0026quot;{{ $toc.RelPermalink }}\u0026quot; integrity=\u0026quot;{{ $toc.Data.Integrity }}\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot; defer\u0026gt;\u0026lt;/script\u0026gt; "}),e.add({id:93,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/vscode/",title:"VSCode",description:"便签 # 使用clang-format 快捷键 # 操作 减小字体 Command\u0026ndash; 放大字体 Command-+ 文件内查找 Command-F 注释代码 Command-K Command-C 去注释 Command-K Command-U 头文件/源文件 切换 Option-O 打开首选项 Command-, 使用clang-format # 安装扩展C/C++，自动安装clang-format 保存文件时，应用格式 首选项 \u0026gt; Text Editor \u0026gt; Formatting，勾选 Format On Save ",content:"便签 # 使用clang-format 快捷键 # 操作 减小字体 Command\u0026ndash; 放大字体 Command-+ 文件内查找 Command-F 注释代码 Command-K Command-C 去注释 Command-K Command-U 头文件/源文件 切换 Option-O 打开首选项 Command-, 使用clang-format # 安装扩展C/C++，自动安装clang-format 保存文件时，应用格式 首选项 \u0026gt; Text Editor \u0026gt; Formatting，勾选 Format On Save "}),e.add({id:94,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E7%BB%84%E4%BB%B6/%E9%AA%A8%E9%AA%BC%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%84%E4%BB%B6/",title:"骨骼网格体组件",description:"SkeletalMesh USkeletalMeshComponent # UE_5.1/Engine/Source/Runtime/Engine/Classes/Components/SkeletalMeshComponent.h 骨骼网格体外形是多边形，内里由具有层级结构的骨骼组成，因此，可以为骨骼网格体编排动画 可以是人，可以是物 可以为骨骼网格体绑定模型 USkeletalMeshComponent和UStaticMeshComponent拥有共同基类UMeshComponent UMeshComponent派生自UPrimitiveComponent, UPrimitiveComponent派生自USceneComponent, 而USceneComponent具有变换属性 ACharacter自带SkeletalMesh组件 头文件 # #include \u0026quot;Components/SkeletalMeshComponent.h\u0026quot; 相关函数 # - ACharacter::GetMesh 获取Character的SkeletalMesh组件 ",content:"SkeletalMesh USkeletalMeshComponent # UE_5.1/Engine/Source/Runtime/Engine/Classes/Components/SkeletalMeshComponent.h 骨骼网格体外形是多边形，内里由具有层级结构的骨骼组成，因此，可以为骨骼网格体编排动画 可以是人，可以是物 可以为骨骼网格体绑定模型 USkeletalMeshComponent和UStaticMeshComponent拥有共同基类UMeshComponent UMeshComponent派生自UPrimitiveComponent, UPrimitiveComponent派生自USceneComponent, 而USceneComponent具有变换属性 ACharacter自带SkeletalMesh组件 头文件 # #include \u0026quot;Components/SkeletalMeshComponent.h\u0026quot; 相关函数 # - ACharacter::GetMesh 获取Character的SkeletalMesh组件 "}),e.add({id:95,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2/character%E7%B1%BB/",title:"Character类",description:"派生自APawn，实现了角色的动作(motion)，动画(animation)和物理交互(physical interaction) ACharacter # 构成 # - 构造函数 BeginPlay 出现在场景中调用 Tick 每秒调用 SetupPlayerInputComponent 键位绑定 ACharacter::ACharacter # 构造函数 设置组件类型(派生类or基类) ACharacter::GetMesh # 获取Character的SkeletalMesh组件 访问Controller对象 # 访问Controller对象 受控于AI控制器 # 受控于AI控制器 ",content:"派生自APawn，实现了角色的动作(motion)，动画(animation)和物理交互(physical interaction) ACharacter # 构成 # - 构造函数 BeginPlay 出现在场景中调用 Tick 每秒调用 SetupPlayerInputComponent 键位绑定 ACharacter::ACharacter # 构造函数 设置组件类型(派生类or基类) ACharacter::GetMesh # 获取Character的SkeletalMesh组件 访问Controller对象 # 访问Controller对象 受控于AI控制器 # 受控于AI控制器 "}),e.add({id:96,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/npc%E8%A1%8C%E4%B8%BA/npc%E5%89%8D%E8%BF%9B%E5%90%91%E9%87%8F%E5%8F%98%E5%8C%96%E6%97%B6%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5%E6%97%8B%E8%BD%AC%E8%BF%87%E6%B8%A1/",title:"NPC前进向量变化时自动插入旋转过渡",description:"蓝图 # BP_STUAICharacter 游戏角色在水平方向旋转不再通过控制器控制 游戏角色旋转由控制器根据预期自行实现; 设置旋转插入比例 C++ # STUAICharacter FRotator中分量的顺序依次为: Pitch Y , Yaw Z , Roll X #include \u0026quot;GameFramework/CharacterMovementComponent.h\u0026quot; // ASTUAICharacter bUseControllerRotationYaw = false; if (GetCharacterMovement()) { GetCharacterMovement()-\u0026gt;bUseControllerDesiredRotation = true; GetCharacterMovement()-\u0026gt;RotationRate = FRotator(0.0f, 200.0f, 0.0f); } ",content:"蓝图 # BP_STUAICharacter 游戏角色在水平方向旋转不再通过控制器控制 游戏角色旋转由控制器根据预期自行实现; 设置旋转插入比例 C++ # STUAICharacter FRotator中分量的顺序依次为: Pitch Y , Yaw Z , Roll X #include \u0026quot;GameFramework/CharacterMovementComponent.h\u0026quot; // ASTUAICharacter bUseControllerRotationYaw = false; if (GetCharacterMovement()) { GetCharacterMovement()-\u0026gt;bUseControllerDesiredRotation = true; GetCharacterMovement()-\u0026gt;RotationRate = FRotator(0.0f, 200.0f, 0.0f); } "}),e.add({id:97,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%9C%A8c++%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E7%B1%BB%E5%9E%8B/",title:"在C++中创建任务类型",description:"说明 # AI Task 在C++中生成随机点, 让NPC移动到随机生成位置 创建任务类型 # 创建蓝图任务类型的方法 BT_STUCharacter 点击 New Task C++ - 基类 BTTaskNode 路径 AI/Tasks/ Public STUNextLocationTask ShootThemUp: ShootThemUp.Build.cs 修改头文件搜索路径 PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon/Components\u0026quot;, \u0026quot;ShootThemUp/Public/AI\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Tasks\u0026quot; }); 添加依赖模块GameplayTasks和NavigationSystem PublicDependencyModuleNames.AddRange(new string[] { \u0026quot;Core\u0026quot;, \u0026quot;CoreUObject\u0026quot;, \u0026quot;Engine\u0026quot;, \u0026quot;InputCore\u0026quot;, \u0026quot;Niagara\u0026quot;, \u0026quot;PhysicsCore\u0026quot;, \u0026quot;GameplayCameras\u0026quot;, \u0026quot;GameplayTasks\u0026quot;, \u0026quot;NavigationSystem\u0026quot; }); 实现任务: 在给定半径圆形范围内生成随机点并设置变量 # 添加构造函数 ShootThemUp: AI/Tasks/STUNextLocationTask.h public USTUNextLocationTask(); 执行任务时调用ExecuteTask 覆写 ShootThemUp: AI/Tasks/STUNextLocationTask.h public virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory) override; 添加属性 半径和黑板变量 ShootThemUp: AI/Tasks/STUNextLocationTask.",content:"说明 # AI Task 在C++中生成随机点, 让NPC移动到随机生成位置 创建任务类型 # 创建蓝图任务类型的方法 BT_STUCharacter 点击 New Task C++ - 基类 BTTaskNode 路径 AI/Tasks/ Public STUNextLocationTask ShootThemUp: ShootThemUp.Build.cs 修改头文件搜索路径 PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon/Components\u0026quot;, \u0026quot;ShootThemUp/Public/AI\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Tasks\u0026quot; }); 添加依赖模块GameplayTasks和NavigationSystem PublicDependencyModuleNames.AddRange(new string[] { \u0026quot;Core\u0026quot;, \u0026quot;CoreUObject\u0026quot;, \u0026quot;Engine\u0026quot;, \u0026quot;InputCore\u0026quot;, \u0026quot;Niagara\u0026quot;, \u0026quot;PhysicsCore\u0026quot;, \u0026quot;GameplayCameras\u0026quot;, \u0026quot;GameplayTasks\u0026quot;, \u0026quot;NavigationSystem\u0026quot; }); 实现任务: 在给定半径圆形范围内生成随机点并设置变量 # 添加构造函数 ShootThemUp: AI/Tasks/STUNextLocationTask.h public USTUNextLocationTask(); 执行任务时调用ExecuteTask 覆写 ShootThemUp: AI/Tasks/STUNextLocationTask.h public virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory) override; 添加属性 半径和黑板变量 ShootThemUp: AI/Tasks/STUNextLocationTask.h protected UPROPERTY(EditAnywhere, BlueprintReadWrite) float Radius = 1000.0f; UPROPERTY(EditAnywhere, BlueprintReadWrite) FBlackboardKeySelector AimLocationKey; 在构造函数中设置任务节点名 ShootThemUp: AI/Tasks/STUNextLocationTask.cpp USTUNextLocationTask::USTUNextLocationTask() { NodeName = \u0026quot;Next Location\u0026quot;; } 生成随机点并写入黑板变量 GetRandomReachablePointInRadius在游戏角色可以去到的nav mesh范围内计算随机点, 该函数在覆盖范围实现路径搜索算法 如果找到该点, 游戏角色一定能从所处位置去到该点 给出搜索中心点, 搜索半径, 存放点的变量 ShootThemUp: AI/Tasks/STUNextLocationTask.cpp #include \u0026quot;BehaviorTree/BlackboardComponent.h\u0026quot; #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;NavigationSystem.h\u0026quot; EBTNodeResult::Type USTUNextLocationTask::ExecuteTask(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory) { const auto Controller = OwnerComp.GetAIOwner(); const auto Blackboard = OwnerComp.GetBlackboardComponent(); if (!Controller || !Blackboard) return EBTNodeResult::Failed; const auto Pawn = Controller-\u0026gt;GetPawn(); if (!Pawn) return EBTNodeResult::Failed; const auto NavSys = UNavigationSystemV1::GetCurrent(Pawn); if (!NavSys) return EBTNodeResult::Failed; FNavLocation NavLocation; const auto Found = NavSys-\u0026gt;GetRandomReachablePointInRadius(Pawn-\u0026gt;GetActorLocation(), Radius, NavLocation); if (!Found) return EBTNodeResult::Failed; Blackboard-\u0026gt;SetValueAsVector(AimLocationKey.SelectedKeyName, NavLocation.Location); return EBTNodeResult::Succeeded; } 查看 # 添加变量AimLocation BB_STUCharacter 更新行为树 BT_STUCharacter \u0026gt; 生成随机点 \u0026gt; 等待两秒 \u0026gt; 去到随机点; 循环 黑板变量绑定 移动到随机点 移除上节在指定点往返逻辑 BP_STUAIController 人为干预: 设置ExecuteTask返回Failed # BT_STUCharacter 添加任务: FinishedWithResult, 设置结果为Failed; 游戏角色停留在Wait节点 移除FinishedWithResult节点 "}),e.add({id:98,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/",title:"物理材质",description:"说明 # 实现: 与不同材质的表面发生碰撞时, 产生不同的撞击特效 三类物理材质: 地面和楼梯, 游戏角色身体部分, 游戏角色头部 也是击中游戏角色不同部位造成不同伤害数值的另一种实现 为网格体设置物理材质 Physical Material 获取撞击物体的物理材质, 生成对应特效 物理材质 # 如果对物体使能物理仿真, 其会根据设置与其他物体互动 设置物体的物理特性, 对应一种表面类型 通过物理材质, 创建表面类型, 根据撞击物体的表面类型, 产生对应特效 目前只使用物理材质来定义表面类型, 而不用于物理仿真 创建多种特效 # 未设定当前物理材质对应的特效时, 生成默认特效 重命名NS_BaseImpact为NS_DefaultImpact, 设置颜色为黑色 按下 Ctrl-D 复制NS_DefaultImpact, 命名为NS_GroundImpact、NS_HeadImpact和NS_BodyImpact 设置NS_GroundImpact 设置为绿色 设置NS_HeadImpact 设置为暗红色 设置粒子数 设置NS_BodyImpact 设置为红色 创建物理材质 # 创建文件夹 Content/PhysMaterials 选择类, 命名为PhysMat_Ground 复制PhysMat_Ground, 命名为PhysMat_Head和PhysMat_Body 为物体设置物理材质 # 物理材质只能应用到网格体, 而地板和楼梯使用几何体笔刷构造, 并不是网格体. 我们可以将其转换为网格体 目前, 击中地板和楼梯时, 生成默认特效 添加几何网格体 Place Actors \u0026gt; Shapes \u0026gt; Cube , 设置物理材质为PhysMat_Ground 为游戏角色设置物理材质 # 打开 Content \u0026gt; ExternalContent \u0026gt; Animation \u0026gt; Characters \u0026gt; HeroTPP \u0026gt; HeroTPP_Physics 为头部设置物理材质 为身体其他部位挨个设置物理材质 获取物理材质信息生成对应类型特效 # 添加依赖模块PhysicsCore # ShootThemUp: ShootThemUp.",content:`说明 # 实现: 与不同材质的表面发生碰撞时, 产生不同的撞击特效 三类物理材质: 地面和楼梯, 游戏角色身体部分, 游戏角色头部 也是击中游戏角色不同部位造成不同伤害数值的另一种实现 为网格体设置物理材质 Physical Material 获取撞击物体的物理材质, 生成对应特效 物理材质 # 如果对物体使能物理仿真, 其会根据设置与其他物体互动 设置物体的物理特性, 对应一种表面类型 通过物理材质, 创建表面类型, 根据撞击物体的表面类型, 产生对应特效 目前只使用物理材质来定义表面类型, 而不用于物理仿真 创建多种特效 # 未设定当前物理材质对应的特效时, 生成默认特效 重命名NS_BaseImpact为NS_DefaultImpact, 设置颜色为黑色 按下 Ctrl-D 复制NS_DefaultImpact, 命名为NS_GroundImpact、NS_HeadImpact和NS_BodyImpact 设置NS_GroundImpact 设置为绿色 设置NS_HeadImpact 设置为暗红色 设置粒子数 设置NS_BodyImpact 设置为红色 创建物理材质 # 创建文件夹 Content/PhysMaterials 选择类, 命名为PhysMat_Ground 复制PhysMat_Ground, 命名为PhysMat_Head和PhysMat_Body 为物体设置物理材质 # 物理材质只能应用到网格体, 而地板和楼梯使用几何体笔刷构造, 并不是网格体. 我们可以将其转换为网格体 目前, 击中地板和楼梯时, 生成默认特效 添加几何网格体 Place Actors \u0026gt; Shapes \u0026gt; Cube , 设置物理材质为PhysMat_Ground 为游戏角色设置物理材质 # 打开 Content \u0026gt; ExternalContent \u0026gt; Animation \u0026gt; Characters \u0026gt; HeroTPP \u0026gt; HeroTPP_Physics 为头部设置物理材质 为身体其他部位挨个设置物理材质 获取物理材质信息生成对应类型特效 # 添加依赖模块PhysicsCore # ShootThemUp: ShootThemUp.Build.cs PublicDependencyModuleNames.AddRange(new string[] { \u0026quot;Core\u0026quot;, \u0026quot;CoreUObject\u0026quot;, \u0026quot;Engine\u0026quot;, \u0026quot;InputCore\u0026quot;, \u0026quot;Niagara\u0026quot;, \u0026quot;PhysicsCore\u0026quot; }); 发生碰撞时, 传递物理材质信息 # FHitResult结构体的PhysMaterial字段存放物理材质信息, 其类型为TWeakObjectPtr, 是Weak指针在虚幻引擎的内部实现 同样, 使用前需检查有效性, 使用时通过Get 使能标志位, 在FHitResult结构体中保存物理材质信息 步枪 # ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeHit CollisionParams.bReturnPhysicalMaterial = true; 榴弹 # ShootThemUp: Weapon/STUProjectile.cpp // ASTUProjectile CollisionComponent-\u0026gt;bReturnMaterialOnMove = true; 撞击特效组件: 保存物理材质和特效类型的对应关系 # 将Effect属性重命名为DefaultEffect, 作为默认特效类型 使用TMap类型保存对应关系 # 关联容器类型Map在虚幻引擎的内部实现 ShootThemUp: Weapon/Components/STUWeaponFXComponent.h protected class UPhysicalMaterial; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) TMap\u0026lt;UPhysicalMaterial*, UNiagaraSystem*\u0026gt; EffectsMap; 发生碰撞时, 查询特效类型并使用 # ShootThemUp: Weapon/Components/STUWeaponFXComponent.cpp #include \u0026quot;PhysicalMaterials/PhysicalMaterial.h\u0026quot; // PlayImpactFX auto Effect = DefaultEffect; if (Hit.PhysMaterial.IsValid()) { const auto PhysMat = Hit.PhysMaterial.Get(); if (EffectsMap.Contains(PhysMat)) { Effect = EffectsMap[PhysMat]; } } 查看 # 设置步枪和榴弹的默认特效为NS_DefaultImpact 步枪 # 设置物理材质和特效的对应关系 - PhysMat_Body NS_BodyImpact PhysMat_Head NS_HeadImpact PhysMat_Ground NS_GroundImpact 拷贝设置小技巧 右键EffectsMap, 选择Copy; 去到另一个EffectsMap, 右键粘贴 榴弹 # 新建Niagara粒子系统资产用于榴弹 # 如果模板中有 Simple Explosion , 使用现有模板 否则, 选择现有发射器 依次添加 OmnidirectionalBurst UpwardMeshBurst SimpleSpriteBurst 命名为NS_ProjectileImpact 查看单个发射器效果 # 点击图标 设置速度方向 # Add Velocity from Point \u0026gt; Origin Offset , 对调X和Z的值 如果使用现有发射器创建粒子系统
OmnidirectionalBurst Velocity Mode : From Point Velocity Speed : Random Range Float; Minimum = 350, Maximum = 550 Offet \u0026gt; Origin Offset : X = -24, Z = 0 UpwardMeshBurst Velocity Mode : In Cone Velocity Speed : Random Range Float; Minimum = 100, Maximum = 400 Cone \u0026gt; Axis : X = 1, Z = 0 Cone \u0026gt; Angle : 66 SimpleSpriteBurst Velocity Mode : From Point Velocity Speed : Random Range Float; Minimum = 50, Maximum = 200 Offet \u0026gt; Origin Offset : X = -85, Z = 0 设置榴弹默认特效为NS_ProjectileImpact # 添加插件的方法 # Edit \u0026gt; Plugin 勾选NiagaraFluids, 重启 `}),e.add({id:99,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A1%A5%E7%BB%99/%E5%BC%B9%E8%8D%AF%E8%A1%A5%E7%BB%99/",title:"弹药补给",description:"说明 # 弹药补给包含2个参数: 武器类型和弹匣数 弹药补给逻辑 # 添加属性 # ShootThemUp: Pickups/STUAmmoPickup.h protected class ASTUBaseWeapon; UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = \u0026quot;1.0\u0026quot;, ClampMax = \u0026quot;10.0\u0026quot;)) int32 ClipsAmount = 10; UPROPERTY(EditAnywhere, BlueprintReadWrite) TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponType; 添加接口: 若非死亡跌倒或组件不可寻, 调用武器组件接口 # ShootThemUp: Pickups/STUAmmoPickup.cpp #include \u0026quot;Components/STUHealthComponent.h\u0026quot; #include \u0026quot;Components/STUWeaponComponent.h\u0026quot; #include \u0026quot;GameFramework/Pawn.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; // GivePickupTo const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(PlayerPawn); if (!HealthComponent || HealthComponent-\u0026gt;IsDead()) return false; const auto WeaponComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUWeaponComponent\u0026gt;(PlayerPawn); if (!WeaponComponent) return false; return WeaponComponent-\u0026gt;TryToAddAmmo(WeaponType, ClipsAmount); 武器组件逻辑 # 添加接口: 调用对应类型武器接口 ShootThemUp: Components/STUWeaponComponent.",content:"说明 # 弹药补给包含2个参数: 武器类型和弹匣数 弹药补给逻辑 # 添加属性 # ShootThemUp: Pickups/STUAmmoPickup.h protected class ASTUBaseWeapon; UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = \u0026quot;1.0\u0026quot;, ClampMax = \u0026quot;10.0\u0026quot;)) int32 ClipsAmount = 10; UPROPERTY(EditAnywhere, BlueprintReadWrite) TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponType; 添加接口: 若非死亡跌倒或组件不可寻, 调用武器组件接口 # ShootThemUp: Pickups/STUAmmoPickup.cpp #include \u0026quot;Components/STUHealthComponent.h\u0026quot; #include \u0026quot;Components/STUWeaponComponent.h\u0026quot; #include \u0026quot;GameFramework/Pawn.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; // GivePickupTo const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(PlayerPawn); if (!HealthComponent || HealthComponent-\u0026gt;IsDead()) return false; const auto WeaponComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUWeaponComponent\u0026gt;(PlayerPawn); if (!WeaponComponent) return false; return WeaponComponent-\u0026gt;TryToAddAmmo(WeaponType, ClipsAmount); 武器组件逻辑 # 添加接口: 调用对应类型武器接口 ShootThemUp: Components/STUWeaponComponent.h public bool TryToAddAmmo(TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponType, int32 ClipsAmount); ShootThemUp: Components/STUWeaponComponent.cpp bool USTUWeaponComponent::TryToAddAmmo(TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponType, int32 ClipsAmount) { for (const auto Weapon : Weapons) { if (Weapon \u0026amp;\u0026amp; Weapon-\u0026gt;IsA(WeaponType)) { return Weapon-\u0026gt;TryToAddAmmo(ClipsAmount); } } return false; } 武器逻辑 # ShootThemUp: Weapon/STUBaseWeapon.h // public bool TryToAddAmmo(int32 ClipsAmount); // protected bool IsAmmoFull() const; ShootThemUp: Weapon/STUBaseWeapon.cpp bool ASTUBaseWeapon::IsAmmoFull() const { return CurrentAmmo.Clips == DefaultAmmo.Clips \u0026amp;\u0026amp; // CurrentAmmo.Bullets == DefaultAmmo.Bullets; } bool ASTUBaseWeapon::TryToAddAmmo(int32 ClipsAmount) { if (CurrentAmmo.Infinite || IsAmmoFull() || ClipsAmount \u0026lt;= 0) return false; if (IsAmmoEmpty()) { UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Ammo was empty!\u0026quot;)); CurrentAmmo.Clips = FMath::Clamp(CurrentAmmo.Clips + ClipsAmount, 0, DefaultAmmo.Clips + 1); OnClipEmpty.Broadcast(); } else if (CurrentAmmo.Clips \u0026lt; DefaultAmmo.Clips) { if (CurrentAmmo.Clips + ClipsAmount \u0026lt;= DefaultAmmo.Clips) { CurrentAmmo.Clips += ClipsAmount; UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Clips were added\u0026quot;)); } else { CurrentAmmo.Clips = DefaultAmmo.Clips; CurrentAmmo.Bullets = DefaultAmmo.Bullets; UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Ammo is full now\u0026quot;)); } } else { CurrentAmmo.Bullets = DefaultAmmo.Bullets; UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Bullets were added\u0026quot;)); } return true; } 查看 # 将榴弹弹匣可以容纳的榴弹数改为2 BP_STULauncherWeapon 设置弹药补给的武器类型为 BP_STULauncherWeapon BP_STUAmmoPickup 初始状态, 无法拾取弹药补给 射击一次后, 提示榴弹增加 打掉一个弹匣后, 提示弹药装满 打空后, 提示弹药为空 再次打空后, 切换武器, 拾取弹药装备, 切换回发射器, 弹药信息显示不正确 解决问题 # 装弹时, 只对当前武器进行操作 委托定义中, 增加一个传参 # STUCoreTypes.h class ASTUBaseWeapon; DECLARE_MULTICAST_DELEGATE_OneParam(FOnClipEmptySignature, ASTUBaseWeapon*); 修改调用 # ShootThemUp: Weapon/STUBaseWeapon.cpp // DecreaseAmmo OnClipEmpty.Broadcast(this); // TryToAddAmmo OnClipEmpty.Broadcast(this); 修改声明和定义 # ShootThemUp: Components/STUWeaponComponent.h void OnEmptyClip(ASTUBaseWeapon *AmmoEmptyWeapon); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::OnEmptyClip(ASTUBaseWeapon *AmmoEmptyWeapon) { if (!AmmoEmptyWeapon) return; if (CurrentWeapon == AmmoEmptyWeapon) { ChangeClip(); } else { for (const auto Weapon : Weapons) { if (Weapon == AmmoEmptyWeapon) { Weapon-\u0026gt;ChangeClip(); } } } } "}),e.add({id:100,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%99%9A%E5%B9%BB%E8%BF%90%E5%8A%A8%E5%9B%BE%E8%A1%A8/%E5%9C%A8%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6%E7%BB%98%E5%88%B6%E7%9E%84%E5%87%86%E5%8D%81%E5%AD%97/",title:"在窗口部件绘制瞄准十字",description:"概览 # 获取并导入素材 在窗口部件中添加瞄准十字图片 窗口部件实现接口返回当前武器图片 在窗口部件中实现逻辑加载图片 获取素材 # ShooterGame 选中Conent/UI/HUD/HUDMain 右键 裁剪武器图标和对应的十字瞄准线, 命名并保存到Image文件夹 导入素材 # ShootThemUp 将Image文件夹拖入到Content/UI下, 虚幻引擎自动将图片转换成资产 所有的外部资源, 如图片, 音频, 导入时均会被转换为资产格式. 这样, 在不同平台打包时更便利 本节课使用瞄准十字图片, 武器图标供下节课使用 在窗口部件中添加瞄准十字图片 # WBP_PlayerHUD 从选项板中, 将图片元素拖入到视口 # Palette \u0026gt; Image 可以在视口中调整图片大小 选择测试图片 # Details \u0026gt; Appearance \u0026gt; Brush \u0026gt; Image 选择RifleCrossHair 使用图片原大小 # 勾选 Details \u0026gt; Slot \u0026gt; Size To Content 使图片居中 # 添加锚 Details \u0026gt; Slot(Canvas Panel Slot) \u0026gt; Anchors , 选择居中项 设置图片位置 Details \u0026gt; Slot , 设置Position X = Position Y = 0 设置对齐 Details \u0026gt; Slot , 设置Alignment X = Y = 0.",content:`概览 # 获取并导入素材 在窗口部件中添加瞄准十字图片 窗口部件实现接口返回当前武器图片 在窗口部件中实现逻辑加载图片 获取素材 # ShooterGame 选中Conent/UI/HUD/HUDMain 右键 裁剪武器图标和对应的十字瞄准线, 命名并保存到Image文件夹 导入素材 # ShootThemUp 将Image文件夹拖入到Content/UI下, 虚幻引擎自动将图片转换成资产 所有的外部资源, 如图片, 音频, 导入时均会被转换为资产格式. 这样, 在不同平台打包时更便利 本节课使用瞄准十字图片, 武器图标供下节课使用 在窗口部件中添加瞄准十字图片 # WBP_PlayerHUD 从选项板中, 将图片元素拖入到视口 # Palette \u0026gt; Image 可以在视口中调整图片大小 选择测试图片 # Details \u0026gt; Appearance \u0026gt; Brush \u0026gt; Image 选择RifleCrossHair 使用图片原大小 # 勾选 Details \u0026gt; Slot \u0026gt; Size To Content 使图片居中 # 添加锚 Details \u0026gt; Slot(Canvas Panel Slot) \u0026gt; Anchors , 选择居中项 设置图片位置 Details \u0026gt; Slot , 设置Position X = Position Y = 0 设置对齐 Details \u0026gt; Slot , 设置Alignment X = Y = 0.5 测试结果 # 窗口部件类实现接口返回武器图片 # 添加数据结构: 存放相应图片 # 存放武器对应的图标和瞄准十字 使用 UTexture2D 类型保存纹理 CoreTypes.h class UTexture2D; // weapon USTRUCT(BlueprintType) struct FWeaponUIData { GENERATED_USTRUCT_BODY() UPROPERTY(EDitDefaultsOnly, BlueprintReadWrite) UTexture2D *MainIcon; UPROPERTY(EDitDefaultsOnly, BlueprintReadWrite) UTexture2D *CrossHairIcon; }; 添加数据成员: 存放武器相关图片 # ShootThemUp: Weapon/STUBaseWeapon.h protected UPROPERTY(EDitDefaultsOnly, BlueprintReadWrite) FWeaponUIData UIData; 添加接口: 获取武器相关图片 # ShootThemUp: Weapon/STUBaseWeapon.h public FWeaponUIData GetUIData() const { return UIData; } 添加接口: 获取当前武器相关图片 # Wrapper Function ShootThemUp: Components/STUWeaponComponent.h pulic bool GetWeaponUIData(FWeaponUIData \u0026amp;UIData) const; ShootThemUp: Components/STUWeaponComponent.cpp bool USTUWeaponComponent::GetWeaponUIData(FWeaponUIData \u0026amp;UIData) const { if (CurrentWeapon) { UIData = CurrentWeapon-\u0026gt;GetUIData(); return true; } return false; } 添加接口: 窗口部件类提供接口获取武器图片信息 # ShootThemUp: UI/STUPlayerHUDWidget.h public #include \u0026quot;STUCoreTypes.h\u0026quot; UFUNCTION(BlueprintCallable) bool GetWeaponUIData(FWeaponUIData \u0026amp;UIData) const; ShootThemUp: UI/STUPlayerHUDWidget.cpp #include \u0026quot;Components/STUWeaponComponent.h\u0026quot; bool USTUPlayerHUDWidget::GetWeaponUIData(FWeaponUIData \u0026amp;UIData) const { const auto Player = GetOwningPlayerPawn(); if (!Player) return false; const auto Component = Player-\u0026gt;GetComponentByClass(USTUWeaponComponent::StaticClass()); const auto WeaponComponent = Cast\u0026lt;USTUWeaponComponent\u0026gt;(Component); if (!WeaponComponent) return false; return WeaponComponent-\u0026gt;GetWeaponUIData(UIData); } 屏蔽之前绘制瞄准十字逻辑 # ShootThemUp: UI/STUGameHUD.cpp 屏蔽DrawHUD中对DrawCrossHair的调用 设置瞄准图片 # 配置步枪和发射器图片 # BP_STURifleWeapon BP_STULauncherWeapon 获取瞄准十字图片 # WBP_PlayerHUD 添加函数: 获取瞄准十字图片 # Image \u0026gt; Details \u0026gt; Brush \u0026gt; Bind \u0026gt; Create Binding 重命名为 Get Crosshair Image 添加节点: 获取武器图片 # 展开UIData针脚 添加节点: 根据返回值做不同处理 # 空白处左键同时按下 B 输入来自 GetWeaponUIData 返回值 添加节点: 绘制图片 # 从 Return Node 的 Return Value 出发, 添加 Widget \u0026gt; Make Slate Bruch 设置图片
从 GetWeaponUIData \u0026gt; UIData CrossHair Icon 到 MakeSlatBrush \u0026gt; Image 设置图片绘制大小为图片原大小
添加节点: 创建Vector2D
从 MakeSlatBruch \u0026gt; ImageSize 出发, 添加 MakeVector2D 设置数组
从 GetWeaponUIData \u0026gt; UIData CrossHair Icon 出发, 添加 Rendering \u0026gt; Texture \u0026gt; GetSizeX和GetSizeY 组合成Vector2D GetSizeX和GetSizeY返回整数, 自动转换为浮点数 完整处理 # 查看 # 步枪瞄准十字 发射器瞄准十字 角色死亡时, 瞄准十字变为方块, 此时未获取到图片 调节光线 # 4.27 World outliner \u0026gt; Sky Sphere \u0026gt; Details Default \u0026gt; Directional Light Actor \u0026gt; Clear Override Settings \u0026gt; Sun Height = -1 `}),e.add({id:101,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/which-key/",title:"which-key",description:"命令提示 which-key-安装 # (use-package which-key :ensure t :config (which-key-mode)) ",content:"命令提示 which-key-安装 # (use-package which-key :ensure t :config (which-key-mode)) "}),e.add({id:102,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E4%BD%BF%E7%94%A8emacs%E5%81%9A%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/",title:"使用Emacs做视频笔记",description:"需求 # 有尝试使用Logseq和Obsidian做视频笔记，结果不太满意，不过弄清楚了需求 - 在笔记页面控制视频的暂停，前进，后退 播放器能加载字幕，能设置屏幕大小(全屏) 在笔记页面添加时间戳 从时间戳播放视频 说明 # - 播放器 mpv 插件 emms 播放器和Emacs间的接口：控制播放器，获取相关参数 插件 pretty-hydra 自定义快捷键菜单 自定义函数 打时间戳，跳转 时间戳样式 # 无! ![[timestamp:file.mp4#00:29][name]] 需设置emms默认播放路径 # ;; (setq my/movie-path \u0026quot;path/to/movie\u0026quot;) 需设置视频根目录 # ;; (setq my/video-path \u0026quot;path/to/video\u0026quot;) 安装emms # emms-安装 安装pretty-hydra # pretty-hydra-安装 插入时间戳 # (defun my/insert-timestamp() (interactive) (let ((desc (read-string \u0026quot;Description: \u0026quot;))) (setq my/mpv-current-file nil) (setq my/mpv-timestamp nil) (emms-player-mpv-ipc-req-send '(get_property path) #'(lambda (ret err) (unless err (setq my/mpv-current-file (file-relative-name ret my/video-path)) ) ) ) (emms-player-mpv-ipc-req-send '(get_property time-pos) #'(lambda (ret err) (unless err (setq my/mpv-timestamp ret) ) ) ) (sleep-for 0.",content:"需求 # 有尝试使用Logseq和Obsidian做视频笔记，结果不太满意，不过弄清楚了需求 - 在笔记页面控制视频的暂停，前进，后退 播放器能加载字幕，能设置屏幕大小(全屏) 在笔记页面添加时间戳 从时间戳播放视频 说明 # - 播放器 mpv 插件 emms 播放器和Emacs间的接口：控制播放器，获取相关参数 插件 pretty-hydra 自定义快捷键菜单 自定义函数 打时间戳，跳转 时间戳样式 # 无! ![[timestamp:file.mp4#00:29][name]] 需设置emms默认播放路径 # ;; (setq my/movie-path \u0026quot;path/to/movie\u0026quot;) 需设置视频根目录 # ;; (setq my/video-path \u0026quot;path/to/video\u0026quot;) 安装emms # emms-安装 安装pretty-hydra # pretty-hydra-安装 插入时间戳 # (defun my/insert-timestamp() (interactive) (let ((desc (read-string \u0026quot;Description: \u0026quot;))) (setq my/mpv-current-file nil) (setq my/mpv-timestamp nil) (emms-player-mpv-ipc-req-send '(get_property path) #'(lambda (ret err) (unless err (setq my/mpv-current-file (file-relative-name ret my/video-path)) ) ) ) (emms-player-mpv-ipc-req-send '(get_property time-pos) #'(lambda (ret err) (unless err (setq my/mpv-timestamp ret) ) ) ) (sleep-for 0.1) (when (and my/mpv-timestamp my/mpv-current-file) (insert (format (concat \u0026quot;[[\u0026quot; \u0026quot;timestamp:%s#%d][时间戳:%s]]\u0026quot;) my/mpv-current-file my/mpv-timestamp desc)) (message \u0026quot;Add timestamp %s#%d success!\u0026quot; my/mpv-current-file my/mpv-timestamp) ) (unless (and my/mpv-timestamp my/mpv-current-file) (message \u0026quot;Fail to insert timestamp!\u0026quot;) ) ) ) (global-set-key (kbd \u0026quot;C-c e i\u0026quot;) 'my/insert-timestamp) 时间戳跳转 # (defun my/emms-player-start-hook () ;; (emms-pause) (emms-seek-to my/emms-timestamp) (remove-hook 'emms-player-started-hook 'my/emms-player-start-hook)) (defun my/seek-to-timestamp () (interactive) (when (search-backward (concat \u0026quot;[[\u0026quot; \u0026quot;timestamp:\u0026quot;) nil t) (when (re-search-forward (rx \u0026quot;[[\u0026quot; \u0026quot;timestamp:\u0026quot; (group (0+ (not \u0026quot;#\u0026quot;))) \u0026quot;#\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1))))) (setq my/emms-timestamp (string-join (mapcar #'string (match-string 2)))) (if emms-player-playing-p (emms-stop)) (add-hook 'emms-player-started-hook 'my/emms-player-start-hook) (emms-player-start (emms-track 'file (concat my/video-path \u0026quot;/\u0026quot; file))) ;; (setq track (emms-track 'file (concat my/video-path \u0026quot;/\u0026quot; file))) ;; (emms-player-start track) ) ) ) ) (global-set-key (kbd \u0026quot;C-c e g\u0026quot;) 'my/seek-to-timestamp) "}),e.add({id:103,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/chrome/",title:"Chrome",description:"开发者工具 # F12 设置页面布局 查看日志 查看元素信息 跟踪事件 # 开始Record 停止 页面滚动事件 文章目录滚动 ",content:"开发者工具 # F12 设置页面布局 查看日志 查看元素信息 跟踪事件 # 开始Record 停止 页面滚动事件 文章目录滚动 "}),e.add({id:104,href:"/docs/build-blog/%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E8%B7%9F%E9%9A%8F%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E6%BB%9A%E5%8A%A8/",title:"文章目录跟随文章内容滚动",description:"说明 # 监听滚动事件, 触发定时器, 到时实现文章目录滚动跟随 浏览器支持 - docs-toc scrollTop my-toc scrollTop 文章目录跳转 Safari O X - Firefox O X - Chrome O O docs-toc需要定时器, 延时要求大于文章目录跳转最大耗时 滚动监听 # window添加事件监听 window.addEventListener('scroll', () =\u0026gt; { // 处理 }); window注册滚动处理 window.onscroll = function () { // 处理 }; 进入判断 # document.addEventListener('DOMContentLoaded', () =\u0026gt; { const myToc = document.querySelector('.my-toc'); const fullToc = document.querySelector('.docs-toc'); if (!myToc || !fullToc) return; // 后续处理 }); 滚动计算 # 为标题排序, 厘清高亮标题在文章目录中的位置 # let i = 0; myToc.",content:"说明 # 监听滚动事件, 触发定时器, 到时实现文章目录滚动跟随 浏览器支持 - docs-toc scrollTop my-toc scrollTop 文章目录跳转 Safari O X - Firefox O X - Chrome O O docs-toc需要定时器, 延时要求大于文章目录跳转最大耗时 滚动监听 # window添加事件监听 window.addEventListener('scroll', () =\u0026gt; { // 处理 }); window注册滚动处理 window.onscroll = function () { // 处理 }; 进入判断 # document.addEventListener('DOMContentLoaded', () =\u0026gt; { const myToc = document.querySelector('.my-toc'); const fullToc = document.querySelector('.docs-toc'); if (!myToc || !fullToc) return; // 后续处理 }); 滚动计算 # 为标题排序, 厘清高亮标题在文章目录中的位置 # let i = 0; myToc.querySelectorAll('a').forEach(entry =\u0026gt; { entry.setAttribute('scrollIdx', i++); }); 文章目录结构 # .my-toc嵌套在.docs-toc中, .docs-toc多一个\u0026quot;文章目录\u0026quot;提示 根据.my-toc的滚动高度和其容纳的标题个数计算单个标题的高度 function computeHeadingHeight() { const toc = document.querySelector('.my-toc'); return toc.scrollHeight / toc.querySelectorAll('a').length; } 计算窗口能容纳的标题数，经过测试，取其1/6，可以使高亮标题始终处于文章目录偏上位置 function computeUpIdx() { const fullToc = document.querySelector('.docs-toc'); const myToc = document.querySelector('.my-toc'); const offset = fullToc.scrollHeight - myToc.scrollHeight; const max = parseInt((window.innerHeight - offset) / HeadingHeight); return parseInt(max / 6); } 添加全局变量, 保存单个标题高度和高亮标题理想位置 let HeadingHeight, UpIdx; HeadingHeight = computeHeadingHeight(); UpIdx = computeUpIdx(); 注册监听处理：重启定时器, 延时滚动文章目录 # let FollowTimer = null; // 全局 const FollowTimerInterval = 300; window.onscroll = function () { clearTimeout(FollowTimer); FollowTimer = setTimeout(scrollFollow, FollowTimerInterval); }; 实现文章目录滚动 # 无高亮标题, 不作处理；多个标题高亮时, 基于第一个标题计算滚动偏移 function scrollFollow() { const activeHeadings = document.querySelector('.my-toc').querySelectorAll('a.active'); if (activeHeadings.length \u0026gt; 0) { const heading = activeHeadings.item(0); const idx = heading.getAttribute('scrollIdx'); const scrollTarget = idx - upIdx; document.querySelector('.docs-toc').scrollTop = HeadingHeight * scrollTarget; } } 完整JavaScript代码 # let HeadingHeight, UpIdx; let FollowTimer = null; const FollowTimerInterval = 300; function computeHeadingHeight() { const toc = document.querySelector('.my-toc'); return toc.scrollHeight / toc.querySelectorAll('a').length; } function computeUpIdx() { const fullToc = document.querySelector('.docs-toc'); const myToc = document.querySelector('.my-toc'); const offset = fullToc.scrollHeight - myToc.scrollHeight; const max = parseInt((window.innerHeight - offset) / HeadingHeight); return parseInt(max / 6); } function scrollFollow() { const activeHeadings = document.querySelector('.my-toc').querySelectorAll('a.active'); if (activeHeadings.length \u0026gt; 0) { const heading = activeHeadings.item(0); const idx = heading.getAttribute('scrollIdx'); const scrollTarget = idx - UpIdx; document.querySelector('.docs-toc').scrollTop = HeadingHeight * scrollTarget; } } document.addEventListener('DOMContentLoaded', () =\u0026gt; { const myToc = document.querySelector('.my-toc'); const fullToc = document.querySelector('.docs-toc'); if (!myToc || !fullToc) return; let i = 0; myToc.querySelectorAll('a').forEach(entry =\u0026gt; { entry.setAttribute('scrollIdx', i++); }); HeadingHeight = computeHeadingHeight(); UpIdx = computeUpIdx(); window.onscroll = function () { clearTimeout(FollowTimer); FollowTimer = setTimeout(scrollFollow, FollowTimerInterval); }; }); "}),e.add({id:105,href:"/docs/build-blog/%E4%B8%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/",title:"为技术博客绑定域名",description:"前提 # 依托GitHub的技术博客网址国内不可访问 域名说明 # 购买域名需要实名认证 + 信息模板实名认证, 腾讯云在信息模板认证通过后才能注册域名 即, 需要在购买处提供个人实名信息 域名无法买断, 通常按年购买和续费, 且首年和续费的费用不一致. 用作技术博客, 主要考虑续费费用 为博客绑定域名之后, 国内可以正常访问, 使用百度也可以搜索得到, 但速度还是不快, 因此, 后续就存在租用服务器的可能 大家见仁见智吧 域名服务商 # 参考 国内 阿里云 腾讯云 爱名网 聚名 西部数码 国外 GoDaddy Dynadot CloudFlare 购买域名之前, 查询域名历史 # 域名选购注意 - 爱站 站长之家 网站时光机 域名购买流程 # 在腾讯云上注册帐号 实名认证 信息模板实名认证 据说1-3个小时, 还是比较快的 注册域名 等待域名实名通过 需要一会 为博客绑定域名流程 # 获取GitHub服务器IP # 在终端ping博客网址 在域名服务商处设置域名解析 # 为域名添加解析 快速添加解析 填写GitHub服务器IP 得到两条解析记录, 点击确定 修改www子域的解析记录 设置记录类型为CNAME, 即将记录值解析成本域名 设置记录值为enjoy61.github.io enjoy61.",content:"前提 # 依托GitHub的技术博客网址国内不可访问 域名说明 # 购买域名需要实名认证 + 信息模板实名认证, 腾讯云在信息模板认证通过后才能注册域名 即, 需要在购买处提供个人实名信息 域名无法买断, 通常按年购买和续费, 且首年和续费的费用不一致. 用作技术博客, 主要考虑续费费用 为博客绑定域名之后, 国内可以正常访问, 使用百度也可以搜索得到, 但速度还是不快, 因此, 后续就存在租用服务器的可能 大家见仁见智吧 域名服务商 # 参考 国内 阿里云 腾讯云 爱名网 聚名 西部数码 国外 GoDaddy Dynadot CloudFlare 购买域名之前, 查询域名历史 # 域名选购注意 - 爱站 站长之家 网站时光机 域名购买流程 # 在腾讯云上注册帐号 实名认证 信息模板实名认证 据说1-3个小时, 还是比较快的 注册域名 等待域名实名通过 需要一会 为博客绑定域名流程 # 获取GitHub服务器IP # 在终端ping博客网址 在域名服务商处设置域名解析 # 为域名添加解析 快速添加解析 填写GitHub服务器IP 得到两条解析记录, 点击确定 修改www子域的解析记录 设置记录类型为CNAME, 即将记录值解析成本域名 设置记录值为enjoy61.github.io enjoy61.github.io 末尾的*表示根域, 为系统默认添加 在GitHub设置绑定域名 # 官方说明 管理GitHub Pages站点的自定义域 关于自定义域名和GitHub页面 在部署博客的项目中，设置自定义域名 # 生成博客内容的方法有很多, 比如Hugo, Hexo, 但最终都是把生成内容上传到部署博客的项目 这一项设置对应项目内一个名为CNAME的文件，内容如下, 即把配置内容写到CNAME中 www.enjoy61.com 也就是说, 再次生成博客内容时, 要想解析仍旧有效, 项目里需始终包含CNAME文件 修改博客项目配置信息 # Hugo Doks 修改配置项中的主页网址 config \u0026gt; _default \u0026gt; config.toml baseurl = \u0026quot;https://www.enjoy61.com/\u0026quot; 生成博客内容时, 如果设置了baseurl, 相应修改 hugo --baseUrl=\u0026quot;https://www.enjoy61.com/\u0026quot; --buildFuture --cleanDestinationDir 查看 # 在浏览器能正常访问www.enjoy61.com 在浏览器输入enjoy61.github.io, 会自动跳转到www.enjoy61.com 便签 # - 绑定域名 "}),e.add({id:106,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/npc%E8%A1%8C%E4%B8%BA/%E4%BB%8B%E7%BB%8Deqs%E8%B5%84%E4%BA%A7/",title:"介绍EQS资产",description:"介绍EQS资产 # 类似行为树图表 从Root出发, 可以设置各种生成器 # 随机目的地 # 双击打开EQS_RandomRoam 介绍下列生成器 - Points: Grid 方形点阵 Points: Circle 圆圈点阵 Points: Cone 扇形点阵 方形点阵 # EQS_TestPawn身处方形点阵表示的位置区域中 可配置项 GridHalfSize 点阵大小 Space Between 点阵密度 圆圈点阵 # 只圆形周长存在有效位置 可配置项 Circle Radius 半径 扇形点阵 # EQS_TestPawn位于顶点处, 前进向量对应扇形中线 该模板用于选择前进时的下一个目的地, 因为前进向量的改变不会太突兀 可配置项 Aligned Points Distance 射线上的点间距 Cone Degrees 顶角 Angle Step 射线密度 Range \u0026gt; Data Binding = None, Range 半径 Projection Data \u0026gt; Track Mode 设置投影 - Navigation 默认值, 显示投影到导航网格体的点阵 None 无投影, 会生成无法去到的位置点 Track Mode = None Range \u0026gt; Data Binding 半径模板选项 - None 默认, 固定值 Query Params Random number 设置随机数范围 Range \u0026gt; Data Binding = Random number 为扇形点阵添加限制条件 # 右键生成器, Add Test \u0026gt; Distance : 根据位置点到顶点的距离对位置点进行筛选 Details \u0026gt; Filter \u0026gt; Filter Type 限制类型 Range 给定范围 Minimum 给定最小值 当前给定筛选距离范围, 最大值和最小值均为0, 所以无合适位置点 表示位置点的球型显示为蓝色: 不是合适的位置点 给定最小值 为每个位置计算到顶点的距离, 根据距离, 给出权重: 距离越大的点, 选中的可能性更高 Float Value Min = 0.",content:"介绍EQS资产 # 类似行为树图表 从Root出发, 可以设置各种生成器 # 随机目的地 # 双击打开EQS_RandomRoam 介绍下列生成器 - Points: Grid 方形点阵 Points: Circle 圆圈点阵 Points: Cone 扇形点阵 方形点阵 # EQS_TestPawn身处方形点阵表示的位置区域中 可配置项 GridHalfSize 点阵大小 Space Between 点阵密度 圆圈点阵 # 只圆形周长存在有效位置 可配置项 Circle Radius 半径 扇形点阵 # EQS_TestPawn位于顶点处, 前进向量对应扇形中线 该模板用于选择前进时的下一个目的地, 因为前进向量的改变不会太突兀 可配置项 Aligned Points Distance 射线上的点间距 Cone Degrees 顶角 Angle Step 射线密度 Range \u0026gt; Data Binding = None, Range 半径 Projection Data \u0026gt; Track Mode 设置投影 - Navigation 默认值, 显示投影到导航网格体的点阵 None 无投影, 会生成无法去到的位置点 Track Mode = None Range \u0026gt; Data Binding 半径模板选项 - None 默认, 固定值 Query Params Random number 设置随机数范围 Range \u0026gt; Data Binding = Random number 为扇形点阵添加限制条件 # 右键生成器, Add Test \u0026gt; Distance : 根据位置点到顶点的距离对位置点进行筛选 Details \u0026gt; Filter \u0026gt; Filter Type 限制类型 Range 给定范围 Minimum 给定最小值 当前给定筛选距离范围, 最大值和最小值均为0, 所以无合适位置点 表示位置点的球型显示为蓝色: 不是合适的位置点 给定最小值 为每个位置计算到顶点的距离, 根据距离, 给出权重: 距离越大的点, 选中的可能性更高 Float Value Min = 0.0: 颜色从红色到绿色, 权重由小变大 生成附近随机位置 # - 生成敌人附近的随机点 环状点阵 寻找敌人 Context 介绍新生成器 - Points: Donut 环形点阵 环状点阵 # Points: Donut - Projection Data \u0026gt; Track Mode 设置投影 Inner Radius 内圈半径 Outer Radius 外圈半径 Number Of Rings 半径上的点个数 Points Per Ring 一圈上的点个数 Arc Angle 圆环扇形 Use Spiral Pattern 螺旋模式 为环状点阵添加限制条件 # 使用Distance - Filter \u0026gt; Filter Type 筛选方式 Score \u0026gt; Scoring Factor 权重比: 1则越远越大, -1则越近越大 权重比为1 最外层有几圈蓝色位置点, 均无效, 权重为0; 有效位置点由红色变为绿色, 权重由0变为1 权重比为-1 给定权重比范围, -1 ~ 1 设置中心点 # 环状点阵生成器中心点选项 # 选中环状点阵, Details \u0026gt; Center - EnvQueryContext_Querier 默认值, 使用EQS的上级Pawn; 可以自定义EnvQueryrContext 环状点阵距离限制条件距离计算的参照点选项 # 选中Distance, Details \u0026gt; Distance \u0026gt; Distance To - EnvQueryContext_Querier 默认值, 使用EQS的上级Pawn; 可以自定义EnvQueryrContext "}),e.add({id:107,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E7%BB%84%E4%BB%B6/%E5%BC%B9%E7%B0%A7%E8%87%82%E7%BB%84%E4%BB%B6/",title:"弹簧臂组件",description:"Spring Arm USpringArmComponent # USpringArmComponent::SocketOffset # 设置下级组件的相对偏移 ",content:"Spring Arm USpringArmComponent # USpringArmComponent::SocketOffset # 设置下级组件的相对偏移 "}),e.add({id:108,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%9C%A8c++%E4%B8%AD%E8%BF%90%E8%A1%8C%E8%A1%8C%E4%B8%BA%E6%A0%91%E5%92%8C%E4%B8%BAnpc%E8%BD%AC%E5%90%91%E6%B7%BB%E5%8A%A0%E8%BF%87%E6%B8%A1/",title:"在C++中运行行为树和为NPC转向添加过渡",description:"说明 # Smooth Character Rotation 在C++中运行行为树; NPC转向时有过渡 补充遗漏 # 让NPC移动到指定位置 那一节: 提供了允许游戏角色同时在场景中添加和代码中生成的方法; 以及在代码中设置AI控制器类的方法 添加构造函数 public ShootThemUp: AI/STUAICharacter.h ASTUAICharacter(const FObjectInitializer \u0026amp;ObjInit); ShootThemUp: AI/STUAICharacter.cpp #include \u0026quot;AI/STUAIController.h\u0026quot; ASTUAICharacter::ASTUAICharacter(const FObjectInitializer \u0026amp;ObjInit) : Super(ObjInit) { AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned; AIControllerClass = ASTUAIController::StaticClass(); } 在C++中运行行为树 # 添加属性: 保存行为树资产 可以作为控制器的逻辑, 也可以作为游戏角色的逻辑; 由于控制器控制多个游戏角色, 其有自己的行为树逻辑, 所以, 更适合放在游戏角色 public ShootThemUp: AI/STUAICharacter.h class UBehaviorTree; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) UBehaviorTree *BehaviorTreeAsset; 运行行为树 在OnPossess函数中; 在游戏中会被多次调用; 控制器每次切换游戏角色时调用 protected ShootThemUp: AI/STUAIController.h virtual void OnPossess(APawn *InPawn) override; ShootThemUp: AI/STUAIController.cpp #include \u0026quot;AI/STUAICharacter.",content:"说明 # Smooth Character Rotation 在C++中运行行为树; NPC转向时有过渡 补充遗漏 # 让NPC移动到指定位置 那一节: 提供了允许游戏角色同时在场景中添加和代码中生成的方法; 以及在代码中设置AI控制器类的方法 添加构造函数 public ShootThemUp: AI/STUAICharacter.h ASTUAICharacter(const FObjectInitializer \u0026amp;ObjInit); ShootThemUp: AI/STUAICharacter.cpp #include \u0026quot;AI/STUAIController.h\u0026quot; ASTUAICharacter::ASTUAICharacter(const FObjectInitializer \u0026amp;ObjInit) : Super(ObjInit) { AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned; AIControllerClass = ASTUAIController::StaticClass(); } 在C++中运行行为树 # 添加属性: 保存行为树资产 可以作为控制器的逻辑, 也可以作为游戏角色的逻辑; 由于控制器控制多个游戏角色, 其有自己的行为树逻辑, 所以, 更适合放在游戏角色 public ShootThemUp: AI/STUAICharacter.h class UBehaviorTree; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) UBehaviorTree *BehaviorTreeAsset; 运行行为树 在OnPossess函数中; 在游戏中会被多次调用; 控制器每次切换游戏角色时调用 protected ShootThemUp: AI/STUAIController.h virtual void OnPossess(APawn *InPawn) override; ShootThemUp: AI/STUAIController.cpp #include \u0026quot;AI/STUAICharacter.h\u0026quot; void ASTUAIController::OnPossess(APawn *InPawn) { Super::OnPossess(InPawn); const auto STUCharacter = Cast\u0026lt;ASTUAICharacter\u0026gt;(InPawn); if (STUCharacter) { RunBehaviorTree(STUCharacter-\u0026gt;BehaviorTreeAsset); } } 查看 # BP_STUAIController 移除行为树逻辑 BP_STUAICharacter 设置行为树资产 BT_STUCharacter 移除Wait任务 游戏角色转向突兀 在蓝图中设置NPC转向时过渡 # BP_STUAICharacter CharacterMovement \u0026gt; Details \u0026gt; Character Movement(Rotation Settings) 勾选Use Controller Desired Rotation: 旋转时在Tick函数中插入旋转过渡 设置旋转插入比例: Z = 200 BU_STUAICharacter \u0026gt; Details \u0026gt; Pawn , 取消Use Controller Rotation Yaw的勾选 在C++中为NPC转向添加过渡的方法 # ShootThemUp: AI/STUAICharacter.cpp #include \u0026quot;GameFramework/CharacterMovementComponent.h\u0026quot; // ASTUAICharacter bUseControllerRotationYaw = false; if (GetCharacterMovement()) { GetCharacterMovement()-\u0026gt;bUseControllerDesiredRotation = true; GetCharacterMovement()-\u0026gt;RotationRate = FRotator(0.0f, 200.0f, 0.0f); } "}),e.add({id:109,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E8%B4%B4%E8%8A%B1%E5%AE%9E%E7%8E%B0%E5%BC%B9%E7%97%95/",title:"使用贴花实现弹痕",description:"说明 # 使用贴花实现弹痕 从ShooterGame获取贴花资产 # Content/Effects/materials/Weapon/M_Impact_Decal , 右键 文件夹结构 导入ShootThemUp # 将Effect重命名为BulletDecal, 移动到 ExternalContent , 设置文件夹颜色 用来实现弹痕 重新构造光照 # 有对应提示时 设置光照质量 Build \u0026gt; Lighting Quality 构造光照 贴花 # 可以投影到网格体的特殊材质. 支持静态网格体和骨骼网格体 可以设置贴花的体积大小, 纹理, 隐入隐出相关参数 贴花Actor对应一个立方体, 立方体与包含物体的相交面作为投影面 我们可以使用贴花在墙上画涂鸦, 在不同表面上生成不同子弹特效 测试贴花Actor # 创建测试纹理 # 创建文件夹 Content/Dev 从网络下载虚幻引擎Logo作为纹理, 保存到Content/Dev 右键图片, 创建纹理, 命名为M_TestDecal 和之前的材质比较, 图片作为BaseColor的输入 将材质作为贴花使用的设置 延后贴花; 半透明渲染: Details \u0026gt; Material \u0026gt; Material Domain , 设置为 Deferred Decal ; Blend Mode 设置为 Translucent Alpha通道作为透明度的输入 设置贴花 # 添加贴花Actor到关卡中 Place Actors \u0026gt; Visual Effects \u0026gt; Decal Actor 使用M_TestDecal 选中贴花, 点击应用图标 设置贴花体积 选中DecalActor, Details \u0026gt; Decal \u0026gt; Decal Size , 设置X = 10, Y = Z = 20 查看弹痕贴花 # Content/ExternalContent/BulletDecal/Materials/Weapon/M_Impact_Decal 双击打开, 较M_TestDecal更为复杂, 添加了法向量和饱和度设置, 用以提高视觉质量 击中时生成贴花 # 产生冲击特效时生成贴花 添加数据结构 # STUCoreTypes.",content:"说明 # 使用贴花实现弹痕 从ShooterGame获取贴花资产 # Content/Effects/materials/Weapon/M_Impact_Decal , 右键 文件夹结构 导入ShootThemUp # 将Effect重命名为BulletDecal, 移动到 ExternalContent , 设置文件夹颜色 用来实现弹痕 重新构造光照 # 有对应提示时 设置光照质量 Build \u0026gt; Lighting Quality 构造光照 贴花 # 可以投影到网格体的特殊材质. 支持静态网格体和骨骼网格体 可以设置贴花的体积大小, 纹理, 隐入隐出相关参数 贴花Actor对应一个立方体, 立方体与包含物体的相交面作为投影面 我们可以使用贴花在墙上画涂鸦, 在不同表面上生成不同子弹特效 测试贴花Actor # 创建测试纹理 # 创建文件夹 Content/Dev 从网络下载虚幻引擎Logo作为纹理, 保存到Content/Dev 右键图片, 创建纹理, 命名为M_TestDecal 和之前的材质比较, 图片作为BaseColor的输入 将材质作为贴花使用的设置 延后贴花; 半透明渲染: Details \u0026gt; Material \u0026gt; Material Domain , 设置为 Deferred Decal ; Blend Mode 设置为 Translucent Alpha通道作为透明度的输入 设置贴花 # 添加贴花Actor到关卡中 Place Actors \u0026gt; Visual Effects \u0026gt; Decal Actor 使用M_TestDecal 选中贴花, 点击应用图标 设置贴花体积 选中DecalActor, Details \u0026gt; Decal \u0026gt; Decal Size , 设置X = 10, Y = Z = 20 查看弹痕贴花 # Content/ExternalContent/BulletDecal/Materials/Weapon/M_Impact_Decal 双击打开, 较M_TestDecal更为复杂, 添加了法向量和饱和度设置, 用以提高视觉质量 击中时生成贴花 # 产生冲击特效时生成贴花 添加数据结构 # STUCoreTypes.h 贴花信息 # 贴花材质 立方体体积参数 留存时间 贴花Alpha分量的动画时长 在给定时长, 贴花从场景中消失 // VFX class UMaterialInterface; USTRUCT(BlueprintType) struct FDecalData { GENERATED_USTRUCT_BODY() UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) UMaterialInterface *Material; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) FVector Size = FVector(10.0f); UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) float LifeTime = 5.0f; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) float FadeOutTime = 0.7f; }; 特效信息整合: 包含Niagara粒子系统和贴花 # class NiagaraSystem; USTRUCT(BlueprintType) struct FImpactData { GENERATED_USTRUCT_BODY() UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) UNiagaraSystem *NiagaraEffect; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) FDecalData DecalData; }; 使用特效数据结构 # ShootThemUp: Weapon/Components/STUWeaponFXComponent.h protected #include \u0026quot;STUCoreTypes.h\u0026quot; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) FImpactData DefaultImpactData; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) TMap\u0026lt;UPhysicalMaterial*, FImpactData\u0026gt; ImpactDataMap; ShootThemUp: Weapon/Components/STUWeaponFXComponent.cpp auto ImpactData = DefaultImpactData; if (ImpactDataMap.Contains(PhysMat)) { ImpactData = ImpactDataMap[PhysMat]; } // Niagara UNiagaraFunctionLibrary::SpawnSystemAtLocation(GetWorld(), // ImpactData.NiagaraEffect, // Hit.ImpactPoint, // Hit.ImpactNormal.Rotation()); 生成贴花 # 2个函数可以生成贴花 SpawnDecalAtLocation : 在给定世界座标生成贴花 - WorldContextObject 世界上下文 DecalMaterial 贴花材质 DecalSize 贴花体积参数 Location 位置 Rotation 方向向量 static UDecalComponent* SpawnDecalAtLocation(const UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, FVector DecalSize, FVector Location, FRotator Rotation = FRotator(-90, 0, 0), float LifeSpan = 0); SpawnDecalAttached : 生成贴花后设置上级组件 设置隐入隐出 SetFadeIn : 贴花出现 SetFadeOut StartDelay参数: 贴花出现后多久开始播放消失动画 DestroyOwnerAfterFade参数: 使用SpawnDecalAttached生成贴花时, 该参数有效; 从上级组件移除贴花; 默认值为true void UDecalComponent::SetFadeOut(float StartDelay, float Duration, bool DestroyOwnerAfterFade); // DestroyOwnerAfterFade = true ShootThemUp: Weapon/Components/STUWeaponFXComponent.cpp #include \u0026quot;Kismet/GameplayStatics.h\u0026quot; #include \u0026quot;Components/DecalComponent.h\u0026quot; // PlayImpactFX // decal auto DecalComponent = UGameplayStatics::SpawnDecalAtLocation(GetWorld(), // ImpactData.DecalData.Material, // ImpactData.DecalData.Size, // Hit.ImpactPoint, // Hit.ImpactNormal.Rotation()); if (DecalComponent) { DecalComponent-\u0026gt;SetFadeOut(ImpactData.DecalData.LifeTime, ImpactData.DecalData.FadeOutTime); } 设置特效数据属性 # 步枪 # 默认特效数据 映射: 拷贝DecalData属性 榴弹 # 设置贴花体积参数 图示错误 Size: X = 10, Y = Z = 100 效果 # 设置弹痕消失动画 # M_Impact_Decal 为Alpha通道添加动画 使用 Utils \u0026gt; DecalLifetimeOpacity 节点, 该变量存储贴花透明变量, 开始播放贴花隐出动画时, 该变量由1变为0 节点输出和纹理的Alpha分量相乘, 作为Opacity的输入 "}),e.add({id:110,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A1%A5%E7%BB%99/%E7%94%9F%E5%91%BD%E8%A1%A5%E7%BB%99/",title:"生命补给",description:"生命补给逻辑 # 添加属性 # ShootThemUp: Pickups/STUHealthPickup.h protected UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = \u0026quot;1.0\u0026quot;, ClampMax = \u0026quot;100.0\u0026quot;)) float HealthAmount = 100.0f; 添加接口: 若非死亡跌倒或组件不可寻, 调用健康组件接口 # ShootThemUp: Pickups/STUHealthPickup.cpp #include \u0026quot;Components/STUHealthComponent.h\u0026quot; #include \u0026quot;GameFramework/Pawn.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; // GivePickupTo const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(PlayerPawn); if (!HealthComponent || HealthComponent-\u0026gt;IsDead()) return false; return HealthComponent-\u0026gt;TryToAddHealth(HealthAmount); 生命组件逻辑 # ShootThemUp: Components/STUHealthComponent.h public bool TryToAddHealth(float HealthAmount); bool IsHealthFull() const; ShootThemUp: Components/STUHealthComponent.cpp bool USTUHealthComponent::IsHealthFull() const { return FMath::IsNearlyEqual(Health, MaxHealth); } bool USTUHealthComponent::TryToAddHealth(float HealthAmount) { if (IsHealthFull()) return false; SetHealth(Health + HealthAmount); return true; } 修改当前接口调用: 使用IsHealthFull # ShootThemUp: Components/STUHealthComponent.",content:"生命补给逻辑 # 添加属性 # ShootThemUp: Pickups/STUHealthPickup.h protected UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = \u0026quot;1.0\u0026quot;, ClampMax = \u0026quot;100.0\u0026quot;)) float HealthAmount = 100.0f; 添加接口: 若非死亡跌倒或组件不可寻, 调用健康组件接口 # ShootThemUp: Pickups/STUHealthPickup.cpp #include \u0026quot;Components/STUHealthComponent.h\u0026quot; #include \u0026quot;GameFramework/Pawn.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; // GivePickupTo const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(PlayerPawn); if (!HealthComponent || HealthComponent-\u0026gt;IsDead()) return false; return HealthComponent-\u0026gt;TryToAddHealth(HealthAmount); 生命组件逻辑 # ShootThemUp: Components/STUHealthComponent.h public bool TryToAddHealth(float HealthAmount); bool IsHealthFull() const; ShootThemUp: Components/STUHealthComponent.cpp bool USTUHealthComponent::IsHealthFull() const { return FMath::IsNearlyEqual(Health, MaxHealth); } bool USTUHealthComponent::TryToAddHealth(float HealthAmount) { if (IsHealthFull()) return false; SetHealth(Health + HealthAmount); return true; } 修改当前接口调用: 使用IsHealthFull # ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage // OnHeal 查看 # 设置治疗频率 BP_STUBaseCharacter "}),e.add({id:111,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%99%9A%E5%B9%BB%E8%BF%90%E5%8A%A8%E5%9B%BE%E8%A1%A8/%E5%9C%A8%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%AD%A6%E5%99%A8%E5%92%8C%E5%BC%B9%E8%8D%AF%E5%BA%93/",title:"在窗口部件显示当前武器和弹药库",description:"说明 # 在窗口部件的右下角显示武器图标, 子弹数和弹匣数 概览 # 给武器组件和窗口部件的接口添加Current关键字 窗口部件实现接口: 返回弹药数据 窗口部件显示武器图标 窗口部件显示弹药库存 修改接口: 窗口部件返回武器图片 # 添加内部接口: 获取武器组件 # ShootThemUp: UI/STUPlayerHUDWidget.h private class USTUWeaponComponent; USTUWeaponComponent *GetWeaponComponent() const; ShootThemUp: UI/STUPlayerHUDWidget.cpp USTUWeaponComponent *USTUPlayerHUDWidget::GetWeaponComponent() const { const auto Player = GetOwningPlayerPawn(); if (!Player) return nullptr; const auto Component = Player-\u0026gt;GetComponentByClass(USTUWeaponComponent::StaticClass()); const auto WeaponComponent = Cast\u0026lt;USTUWeaponComponent\u0026gt;(Component); return WeaponComponent; } 使用内部接口: 获取武器组件 # ShootThemUp: UI/STUPlayerHUDWidget.cpp // GetCrrentWeaponUIData const auto WeaponComponent = GetWeaponComponent(); 修改接口名: 武器组件返回武器图片 # GetWeaponUIData \u0026gt; GetCurrentWeaponUIData =ShootThemUp: Components/STUWeaponComponent.",content:`说明 # 在窗口部件的右下角显示武器图标, 子弹数和弹匣数 概览 # 给武器组件和窗口部件的接口添加Current关键字 窗口部件实现接口: 返回弹药数据 窗口部件显示武器图标 窗口部件显示弹药库存 修改接口: 窗口部件返回武器图片 # 添加内部接口: 获取武器组件 # ShootThemUp: UI/STUPlayerHUDWidget.h private class USTUWeaponComponent; USTUWeaponComponent *GetWeaponComponent() const; ShootThemUp: UI/STUPlayerHUDWidget.cpp USTUWeaponComponent *USTUPlayerHUDWidget::GetWeaponComponent() const { const auto Player = GetOwningPlayerPawn(); if (!Player) return nullptr; const auto Component = Player-\u0026gt;GetComponentByClass(USTUWeaponComponent::StaticClass()); const auto WeaponComponent = Cast\u0026lt;USTUWeaponComponent\u0026gt;(Component); return WeaponComponent; } 使用内部接口: 获取武器组件 # ShootThemUp: UI/STUPlayerHUDWidget.cpp // GetCrrentWeaponUIData const auto WeaponComponent = GetWeaponComponent(); 修改接口名: 武器组件返回武器图片 # GetWeaponUIData \u0026gt; GetCurrentWeaponUIData =ShootThemUp: Components/STUWeaponComponent.h ShootThemUp: Components/STUWeaponComponent.cpp 修改接口名: 窗口部件返回武器图片 # GetWeaponUIData \u0026gt; GetCurrentWeaponUIData =ShootThemUp: UI/STUPlayerHUDWidget.h ShootThemUp: UI/STUPlayerHUDWidget.cpp // GetCurrentWeaponUIData return WeaponComponent-\u0026gt;GetCurrentWeaponUIData(UIData); 更改接口 # WBP_PlayerHUD \u0026gt; Graph \u0026gt; Get Crosshair Image 添加函数GetCurrentWeaponUIData, 并展开UIData # 修改针脚连线 # 按下Command键同时点击选中区域, 将针脚连线移动到 GetCurrentWeaponUIData \u0026gt; UIData Crosshair Icon 和 GetCurrentWeaponUIData \u0026gt; Return Value 将获取纹理大小封装成宏 # 选中相关节点 右键 命名为 ImageSizeFromTexture 双击宏进入
只需一个输入
选中 Inputs , 去到 Details \u0026gt; Inputs , 删除第二个输入 将输入命名为Texture, 输出命名为Size
GetSizeX和GetSizeY的输入来自Texture
移除ImageSizefromTexture的无效输入 # 按下Option键同时点击选中区域 修改后的GetCrosshairImage # 添加接口: 窗口部件返回弹药信息 # 添加接口: 武器基类返回弹药信息 # ShootThemUp: Weapon/STUBaseWeapon.h public FAmmoData GetAmmoData() const { return CurrentAmmo; } 添加接口: 武器组件返回弹药信息 # ShootThemUp: Components/STUWeaponComponent.h public bool GetCurrentWeaponAmmoData(FAmmoData \u0026amp;AmmoData) const; ShootThemUp: Components/STUWeaponComponent.cpp bool USTUWeaponComponent::GetCurrentWeaponAmmoData(FAmmoData \u0026amp;AmmoData) const { if (CurrentWeapon) { AmmoData = CurrentWeapon-\u0026gt;GetAmmoData(); return true; } return false; } 添加接口: 窗口部件返回弹药信息 # ShootThemUp: UI/STUPlayerHUDWidget.h UFUNCTION(BlueprintCallable) bool GetCurrentWeaponAmmoData(FAmmoData \u0026amp;AmmoData) const; ShootThemUp: UI/STUPlayerHUDWidget.cpp bool USTUPlayerHUDWidget::GetCurrentWeaponAmmoData(FAmmoData \u0026amp;AmmoData) const { const auto WeaponComponent = GetWeaponComponent(); if (!WeaponComponent) return false; return WeaponComponent-\u0026gt;GetCurrentWeaponAmmoData(AmmoData); } 在窗口部件显示武器信息 # WBP_PlayerHUD \u0026gt; Designer 添加元素 # 水平对齐盒 Horizontal Box 文本框 Text 分隔 Spacer 图片 Image 设置分隔 # 分隔文本和图片 Details \u0026gt; Size , 设置X=30 设置水平对齐盒 # Details \u0026gt; Slot \u0026gt; Size To Content 勾选 可以恰好包含内部元素 设置锚点
设置锚点为右下方 设置大小, 位置, 对齐 Slot , Size X = 100, Size Y = 30 已勾选 SizeToContent , 不生效 Slot , Position X = Position Y = 0 Slot \u0026gt; Alignment , X = 1 Y = 1 设置缩进 Slot , Position X = Position Y = -50 设置预览图片 # RifleMainIcon 设置文本框 # Slot \u0026gt; Vertical Alignment , 选择居中 获取武器图标 # 为图片元素添加绑定 # 命名为Get Weapon Icon # 从Get Crosshair Image拷贝节点并修改 # 显示弹药库 # 格式 # 弹匣内子弹数 / 弹匣数 为文本元素添加绑定 # 命名为Get Ammo Text # 使用节点: GetCurrentWeaponAmmoData # 合成文本 # 使用节点: Utilities \u0026gt; String \u0026gt; ToString
将整数转换为字符串 对 AmmoDataBullets 和 AmmoDataClips 使用 使用节点: Select
对 AmmoDataInfinite 使用, 使用无限符号∞还是弹匣数作为分母 使用节点: Utilities \u0026gt; String \u0026gt; Append
拼接文本 完成
ReturnNode 的输入是FText类型 以上逻辑可以在C++中实现. 之所以在蓝图中完成, 因为这部分逻辑更倾向于设计 在蓝图中添加注释
Comment 按下 C 键 查看 # 游戏角色死亡, 武器图标变为方块 `}),e.add({id:112,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/ace-window/",title:"ace-window",description:"根据标号切换窗口 ace-window-安装 # (use-package ace-window :ensure t :init (progn (global-set-key [remap other-window] 'ace-window) (custom-set-faces '(aw-leading-char-face ((t (:inherit ace-jump-face-foreground :height 3.0))))) ;; 配置标识样式 )) ",content:"根据标号切换窗口 ace-window-安装 # (use-package ace-window :ensure t :init (progn (global-set-key [remap other-window] 'ace-window) (custom-set-faces '(aw-leading-char-face ((t (:inherit ace-jump-face-foreground :height 3.0))))) ;; 配置标识样式 )) "}),e.add({id:113,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E4%BD%BF%E7%94%A8ox-hugo%E5%AF%BC%E5%87%BA%E5%8D%9A%E5%AE%A2/",title:"使用ox-hugo导出博客",description:`说明 # - 描述 解决方法 ox-hugo 安装 导出子树时, 整个文件的所有链接要求正确 提取options和子树文本 导出子树时, 自动计算weight, 需要保留其他子树 计算子树的weight 导出文件时, 若在临时文件, 需输入导出文件名 导出子树, 计算子树的导出路径 转换后的下划线无效 不用 Doks主题 markdown文件图片链接无法正确解析 替换图片链接 会检查所有文本(包括代码块)的图片链接 分隔\u0026quot;{{\u0026ldquo;和\u0026rdquo;\u0026lt; figure src\u0026hellip;\u0026quot; 图片链接后接文本, 会作为图片描述 图片链接和文本之间空一行 org-roam 希望能跳转到博客对应标题 将roam节点链接替换为博客+标题链接 时间戳链接 不需要 删除 源码链接 不需要跳转, 需提供说明 在文本块中显示相对路径 安装ox-hugo # ox-hugo-安装 子树路径 # 获取导出文件路径 # 保存到列表 只能有选项SECTION, 子树使用SECTION_FRAG 缺乏子树从属判断 (defun my/compute-subtree-path (export-name) (interactive) (let ((base-dir) (section) (dir) (slotlist '()) (cur-level) (frag) (new-level) ) (save-excursion (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;#+\u0026quot; \u0026quot;HUGO_BASE_DIR\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (setq base-dir (string-join (mapcar #'string (match-string 1)))) (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;#+\u0026quot; \u0026quot;HUGO_SECTION\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (setq section (string-join (mapcar #'string (match-string 1)))) (setq dir (concat base-dir \u0026quot;/content/\u0026quot; section)) ) ) ) (add-to-list 'slotlist export-name) (save-excursion (setq cur-level (funcall outline-level)) (while (re-search-backward (rx \u0026quot;:\u0026quot; \u0026quot;EXPORT_HUGO_SECTION_FRAG\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot; ) nil t) (setq frag (string-join (mapcar #'string (match-string 1)))) (setq new-level (funcall outline-level)) (when (\u0026lt; new-level cur-level) ;;(message \u0026quot;%d %d %s\u0026quot; (funcall outline-level) ocur-level ofrag) ;;(sleep-for 5) (add-to-list 'slotlist frag) (setq cur-level new-level) ) ) ) (add-to-list 'slotlist dir) ) ) 获取导出文件路径的字符串 # (defun my/subtree-path-str (export-name) (interactive) (let ((slotlist (my/compute-subtree-path export-name)) (slot)) (dolist (item slotlist) (setq slot (concat slot \u0026quot;/\u0026quot; item)) ) (string-remove-prefix \u0026quot;/\u0026quot; slot) ) ) Doks主题 # 替换markdown文件图片链接格式 # (defun my/replace-pic-link-format (file) (interactive) (with-current-buffer (find-file-noselect file) (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;{{\u0026quot; \u0026quot;\u0026lt; figure src=\\\u0026quot;\u0026quot; (group (0+ (not \u0026quot;\\\u0026quot;\u0026quot;))) \u0026quot;\\\u0026quot; width=\\\u0026quot;\u0026quot; (group (0+ (not \u0026quot;\\\u0026quot;\u0026quot;))) \u0026quot;\\\u0026quot; \u0026gt;}}\u0026quot;) nil t) (let ((src (string-join (mapcar #'string (match-string 1)))) (width (string-join (mapcar #'string (match-string 2))))) (replace-match (format \u0026quot;\u0026lt;img src=\\\u0026quot;/%s\\\u0026quot; width=\\\u0026quot;%s\\\u0026quot; /\u0026gt; \u0026lt;br/\u0026gt;\u0026quot; src width)) ) ) (save-buffer) (kill-buffer) ) ) 替换子树导出文件图片链接格式 # (defun my/amend-pic-link (export-name) (interactive) (my/replace-pic-link-format (concat (my/subtree-path-str export-name) \u0026quot;.`,content:`说明 # - 描述 解决方法 ox-hugo 安装 导出子树时, 整个文件的所有链接要求正确 提取options和子树文本 导出子树时, 自动计算weight, 需要保留其他子树 计算子树的weight 导出文件时, 若在临时文件, 需输入导出文件名 导出子树, 计算子树的导出路径 转换后的下划线无效 不用 Doks主题 markdown文件图片链接无法正确解析 替换图片链接 会检查所有文本(包括代码块)的图片链接 分隔\u0026quot;{{\u0026ldquo;和\u0026rdquo;\u0026lt; figure src\u0026hellip;\u0026quot; 图片链接后接文本, 会作为图片描述 图片链接和文本之间空一行 org-roam 希望能跳转到博客对应标题 将roam节点链接替换为博客+标题链接 时间戳链接 不需要 删除 源码链接 不需要跳转, 需提供说明 在文本块中显示相对路径 安装ox-hugo # ox-hugo-安装 子树路径 # 获取导出文件路径 # 保存到列表 只能有选项SECTION, 子树使用SECTION_FRAG 缺乏子树从属判断 (defun my/compute-subtree-path (export-name) (interactive) (let ((base-dir) (section) (dir) (slotlist '()) (cur-level) (frag) (new-level) ) (save-excursion (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;#+\u0026quot; \u0026quot;HUGO_BASE_DIR\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (setq base-dir (string-join (mapcar #'string (match-string 1)))) (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;#+\u0026quot; \u0026quot;HUGO_SECTION\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (setq section (string-join (mapcar #'string (match-string 1)))) (setq dir (concat base-dir \u0026quot;/content/\u0026quot; section)) ) ) ) (add-to-list 'slotlist export-name) (save-excursion (setq cur-level (funcall outline-level)) (while (re-search-backward (rx \u0026quot;:\u0026quot; \u0026quot;EXPORT_HUGO_SECTION_FRAG\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot; ) nil t) (setq frag (string-join (mapcar #'string (match-string 1)))) (setq new-level (funcall outline-level)) (when (\u0026lt; new-level cur-level) ;;(message \u0026quot;%d %d %s\u0026quot; (funcall outline-level) ocur-level ofrag) ;;(sleep-for 5) (add-to-list 'slotlist frag) (setq cur-level new-level) ) ) ) (add-to-list 'slotlist dir) ) ) 获取导出文件路径的字符串 # (defun my/subtree-path-str (export-name) (interactive) (let ((slotlist (my/compute-subtree-path export-name)) (slot)) (dolist (item slotlist) (setq slot (concat slot \u0026quot;/\u0026quot; item)) ) (string-remove-prefix \u0026quot;/\u0026quot; slot) ) ) Doks主题 # 替换markdown文件图片链接格式 # (defun my/replace-pic-link-format (file) (interactive) (with-current-buffer (find-file-noselect file) (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;{{\u0026quot; \u0026quot;\u0026lt; figure src=\\\u0026quot;\u0026quot; (group (0+ (not \u0026quot;\\\u0026quot;\u0026quot;))) \u0026quot;\\\u0026quot; width=\\\u0026quot;\u0026quot; (group (0+ (not \u0026quot;\\\u0026quot;\u0026quot;))) \u0026quot;\\\u0026quot; \u0026gt;}}\u0026quot;) nil t) (let ((src (string-join (mapcar #'string (match-string 1)))) (width (string-join (mapcar #'string (match-string 2))))) (replace-match (format \u0026quot;\u0026lt;img src=\\\u0026quot;/%s\\\u0026quot; width=\\\u0026quot;%s\\\u0026quot; /\u0026gt; \u0026lt;br/\u0026gt;\u0026quot; src width)) ) ) (save-buffer) (kill-buffer) ) ) 替换子树导出文件图片链接格式 # (defun my/amend-pic-link (export-name) (interactive) (my/replace-pic-link-format (concat (my/subtree-path-str export-name) \u0026quot;.md\u0026quot;)) ) 替换文件内所有子树导出文件图片链接格式 # (defun my/amend-pic-link-for-all () (interactive) (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;:\u0026quot; \u0026quot;EXPORT_FILE_NAME\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (my/amend-pic-link (string-join (mapcar #'string (match-string 1)))) ) ) org-roam # 需设置相对路径 # ;; (setq my/roam-prefix \u0026quot;hugo/content/\u0026quot;) 将roam节点链接替换为博客+标题链接 # 相对路径计算采用去除前缀 (defun my/replace-roam-link () (interactive) (save-excursion (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;[[\u0026quot; \u0026quot;id:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot;) nil t) (let* ((id (string-join (mapcar #'string (match-string 1)))) (title (string-join (mapcar #'string (match-string 2)))) (title-downcase (string-replace \u0026quot;::\u0026quot; \u0026quot;-\u0026quot; (downcase title))) (node (org-roam-node-from-id id)) (slot)) (with-current-buffer (find-file-noselect (org-roam-node-file node)) (goto-char (org-roam-node-point node)) (outline-next-heading) (when (re-search-backward (rx \u0026quot;:\u0026quot; \u0026quot;EXPORT_FILE_NAME\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (setq slot (my/subtree-path-str (string-join (mapcar #'string (match-string 1))))) ) ) (when slot (save-excursion (beginning-of-buffer) (when (search-forward (format (concat \u0026quot;[[\u0026quot; \u0026quot;id:%s][%s]]\u0026quot;) id title) nil t) ;;(message (format \u0026quot;%s %s\u0026quot; slot title)) ;;(sleep-for 1) (replace-match (format \u0026quot;[[file:/%s/#%s][%s]]\u0026quot; (downcase (string-remove-prefix my/roam-prefix slot)) title-downcase title) nil t) ) ) ) ) ) ) ) 时间戳链接 # 删除时间戳链接 # (defun my/delete-timestamp-link () (interactive) (save-excursion (beginning-of-buffer) (while (re-search-forward (rx (not \u0026quot;!\u0026quot;) \u0026quot;[[\u0026quot; \u0026quot;timestamp:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot;) nil t) (replace-match \u0026quot;\u0026quot; nil t) ) ) ) 源码链接 # 虚幻引擎项目源码 # (defun my/replace-ue-project-file-link () (interactive) (save-excursion (beginning-of-buffer) (while (re-search-forward (rx (not \u0026quot;!\u0026quot;) \u0026quot;[[\u0026quot; \u0026quot;uep:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;:\u0026quot;))) \u0026quot;:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((proj (string-join (mapcar #'string (match-string 2)))) (file (string-join (mapcar #'string (match-string 3))))) (replace-match (format \u0026quot;=%s: %s=\u0026quot; proj file) nil t) ) ) ) ) 虚幻引擎源码 # (defun my/replace-ue-engine-file-link () (interactive) (save-excursion (beginning-of-buffer) (while (re-search-forward (rx (not \u0026quot;!\u0026quot;) \u0026quot;[[\u0026quot; \u0026quot;ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1))))) (replace-match (format \u0026quot;=%s=\u0026quot; file) nil t) ) ) ) ) 虚幻引擎项目源码链接逆向恢复 # ;; (defun my/recover-ue-project-file-link () ;; (interactive) ;; (beginning-of-buffer) ;; (while (re-search-forward (rx \u0026quot;=ShootThemUp: \u0026quot; (group (0+ (not \u0026quot;=\u0026quot;))) \u0026quot;=\u0026quot;) nil t) ;; (let ((filename (string-join (mapcar #'string (match-string 1)))) ;; (folder)) ;; (if (string-suffix-p \u0026quot;.h\u0026quot; filename) ;; (setq folder \u0026quot;Public/\u0026quot;)) ;; (if (string-suffix-p \u0026quot;.cpp\u0026quot; filename) ;; (setq folder \u0026quot;Private/\u0026quot;)) ;; (if (string-suffix-p \u0026quot;.cs\u0026quot; filename) ;; (setq folder \u0026quot;\u0026quot;)) ;; (if (string-prefix-p \u0026quot;STUGameModeBase\u0026quot; filename) ;; (setq folder \u0026quot;\u0026quot;)) ;; (replace-match (format (concat \u0026quot;[[\u0026quot; \u0026quot;uep:%s%s][ShootThemUp:%s]]\u0026quot;) folder filename filename) nil t) ;; ) ;; ) ;; ) 复制文本内容 # 选项 # (defun my/copy-org-options () (interactive) (save-excursion (beginning-of-buffer) (let ((op-start (point))) (outline-next-heading) (buffer-substring-no-properties op-start (point)) ) ) ) 子树 # (defun my/copy-org-subtree () (interactive) (save-excursion (outline-next-heading) (when (re-search-backward (rx \u0026quot;:\u0026quot; \u0026quot;EXPORT_FILE_NAME\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (outline-previous-heading) (org-copy-subtree) (current-kill 0) ) ) ) 计算权重 # (defun my/backward-heading-same-level () (interactive) (org-backward-heading-same-level 1) (point) ) (defun my/compute-weight () (interactive) (let ((cur-pos) (weight 2001)) (save-excursion (outline-next-heading) (when (re-search-backward (rx \u0026quot;:\u0026quot; \u0026quot;EXPORT_FILE_NAME\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (org-previous-visible-heading 1) (setq cur-pos (point)) (while (/= cur-pos (my/backward-heading-same-level)) (setq weight (+ weight 1)) (setq cur-pos (point)) ) (message \u0026quot;%d\u0026quot; weight) ) ) ) ) 导出子树 # 光标所在子树 # (defun my/ox-hugo-export-subtree () (interactive) (save-excursion (outline-next-heading) (when (re-search-backward (rx \u0026quot;:\u0026quot; \u0026quot;EXPORT_FILE_NAME\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (let* ((export-name (string-join (mapcar #'string (match-string 1)))) (subtree (my/copy-org-subtree)) (options (my/copy-org-options)) (weight (my/compute-weight)) (slotlist '()) (slotlist (my/compute-subtree-path export-name)) (slot) (section) (cur-level)) (with-temp-buffer (insert options) (insert subtree) (org-mode) (my/delete-timestamp-link) (my/replace-ue-project-file-link) (my/replace-ue-engine-file-link) (my/replace-roam-link) (pop slotlist) (setq slotlist (reverse slotlist)) (pop slotlist) (setq slotlist (reverse slotlist)) (dolist (item slotlist) (setq slot (concat slot \u0026quot;/\u0026quot; item)) ) (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;+\u0026quot; \u0026quot;HUGO_SECTION\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;)))) nil t) (setq section (string-join (mapcar #'string (match-string 1)))) (replace-match (format (concat \u0026quot;+\u0026quot; \u0026quot;HUGO_SECTION\u0026quot; \u0026quot;: %s\u0026quot;) (concat section slot))) ) (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;EXPORT_HUGO_WEIGHT\u0026quot; \u0026quot;: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;)))) nil t) (replace-match (format (concat \u0026quot;EXPORT_HUGO_WEIGHT\u0026quot; \u0026quot;: %s\u0026quot;) weight)) ) (beginning-of-buffer) (outline-next-heading) (setq cur-level (funcall outline-level)) (while (/= 1 cur-level) (org-shiftmetaleft) (setq cur-level (funcall outline-level)) ) (org-hugo-export-wim-to-md) (my/amend-pic-link export-name) ) ) ) ) ) (global-set-key (kbd \u0026quot;C-c h s\u0026quot;) 'my/ox-hugo-export-subtree) 文件内所有子树 # (defun my/ox-hugo-export-all-subtrees () (interactive) (save-excursion (let ((buf-content (buffer-string))) (with-temp-buffer (insert buf-content) (org-mode) (my/delete-timestamp-link) (my/replace-ue-project-file-link) (my/replace-ue-engine-file-link) (my/replace-roam-link) (org-hugo-export-wim-to-md :all-subtrees) (my/amend-pic-link-for-all) ) ) ) ) (global-set-key (kbd \u0026quot;C-c h a\u0026quot;) 'my/ox-hugo-export-all-subtrees) `}),e.add({id:114,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E7%BB%84%E4%BB%B6/%E6%96%87%E6%9C%AC%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6/",title:"文本渲染组件",description:"Text Render UTextRenderComponent # 基类 # UPrimitiveComponent 相关函数 # UPrimitiveComponent::SetOwnerNoSee ",content:"Text Render UTextRenderComponent # 基类 # UPrimitiveComponent 相关函数 # UPrimitiveComponent::SetOwnerNoSee "}),e.add({id:115,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/",title:"视觉感知",description:"说明 # AI Perception Component 允许NPC游戏角色感知给定范围内的世界中的其他Actor, 通过视觉和听觉感知敌人, 对伤害作出反应 本节为NPC添加视觉感知, 寻找与之最近的敌人, 使NPC面向该敌人 创建C++类 # - 基类 AIPerceptionComponent Components Public STUAIPerceptionComponent 为AIController添加感知组件 # 添加构造函数 ShootThemUp: AI/STUAIController.h public ASTUAIController(); 添加组件 ShootThemUp: AI/STUAIController.h protected class USTUAIPerceptionComponent; UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USTUAIPerceptionComponent *STUAIPerceptionComponent; 初始化组件 ShootThemUp: AI/STUAIController.cpp #include \u0026quot;Components/STUAIPerceptionComponent.h\u0026quot; ASTUAIController::ASTUAIController() { STUAIPerceptionComponent = CreateDefaultSubobject\u0026lt;USTUAIPerceptionComponent\u0026gt;(\u0026quot;STUPerceptionComponent\u0026quot;); SetPerceptionComponent(*STUAIPerceptionComponent); } 设置感知组件 # BP_STUAIController \u0026gt; STUAIPerceptionComponent \u0026gt; Details AI Perception \u0026gt; Senses Config : 对游戏角色的感官进行配置, 可以感知的有伤害, 听觉, 视觉等 添加AI视觉 # 选择 AI Sight config 设置捕捉可视半径为1000 Sense \u0026gt; Sight Radius 设置监控释放半径为1500 Sense \u0026gt; Lose Sight Radius 设置可视半角为60 Sense \u0026gt; PeripheralVisionHalfAngleDegrees 设置调试颜色为蓝色 Sense \u0026gt; Debug Color Sense \u0026gt; Detection by Affiliation , 勾选 Detect Enemies , Detect Neutrals , Detect Friendlies ; 当前没有分队别 设置MaxAge为1: Actor从视野中消失多久后不再保存相关信息 设置感官优先级 # 可以将 Sense \u0026gt; DominantSense 设置为None或 AISense_Sight 查看 # 关闭行为树 BP_STUCharactr 按下 Option , 左键点击箭头 UE4.",content:"说明 # AI Perception Component 允许NPC游戏角色感知给定范围内的世界中的其他Actor, 通过视觉和听觉感知敌人, 对伤害作出反应 本节为NPC添加视觉感知, 寻找与之最近的敌人, 使NPC面向该敌人 创建C++类 # - 基类 AIPerceptionComponent Components Public STUAIPerceptionComponent 为AIController添加感知组件 # 添加构造函数 ShootThemUp: AI/STUAIController.h public ASTUAIController(); 添加组件 ShootThemUp: AI/STUAIController.h protected class USTUAIPerceptionComponent; UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USTUAIPerceptionComponent *STUAIPerceptionComponent; 初始化组件 ShootThemUp: AI/STUAIController.cpp #include \u0026quot;Components/STUAIPerceptionComponent.h\u0026quot; ASTUAIController::ASTUAIController() { STUAIPerceptionComponent = CreateDefaultSubobject\u0026lt;USTUAIPerceptionComponent\u0026gt;(\u0026quot;STUPerceptionComponent\u0026quot;); SetPerceptionComponent(*STUAIPerceptionComponent); } 设置感知组件 # BP_STUAIController \u0026gt; STUAIPerceptionComponent \u0026gt; Details AI Perception \u0026gt; Senses Config : 对游戏角色的感官进行配置, 可以感知的有伤害, 听觉, 视觉等 添加AI视觉 # 选择 AI Sight config 设置捕捉可视半径为1000 Sense \u0026gt; Sight Radius 设置监控释放半径为1500 Sense \u0026gt; Lose Sight Radius 设置可视半角为60 Sense \u0026gt; PeripheralVisionHalfAngleDegrees 设置调试颜色为蓝色 Sense \u0026gt; Debug Color Sense \u0026gt; Detection by Affiliation , 勾选 Detect Enemies , Detect Neutrals , Detect Friendlies ; 当前没有分队别 设置MaxAge为1: Actor从视野中消失多久后不再保存相关信息 设置感官优先级 # 可以将 Sense \u0026gt; DominantSense 设置为None或 AISense_Sight 查看 # 关闭行为树 BP_STUCharactr 按下 Option , 左键点击箭头 UE4.27: 移除Root到Sequence的箭头即可 UE5.1: 必须移除Sequence到子任务的箭头 在新窗口运行游戏 按下 ' 打开AI调试信息; 在小写键盘按下数字4, 使能 Perception 信息 绿色圆柱体表示捕捉可视边界; 粉色圆柱体表示监控释放边界 进入到捕捉可视区域, 游戏角色所处位置出现蓝色调试球体, 表明游戏角色被NPC捕捉到; 绿色可视角 蓝色调试球体的活动范围由可视角和监控释放边界组成 进入到捕捉可视区域, 被NPC捕捉, 之后只要在活动范围内, 其移动就会被NPC捕捉到 活动范围内, 位于障碍物之后, MaxAge时间后, 蓝色调试球消失 移动到活动范围外, MaxAge时间后, 蓝色调试球消失 在场景中添加另一个NPC 场景中有多个游戏角色: NPC靠近和他距离最近的游戏角色 # 获取组件 # GetComponentByClass也是AActor的成员函数: 修改传参类型 STUUtils.h static T *GetSTUPlayerComponent(AActor *PlayerPawn) { // ... } AActor提供成员函数FindComponentByClass 返回最近的Actor # ShootThemUp: Components/STUAIPerceptionComponent.h public AActor *GetClosestEnemy() const; 获取所有捕捉的Actor # TArray\u0026lt;AActor*\u0026gt; PercieveActors; GetCurrentlyPerceivedActors(UAISense_Sight::StaticClass(), PercieveActors); if (!PercieveActors.Num()) return nullptr; 计算最近Actor # const auto Controller = Cast\u0026lt;AAIController\u0026gt;(GetOwner()); if (!Controller) return nullptr; const auto Pawn = Controller-\u0026gt;GetPawn(); if (!Pawn) return nullptr; const auto LocalPos = Pawn-\u0026gt;GetActorLocation(); float BestDistance = MAX_FLT; AActor *BestPawn = nullptr; for (const auto PercieveActor: PercieveActors) { const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(PercieveActor); if (HealthComponent \u0026amp;\u0026amp; !HealthComponent-\u0026gt;IsDead()) // TODO: check if enemies or not { const auto CurrentDistance = (PercieveActor-\u0026gt;GetActorLocation() - LocalPos).Size(); if (CurrentDistance \u0026lt; BestDistance) { BestDistance = CurrentDistance; BestPawn = PercieveActor; } } } 完整实现 # ShootThemUp: Components/STUAIPerceptionComponent.cpp #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; #include \u0026quot;Components/STUHealthComponent.h\u0026quot; #include \u0026quot;Perception/AISense_Sight.h\u0026quot; AActor *USTUAIPerceptionComponent::GetClosestEnemy() const { TArray\u0026lt;AActor*\u0026gt; PercieveActors; GetCurrentlyPerceivedActors(UAISense_Sight::StaticClass(), PercieveActors); if (!PercieveActors.Num()) return nullptr; const auto Controller = Cast\u0026lt;AAIController\u0026gt;(GetOwner()); if (!Controller) return nullptr; const auto Pawn = Controller-\u0026gt;GetPawn(); if (!Pawn) return nullptr; const auto LocalPos = Pawn-\u0026gt;GetActorLocation(); float BestDistance = MAX_FLT; AActor *BestPawn = nullptr; for (const auto PercieveActor: PercieveActors) { const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(PercieveActor); if (HealthComponent \u0026amp;\u0026amp; !HealthComponent-\u0026gt;IsDead()) // TODO: check if enemies or not { const auto CurrentDistance = (PercieveActor-\u0026gt;GetActorLocation() - LocalPos).Size(); if (CurrentDistance \u0026lt; BestDistance) { BestDistance = CurrentDistance; BestPawn = PercieveActor; } } } return BestPawn; } 添加Tick函数: 每秒计算一次最近Actor, 旋转NPC朝向被捕捉对象 # 暂时不检查STUAIPerceptionComponent是否有效 ShootThemUp: AI/STUAIController.h protected virtual void Tick(float DeltaTime) override; ShootThemUp: AI/STUAIController.cpp void ASTUAIController::Tick(float DeltaTime) { Super::Tick(DeltaTime); const auto AimActor = STUAIPerceptionComponent-\u0026gt;GetClosestEnemy(); SetFocus(AimActor); } SetFocus函数 # 设置控制器旋转, 使之前进向量朝向给定Actor 查看 # 打开AI调试信息, 使能Perception 在监控释放半径限定的圆内, 除非躲在障碍物之后, 不会脱离NPC捕捉 "}),e.add({id:116,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E8%82%8C%E8%82%89%E6%9D%BE%E5%BC%9B%E6%95%88%E6%9E%9C/",title:"肌肉松弛效果",description:"说明 # Mesh Relaxation 使用游戏角色身体的物理仿真来替换死亡动画, 该技术被称作 Ragdoll Physics 游戏角色骨骼在重力的作用下跌倒 代码实现 # ShootThemUp: Player/STUBaseCharacter.cpp 检查网格体组件获取 // BeginPlay check(GetMesh()); 游戏角色死亡时 屏蔽动画播放 设置碰撞使能为QueryAndPhysics或者PhysicsOnly 激活物理仿真 // OnDeath GetMesh()-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics); GetMesh()-\u0026gt;SetSimulatePhysics(true); ",content:"说明 # Mesh Relaxation 使用游戏角色身体的物理仿真来替换死亡动画, 该技术被称作 Ragdoll Physics 游戏角色骨骼在重力的作用下跌倒 代码实现 # ShootThemUp: Player/STUBaseCharacter.cpp 检查网格体组件获取 // BeginPlay check(GetMesh()); 游戏角色死亡时 屏蔽动画播放 设置碰撞使能为QueryAndPhysics或者PhysicsOnly 激活物理仿真 // OnDeath GetMesh()-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics); GetMesh()-\u0026gt;SetSimulatePhysics(true); "}),e.add({id:117,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A1%A5%E7%BB%99/%E8%A1%A5%E7%BB%99%E7%BB%95z%E8%BD%B4%E6%97%8B%E8%BD%AC/",title:"补给绕Z轴旋转",description:"说明 # 让补给绕Z轴旋转, 旋转角度为给定范围里的随机值 添加属性 # ShootThemUp: Pickups/STUBasePickup.h private float RotationYaw = 0.0f; 添加接口 # ShootThemUp: Pickups/STUBasePickup.h private void GenerateRotationYaw(); ShootThemUp: Pickups/STUBasePickup.cpp // BeginPlay GenerateRotationYaw(); // Respawn GenerateRotationYaw(); // Tick AddActorLocalRotation(FRotator(0.0f, RotationYaw, 0.0f)); // AddActorWorldRotation void ASTUBasePickup::GenerateRotationYaw() { const auto Direction = FMath::RandBool() ? -1.0f : 1.0f; RotationYaw = FMath::RandRange(1.0f, 2.0f) * Direction; } 查看 # 按下按钮, 控制器释放对游戏角色的控制, 可以选择场景中的任意物体进行观察 在本地座标系和世界座标系间进行切换 ",content:"说明 # 让补给绕Z轴旋转, 旋转角度为给定范围里的随机值 添加属性 # ShootThemUp: Pickups/STUBasePickup.h private float RotationYaw = 0.0f; 添加接口 # ShootThemUp: Pickups/STUBasePickup.h private void GenerateRotationYaw(); ShootThemUp: Pickups/STUBasePickup.cpp // BeginPlay GenerateRotationYaw(); // Respawn GenerateRotationYaw(); // Tick AddActorLocalRotation(FRotator(0.0f, RotationYaw, 0.0f)); // AddActorWorldRotation void ASTUBasePickup::GenerateRotationYaw() { const auto Direction = FMath::RandBool() ? -1.0f : 1.0f; RotationYaw = FMath::RandRange(1.0f, 2.0f) * Direction; } 查看 # 按下按钮, 控制器释放对游戏角色的控制, 可以选择场景中的任意物体进行观察 在本地座标系和世界座标系间进行切换 "}),e.add({id:118,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%99%9A%E5%B9%BB%E8%BF%90%E5%8A%A8%E5%9B%BE%E8%A1%A8/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB/",title:"观察者模式下的窗口部件以及元素动画",description:"说明 # 角色死亡进入观察者视角时隐藏窗口部件, 并显示死亡状态 Spectator Widget 概览 # 添加接口: 判断游戏角色死亡和观察者模式 游戏角色死亡后隐藏进度条、瞄准十字和武器信息 游戏角色死亡后添加加载图标和提示, 并提示添加动画 添加接口 # STUPlayerHUDWidget 获取健康组件 判断游戏角色死亡 判断观察者模式 ShootThemUp: UI/STUPlayerHUDWidget.h class USTUHealthComponent; // private USTUHealthComponent *GetHealthComponent() const; // public UFUNCTION(BlueprintCallable) bool IsPlayerAlive() const; UFUNCTION(BlueprintCallable) bool IsPlayerSpectating() const; ShootThemUp: UI/STUPlayerHUDWidget.cpp USTUHealthComponent *USTUPlayerHUDWidget::GetHealthComponent() const { const auto Player = GetOwningPlayerPawn(); if (!Player) return nullptr; const auto Component = Player-\u0026gt;GetComponentByClass(USTUHealthComponent::StaticClass()); const auto HealthComponent = Cast\u0026lt;USTUHealthComponent\u0026gt;(Component); return HealthComponent; } bool USTUPlayerHUDWidget::IsPlayerAlive() const { const auto HealthComponent = GetHealthComponent(); return HealthComponent \u0026amp;\u0026amp; !",content:"说明 # 角色死亡进入观察者视角时隐藏窗口部件, 并显示死亡状态 Spectator Widget 概览 # 添加接口: 判断游戏角色死亡和观察者模式 游戏角色死亡后隐藏进度条、瞄准十字和武器信息 游戏角色死亡后添加加载图标和提示, 并提示添加动画 添加接口 # STUPlayerHUDWidget 获取健康组件 判断游戏角色死亡 判断观察者模式 ShootThemUp: UI/STUPlayerHUDWidget.h class USTUHealthComponent; // private USTUHealthComponent *GetHealthComponent() const; // public UFUNCTION(BlueprintCallable) bool IsPlayerAlive() const; UFUNCTION(BlueprintCallable) bool IsPlayerSpectating() const; ShootThemUp: UI/STUPlayerHUDWidget.cpp USTUHealthComponent *USTUPlayerHUDWidget::GetHealthComponent() const { const auto Player = GetOwningPlayerPawn(); if (!Player) return nullptr; const auto Component = Player-\u0026gt;GetComponentByClass(USTUHealthComponent::StaticClass()); const auto HealthComponent = Cast\u0026lt;USTUHealthComponent\u0026gt;(Component); return HealthComponent; } bool USTUPlayerHUDWidget::IsPlayerAlive() const { const auto HealthComponent = GetHealthComponent(); return HealthComponent \u0026amp;\u0026amp; !HealthComponent-\u0026gt;IsDead(); } bool USTUPlayerHUDWidget::IsPlayerSpectating() const { const auto Controller = GetOwningPlayer(); return Controller \u0026amp;\u0026amp; Controller-\u0026gt;GetStateName() == NAME_Spectating; } 获取生命值百分比时使用获取健康组件函数 # ShootThemUp: UI/STUPlayerHUDWidget.cpp // GetHealthPercent const auto HealthComponent = GetHealthComponent(); 游戏角色死亡后隐藏窗口部件所有元素 # WBP_PlayerHUD 画布面板 Canvas Panel 是进度条、瞄准十字和水平对齐盒的上级元素 隐藏画布面板 分别隐藏进度条、瞄准十字和水平对齐盒 分别隐藏三个元素 # 隐藏进度条 # 选中进度条, Details \u0026gt; Behavior \u0026gt; Visibility , 添加绑定, 命名为 Is Player Alive 通过窗口部件提供的 IsPlayerAlive 处理 检查绑定 隐藏瞄准十字 # 选中图片, Details \u0026gt; Behavior \u0026gt; Visibility , 绑定 Is Player Alive 隐藏武器信息 # 选中水平对齐盒, 处理同上 查看 # 死亡后窗口部件全部隐藏 恢复三个元素 Details \u0026gt; Behavior \u0026gt; Visibility 设置 添加窗口部件蓝图 # Content/UI 创建窗口部件蓝图, 命名为WBP_AboveHUD, 基类为STUPlayerHUDWidget 添加元素: 层级 # Overlay 支持分组元素的容器, 下级元素属于同一层级. 层级之间相互叠加 在当前窗口部件添加其他窗口部件 # 窗口部件可以相互包含 Palette \u0026gt; USER CREATED \u0026gt; WBP Player HUD , 添加 设置水平和垂直填充 选中WBP_PlayerHUD, Details \u0026gt; Behavior \u0026gt; Visibility \u0026gt; Bind \u0026gt; Create Binding , 命名为Is Player Alive 设置当前使用的关卡部件蓝图 # BP_STUGameHUD 观察者状态显示游戏角色状态 # 添加窗口部件蓝图 # Content/UI 创建窗口部件蓝图, 命名为WBP_SpectatorHUD, 基类为STUPlayerHUDWidget 添加元素: 画布面板 # Canvas Panel 添加元素: 层级 # Overlay 设置大小 Details \u0026gt; Slot \u0026gt; Size X = Size Y = 200 设置锚居中 设置位置 Details \u0026gt; Slot \u0026gt; Position X = Position Y = 0 设置对齐 Details \u0026gt; Slot \u0026gt; Alignment \u0026gt; X = Y = 0.5 添加元素: 文本 # Text Details \u0026gt; Content \u0026gt; Text , 设置为Dead 设置 Horizontal Alignment 为居中 设置 Vertical Alignment 为居中 添加元素: 转圈加载图标 # Circular Throbber Preloader 设置填充 Details \u0026gt; Slot 设置 Horizontal Alignment 为填充 设置 Vertical Alignment 为填充 设置分片数 设置 Details \u0026gt; Appearance \u0026gt; Number of Pieces 为14 设置周期 设置 Details \u0026gt; Appearance \u0026gt; Period 为2 设置颜色 设置 Details \u0026gt; Image \u0026gt; Tint 为红色 添加观察者窗口部件 # WBP_AboveHUD 添加 Palette \u0026gt; USER CREATED \u0026gt; WBP Spectator HUD Details \u0026gt; Slot 设置 Horizontal Alignment 为填充 设置 Vertical Alignment 为填充 为可见性添加绑定 Details \u0026gt; Behavior \u0026gt; Visibility , 命名为Is Player Spectating 为观察者窗口部件文本添加动画 # WBP_SpectatorHUD 使用虚幻运动图表的动画编辑器为用户接口元素添加动画属性 选中Text, 打开动画窗口 选择添加动画 命名为TextBlinking 选择TextBlinking, 为其添加轨道 选择Text, 命名为DeatTextBlock 移动时间线到0.35(s), 为轨道关键帧 Keyframe 添加属性 Color and Opacity 设置为红色 移动时间线到0.7(s), 为轨道关键帧添加属性 Color and Opacity , 设置为白色 播放元素动画 # WBP_SpectatorHUD \u0026gt; Graph 添加动画变量 # 将 My Bluepint \u0026gt; VARIABLES \u0026gt; Animations \u0026gt; TextBlinking 拖动到蓝图, 选择 Get TextBlinking 播放动画 # 添加节点: Play Animation 设置循环播放: 将 NumLoopsToPlay 设为0 事件触发 # 方法一: Event Construct 之后执行 Play Animation 方法二: 添加节点 User Interface \u0026gt; Event On Initialized , 之后执行 Play Animation Event On Initialized 更像BeginPlay, 只在游戏开始时调用 "}),e.add({id:119,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/smex/",title:"smex",description:"M-x提示 smex-安装 # ;; (use-package smex ;; :ensure t ;; :config ((smex-initialize) ;; (global-set-key (kbd \u0026quot;M-x\u0026quot;) 'smex) ;; (global-set-key (kbd \u0026quot;M-X\u0026quot;) 'smex-major-mode-commands) ;; (global-set-key (kbd \u0026quot;C-c C-c M-x\u0026quot;) 'execute-extended-command) ;; This is your old M-x. ;; )) ",content:"M-x提示 smex-安装 # ;; (use-package smex ;; :ensure t ;; :config ((smex-initialize) ;; (global-set-key (kbd \u0026quot;M-x\u0026quot;) 'smex) ;; (global-set-key (kbd \u0026quot;M-X\u0026quot;) 'smex-major-mode-commands) ;; (global-set-key (kbd \u0026quot;C-c C-c M-x\u0026quot;) 'execute-extended-command) ;; This is your old M-x. ;; )) "}),e.add({id:120,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E8%A1%A8%E6%A0%BC%E4%B8%AD%E6%96%87%E5%AF%B9%E9%BD%90/",title:"表格中文对齐",description:"便签 # 参考 方法一: 使用valign # 像素对齐 使用时会导致图片加载卡顿 ;; (use-package valign ;; :ensure t ;; ) ;; (add-hook 'org-mode-hook #'valign-mode) 方法二: 使用cnfonts # GitHub 字体受到cnfonts支持的限制 ;; (use-package cnfonts ;; :ensure t) ;; (cnfonts-mode 1) ;; (define-key cnfonts-mode-map (kbd \u0026quot;C--\u0026quot;) #'cnfonts-decrease-fontsize) ;; (define-key cnfonts-mode-map (kbd \u0026quot;C-=\u0026quot;) #'cnfonts-increase-fontsize) 方法三: 分别对中文字体和英文字体进行设置 # 找到满足英文:中文=1:2的两个字体 下载Iosevka # GitHub # brew tap homebrew/cask-fonts # brew install font-iosevka 设置Emacs中英文字体 # 字号使用14, 16正常 ;; (let ((default-font (font-spec :name \u0026quot;Iosevka\u0026quot; :size 14)) ;; (cn-font (font-spec :name \u0026quot;Sarasa Mono SC\u0026quot;))) ;; (set-face-attribute 'default nil :font default-font) ;; (dolist (charset '(kana han symbol cjk-misc bopomofo)) ;; (set-fontset-font t charset cn-font))) 方法四: 对org-mode表格字体进行设置 # 要求字体英文:中文=1:2 下载更纱字体 # # brew install font-sarasa-gothic 设置表格字体 # 更纱黑体 # ;; (custom-set-faces ;; '(org-table ((t (:family \u0026quot;等距更纱黑体 SC\u0026quot;))))) Iosevka # (custom-set-faces '(org-table ((t (:family \u0026quot;Iosevka\u0026quot;))))) Sarasa Mono SC # ;; (custom-set-faces ;; '(org-table ((t (:family \u0026quot;Sarasa Mono SC\u0026quot;))))) 设置Emacs字体 # ;; (let ((emacs-font-size 14) ;; (emacs-font-name \u0026quot;Victor Mono\u0026quot;)) ;; (set-frame-font (format \u0026quot;%s-%s\u0026quot; (eval emacs-font-name) (eval emacs-font-size))) ;; (set-fontset-font (frame-parameter nil 'font) 'unicode (eval emacs-font-name))) ",content:"便签 # 参考 方法一: 使用valign # 像素对齐 使用时会导致图片加载卡顿 ;; (use-package valign ;; :ensure t ;; ) ;; (add-hook 'org-mode-hook #'valign-mode) 方法二: 使用cnfonts # GitHub 字体受到cnfonts支持的限制 ;; (use-package cnfonts ;; :ensure t) ;; (cnfonts-mode 1) ;; (define-key cnfonts-mode-map (kbd \u0026quot;C--\u0026quot;) #'cnfonts-decrease-fontsize) ;; (define-key cnfonts-mode-map (kbd \u0026quot;C-=\u0026quot;) #'cnfonts-increase-fontsize) 方法三: 分别对中文字体和英文字体进行设置 # 找到满足英文:中文=1:2的两个字体 下载Iosevka # GitHub # brew tap homebrew/cask-fonts # brew install font-iosevka 设置Emacs中英文字体 # 字号使用14, 16正常 ;; (let ((default-font (font-spec :name \u0026quot;Iosevka\u0026quot; :size 14)) ;; (cn-font (font-spec :name \u0026quot;Sarasa Mono SC\u0026quot;))) ;; (set-face-attribute 'default nil :font default-font) ;; (dolist (charset '(kana han symbol cjk-misc bopomofo)) ;; (set-fontset-font t charset cn-font))) 方法四: 对org-mode表格字体进行设置 # 要求字体英文:中文=1:2 下载更纱字体 # # brew install font-sarasa-gothic 设置表格字体 # 更纱黑体 # ;; (custom-set-faces ;; '(org-table ((t (:family \u0026quot;等距更纱黑体 SC\u0026quot;))))) Iosevka # (custom-set-faces '(org-table ((t (:family \u0026quot;Iosevka\u0026quot;))))) Sarasa Mono SC # ;; (custom-set-faces ;; '(org-table ((t (:family \u0026quot;Sarasa Mono SC\u0026quot;))))) 设置Emacs字体 # ;; (let ((emacs-font-size 14) ;; (emacs-font-name \u0026quot;Victor Mono\u0026quot;)) ;; (set-frame-font (format \u0026quot;%s-%s\u0026quot; (eval emacs-font-name) (eval emacs-font-size))) ;; (set-fontset-font (frame-parameter nil 'font) 'unicode (eval emacs-font-name))) "}),e.add({id:121,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%9C%8D%E5%8A%A1/",title:"自定义行为树服务",description:"说明 # AI Service / AIDecorator BTService # 添加到行为树节点的特殊类. 自带Tick函数, 在其中实现游戏逻辑. 在给定条件, 可以修改黑板中的变量值. 本节将通过服务重写定位敌人逻辑, 当敌人出现在NPC的捕捉范围内, 计算得到敌人附近一点, 使NPC跑去该位置. 可以添加到行为树的任意节点 添加黑板变量 # BB_STUCharacter 添加类型为Object的变量, 命名为EnemyActor; 存放选中敌人 创建行为树服务类 # - AI/Services 基类 BTService Public 名称 STUFindEnemyService 每秒搜索距离NPC最近的敌人 修改头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon/Components\u0026quot;, \u0026quot;ShootThemUp/Public/AI\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Tasks\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Services\u0026quot; }); 添加构造函数 # public ShootThemUp: AI/Services/STUFindEnemyService.h USTUFindEnemyService(); 设置服务名称 ShootThemUp: AI/Services/STUFindEnemyService.cpp USTUFindEnemyService::USTUFindEnemyService() { NodeName = \u0026quot;Find Enemy\u0026quot;; } 添加属性: 存放黑板变量信息 # protected ShootThemUp: AI/Services/STUFindEnemyService.",content:"说明 # AI Service / AIDecorator BTService # 添加到行为树节点的特殊类. 自带Tick函数, 在其中实现游戏逻辑. 在给定条件, 可以修改黑板中的变量值. 本节将通过服务重写定位敌人逻辑, 当敌人出现在NPC的捕捉范围内, 计算得到敌人附近一点, 使NPC跑去该位置. 可以添加到行为树的任意节点 添加黑板变量 # BB_STUCharacter 添加类型为Object的变量, 命名为EnemyActor; 存放选中敌人 创建行为树服务类 # - AI/Services 基类 BTService Public 名称 STUFindEnemyService 每秒搜索距离NPC最近的敌人 修改头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon/Components\u0026quot;, \u0026quot;ShootThemUp/Public/AI\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Tasks\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Services\u0026quot; }); 添加构造函数 # public ShootThemUp: AI/Services/STUFindEnemyService.h USTUFindEnemyService(); 设置服务名称 ShootThemUp: AI/Services/STUFindEnemyService.cpp USTUFindEnemyService::USTUFindEnemyService() { NodeName = \u0026quot;Find Enemy\u0026quot;; } 添加属性: 存放黑板变量信息 # protected ShootThemUp: AI/Services/STUFindEnemyService.h UPROPERTY(EditAnywhere, BlueprintReadWrite) FBlackboardKeySelector EnemyActorKey; 添加TickNode函数 # 可以设置调用频率; 在此定位敌人 protected ShootThemUp: AI/Services/STUFindEnemyService.h virtual void TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) override; ShootThemUp: AI/Services/STUFindEnemyService.cpp #include \u0026quot;BehaviorTree/BlackboardComponent.h\u0026quot; #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; #include \u0026quot;Components/STUAIPerceptionComponent.h\u0026quot; void USTUFindEnemyService::TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) { const auto Blackboard = OwnerComp.GetBlackboardComponent(); if (Blackboard) { const auto Controller = OwnerComp.GetAIOwner(); const auto PerceptionComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUAIPerceptionComponent\u0026gt;(Controller); if (PerceptionComponent) { Blackboard-\u0026gt;SetValueAsObject(EnemyActorKey.SelectedKeyName, PerceptionComponent-\u0026gt;GetClosestEnemy()); } } Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds); } SetValueAsObject函数 # 第一个参数: 变量名 第二个参数: 给出指向敌人的UObject指针 在AIController中使用服务 # 添加属性: 存放变量名 # 无法使用选择器, Controller不涉及黑板变量逻辑 ShootThemUp: AI/STUAIController.h UPROPERTY(EditAnywhere, BlueprintReadWrite) FName FocusOnKeyName = \u0026quot;EnemyActor\u0026quot;; 添加接口: 返回敌人对象 # private ShootThemUp: AI/STUAIController.h AActor *GetFocusOnActor() const; ShootThemUp: AI/STUAIController.cpp #include \u0026quot;BehaviorTree/BlackboardComponent.h\u0026quot; AActor *ASTUAIController::GetFocusOnActor() const { if (!GetBlackboardComponent()) return nullptr; return Cast\u0026lt;AActor\u0026gt;(GetBlackboardComponent()-\u0026gt;GetValueAsObject(FocusOnKeyName)); } 在Tick函数中使用服务 # 不直接使用感知组件接口 ShootThemUp: AI/STUAIController.cpp // Tick const auto AimActor = GetFocusOnActor(); NPC行为树 # BT_STUCharacter NPC有两个职责: 在地图上巡逻 将序列命名为Random roam 攻击 添加节点: Sequence, 命名为Attack 添加节点: Selector # 从左到右运行子树. 若排行较前的子树返回Fail, 则执行下一子树 为Selector添加服务: 一直查找敌人 # 右键 Selector , Add Service \u0026gt; STUFindEnemyService 设置STUFindEnemyService # - 说明 EnemyActorKey EnemyActor Service \u0026gt; Interval Tick调用频率上限F Service \u0026gt; RandomDeviation Tick调用频率活动范围FR Tick实际调用频率在F-FR ~ F+FR之间 为Attack添加任务: MoveTo # Blackboard Key无法选择EnemyActor 设置黑板变量EnemyActor # BB_STUCharacter \u0026gt; Enemy Actor \u0026gt; Blackboard Details \u0026gt; Key Type \u0026gt; Base Class , 设置为Actor : UObject对象在世界中不具有变化属性 设置MoveTo目的地为EnemyActor; 勾选 Observe Blackboard Value # 变量值发生改变时, 新目的地立即生效 查看 # UE4.27: 当Find Enemy不为空, 且无法找到AimLocation时, 才会执行Attack序列 UE5.1: 定时执行Find Enemy, 从左到右执行Attack和Rand roam; Enemy Actor不为空, 靠近选中敌人, 为空, 去到随机生成的位置 使用Decorator # Decorator包含逻辑判断, 类似switch, 可以中断整棵子树 根据EnemyActor的设置情况, 决定执行哪个序列 为Attack添加Decorator: Blackboard # Blackboard会检查黑板变量的值 选中 Blackboard Based Condition Details \u0026gt; Description \u0026gt; Node Name 命名为 Has Enemy Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 选中EnemyActor Details \u0026gt; Blackboard \u0026gt; Key Query , 选择IsSet分支 Details \u0026gt; Flow Control \u0026gt; Observer aborts , 选择Self 若EnemyActor有值, 执行Attack, 否则中止序列 为Random roam添加Decorator # 命名为No Enemy Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 选中EnemyActor Details \u0026gt; Blackboard \u0026gt; Key Query , 选择IsNotSet分支 Details \u0026gt; Flow Control \u0026gt; Observer aborts , 选择Self 若EnemyActor没有值, 执行Random roam, 否则中止序列 使NPC移动到敌人附近 # 添加标志位: 以自身为圆心寻找随机点 巡逻 ; 以敌人为圆心寻找随机点 攻击 protected ShootThemUp: AI/Tasks/STUNextLocationTask.h UPROPERTY(EditAnywhere, BlueprintReadWrite) bool SelfCenter = true; 添加属性: 如果以敌人为圆心寻找随机点, 保存敌人信息 protected ShootThemUp: AI/Tasks/STUNextLocationTask.h UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EditCondition = \u0026quot;!SelfCenter\u0026quot;)) FBlackboardKeySelector CenterActorKey; 设置随机位置中心点 ShootThemUp: AI/Tasks/STUNextLocationTask.cpp // ExecuteTask auto Location = Pawn-\u0026gt;GetActorLocation(); if (!SelfCenter) { auto CenterActor = Cast\u0026lt;AActor\u0026gt;(Blackboard-\u0026gt;GetValueAsObject(CenterActorKey.SelectedKeyName)); if (!CenterActor) return EBTNodeResult::Failed; Location = CenterActor-\u0026gt;GetActorLocation(); } const auto Found = NavSys-\u0026gt;GetRandomReachablePointInRadius(Location, Radius, NavLocation); 设置Attack序列 # 添加任务: STUNextLocationTask 进行如下设置 设置MoveTo目的地 "}),e.add({id:122,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%8F%97%E5%88%B0%E4%BC%A4%E5%AE%B3%E6%97%B6%E4%B8%BA%E6%91%84%E5%83%8F%E6%9C%BA%E6%B7%BB%E5%8A%A0%E6%8A%96%E5%8A%A8/",title:"游戏角色受到伤害时为摄像机添加抖动",description:"说明 # MatineeCameraShake 已被 LegacyCameraShake 取代 创建抖动蓝图类 # Content/VFX 右键, Blueprint Class 选择基类 LegacyCameraSh , 命名为BP_DamageCameraShake 开箱即用的解决方案让我们可以很快的实现抖动效果 双击打开, 查看细节面板 Oscillation \u0026gt; Oscillation Duration : 摄像机晃动的时间 绕各轴的振动, 如 Pitch, Yaw, 和 Roll 测试抖动类 # 为摄像机添加抖动 # BP_STUPlayerController \u0026gt; EventGraph 添加节点 GetPlayerCameraManager , 作为节点 StartCameraShake 的输入; 在Tick函数中调用; 设置抖动类为BP_DamageCameraShake 设置抖动时长 # BP_DamageCameraShake 设置 Oscillation Duration 为0.2 添加垂直方向 Pitch 和水平方向 Yaw 的抖动 如果添加摄像机旋转 Roll 抖动, 有地板晃动效果, 暂不需要 抖动参数由设计师提供 断开摄像机抖动 # BP_STUPlayerController \u0026gt; EventGraph 游戏角色受伤时为摄像机添加抖动 # 添加依赖模块GameplayCameras # ShootThemUp: ShootThemUp.",content:"说明 # MatineeCameraShake 已被 LegacyCameraShake 取代 创建抖动蓝图类 # Content/VFX 右键, Blueprint Class 选择基类 LegacyCameraSh , 命名为BP_DamageCameraShake 开箱即用的解决方案让我们可以很快的实现抖动效果 双击打开, 查看细节面板 Oscillation \u0026gt; Oscillation Duration : 摄像机晃动的时间 绕各轴的振动, 如 Pitch, Yaw, 和 Roll 测试抖动类 # 为摄像机添加抖动 # BP_STUPlayerController \u0026gt; EventGraph 添加节点 GetPlayerCameraManager , 作为节点 StartCameraShake 的输入; 在Tick函数中调用; 设置抖动类为BP_DamageCameraShake 设置抖动时长 # BP_DamageCameraShake 设置 Oscillation Duration 为0.2 添加垂直方向 Pitch 和水平方向 Yaw 的抖动 如果添加摄像机旋转 Roll 抖动, 有地板晃动效果, 暂不需要 抖动参数由设计师提供 断开摄像机抖动 # BP_STUPlayerController \u0026gt; EventGraph 游戏角色受伤时为摄像机添加抖动 # 添加依赖模块GameplayCameras # ShootThemUp: ShootThemUp.Build.cs PublicDependencyModuleNames.AddRange(new string[] { \u0026quot;Core\u0026quot;, \u0026quot;CoreUObject\u0026quot;, \u0026quot;Engine\u0026quot;, \u0026quot;InputCore\u0026quot;, \u0026quot;Niagara\u0026quot;, \u0026quot;PhysicsCore\u0026quot;, \u0026quot;GameplayCameras\u0026quot; }); 添加抖动类属性 # ShootThemUp: Components/STUHealthComponent.h protected class UCameraShakeBase; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) TSubclassOf\u0026lt;UCameraShakeBase\u0026gt; CameraShake; 添加接口: 使摄像机抖动 # ShootThemUp: Components/STUHealthComponent.h private void PlayCameraShake(); 受到伤害时调用 ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage PlayCameraShake(); 要求游戏角色未死亡 #include \u0026quot;GameFramework/Pawn.h\u0026quot; #include \u0026quot;GameFramework/PlayerController.h\u0026quot; #include \u0026quot;LegacyCameraShake.h\u0026quot; void USTUHealthComponent::PlayCameraShake() { if (IsDead()) return; const auto Player = Cast\u0026lt;APawn\u0026gt;(GetOwner()); if (!Player) return; const auto Controller = Player-\u0026gt;GetController\u0026lt;APlayerController\u0026gt;(); if (!Controller || !Controller-\u0026gt;PlayerCameraManager) return; Controller-\u0026gt;PlayerCameraManager-\u0026gt;StartCameraShake(CameraShake); } 查看 # BP_BaseCharacter 设置抖动类为BP_DamageCameraShake 选中伤害球, 调整伤害数值 Details \u0026gt; Damage , 设为0.5 当受到其他游戏角色的射击伤害时, 有所察觉 "}),e.add({id:123,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A1%A5%E7%BB%99/%E9%87%8D%E6%9E%84%E5%92%8C%E6%89%93%E5%8C%85/",title:"重构和打包",description:"更改 # 没有弹药时, 不需要做加法 ShootThemUp: Weapon/STUBaseWeapon.cpp // TryToAddAmmo CurrentAmmo.Clips = FMath::Clamp(ClipsAmount, 0, DefaultAmmo.Clips + 1); ",content:"更改 # 没有弹药时, 不需要做加法 ShootThemUp: Weapon/STUBaseWeapon.cpp // TryToAddAmmo CurrentAmmo.Clips = FMath::Clamp(ClipsAmount, 0, DefaultAmmo.Clips + 1); "}),e.add({id:124,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%99%9A%E5%B9%BB%E8%BF%90%E5%8A%A8%E5%9B%BE%E8%A1%A8/%E9%87%8D%E6%9E%84%E5%92%8C%E6%89%93%E5%8C%85/",title:"重构和打包",description:"重构 # 实现模板函数: 获取Pawn组件 # 添加头文件 # 预编译命令应为pragma once, 代码框中有遗漏错误 Public/STUUtil.h #pragma class APawn; class STUUtils { public: template\u0026lt;typename T\u0026gt; static T* GetSTUPlayerComponent(APawn *PlayerPawn) { if (!PlayerPawn) return nullptr; const auto Component = PlayerPawn-\u0026gt;GetComponentByClass(T::StaticClass()); return Cast\u0026lt;T\u0026gt;(Component); } }; 修改获取Pawn组件的地方 # ShootThemUp: UI/STUPlayerHUDWidget.cpp #include \u0026quot;STUUtils.h\u0026quot; // GetHealthPercent, IsPlayerAlive const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(GetOwningPlayerPawn()); // GetCurrentWeaponUIData, GetCurrentWeaponAmmoData const auto WeaponComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUWeaponComponent\u0026gt;(GetOwningPlayerPawn()); 屏蔽GetWeaponComponent和GetHealthComponent # ShootThemUp: UI/STUPlayerHUDWidget.cpp 定义 ShootThemUp: UI/STUPlayerHUDWidget.h 屏蔽USTUWeaponComponent和USTUHealthComponent的前向声明 屏蔽GetWeaponComponent和GetHealthComponent 屏蔽弹药日志 # ShootThemUp: Weapon/STUBaseWeapon.",content:"重构 # 实现模板函数: 获取Pawn组件 # 添加头文件 # 预编译命令应为pragma once, 代码框中有遗漏错误 Public/STUUtil.h #pragma class APawn; class STUUtils { public: template\u0026lt;typename T\u0026gt; static T* GetSTUPlayerComponent(APawn *PlayerPawn) { if (!PlayerPawn) return nullptr; const auto Component = PlayerPawn-\u0026gt;GetComponentByClass(T::StaticClass()); return Cast\u0026lt;T\u0026gt;(Component); } }; 修改获取Pawn组件的地方 # ShootThemUp: UI/STUPlayerHUDWidget.cpp #include \u0026quot;STUUtils.h\u0026quot; // GetHealthPercent, IsPlayerAlive const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(GetOwningPlayerPawn()); // GetCurrentWeaponUIData, GetCurrentWeaponAmmoData const auto WeaponComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUWeaponComponent\u0026gt;(GetOwningPlayerPawn()); 屏蔽GetWeaponComponent和GetHealthComponent # ShootThemUp: UI/STUPlayerHUDWidget.cpp 定义 ShootThemUp: UI/STUPlayerHUDWidget.h 屏蔽USTUWeaponComponent和USTUHealthComponent的前向声明 屏蔽GetWeaponComponent和GetHealthComponent 屏蔽弹药日志 # ShootThemUp: Weapon/STUBaseWeapon.cpp DecreaseAmmo 修改生命值百分比和武器信息颜色 # WBP_PlayerHUD 进度条 # 移动到左下角; 修改颜色 文本框 # 修改颜色 武器图标 # 进入到 GetWeaponIcon MakeSlateBrush , 展开Tint针脚; 修改颜色 修改元素名 # 打包 # "}),e.add({id:125,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/counsel/",title:"counsel",description:"概览 # 提供M-x提示、打开文件等功能 支持在文件夹内所有文件中查找文本, 通过在Shell执行ag命令完成, 需要安装the_silver_searcher the_silver_searcher # macOS 便签 # GitHub 安装 # # brew install the_silver_searcher ag支持目录中查找, 速度快, 高亮匹配 # # ag fact grep需给定文件信息 # # grep fact *.cpp counsel-安装 # (use-package counsel :ensure t :config (progn (global-set-key (kbd \u0026quot;M-x\u0026quot;) 'counsel-M-x) ;; M-x (global-set-key (kbd \u0026quot;C-x C-f\u0026quot;) 'counsel-find-file) ;; 查找文件 (global-set-key (kbd \u0026quot;C-c k\u0026quot;) 'counsel-ag) ;; 目录下查找 ;; (global-set-key (kbd \u0026quot;C-c C-r\u0026quot;) 'ivy-resume) ;; (global-set-key (kbd \u0026quot;\u0026lt;f1\u0026gt; f\u0026quot;) 'counsel-describe-function) ;; (global-set-key (kbd \u0026quot;\u0026lt;f1\u0026gt; v\u0026quot;) 'counsel-describe-variable) ;; (global-set-key (kbd \u0026quot;\u0026lt;f1\u0026gt; o\u0026quot;) 'counsel-describe-symbol) ;; (global-set-key (kbd \u0026quot;\u0026lt;f1\u0026gt; l\u0026quot;) 'counsel-find-library) ;; (global-set-key (kbd \u0026quot;\u0026lt;f2\u0026gt; i\u0026quot;) 'counsel-info-lookup-symbol) ;; (global-set-key (kbd \u0026quot;\u0026lt;f2\u0026gt; u\u0026quot;) 'counsel-unicode-char) ;; (global-set-key (kbd \u0026quot;C-c g\u0026quot;) 'counsel-git) ;; (global-set-key (kbd \u0026quot;C-c j\u0026quot;) 'counsel-git-grep) ;; (global-set-key (kbd \u0026quot;C-x l\u0026quot;) 'counsel-locate) ;; (global-set-key (kbd \u0026quot;C-S-o\u0026quot;) 'counsel-rhythmbox) ;; (define-key minibuffer-local-map (kbd \u0026quot;C-r\u0026quot;) 'counsel-minibuffer-history) )) counsel-快捷键 # - M-x提示 counsel-M-x M-x 打开文件 counsel-find-file C-x C-f 文件夹内所有文件中查找文本 counsel-ag C-c k 打开文件(版本控制) counsel-git C-c g buffer切换 counsel-switch-buffer C-x b 打开文件 # 不能使用Delete键删除路径, 输入.",content:"概览 # 提供M-x提示、打开文件等功能 支持在文件夹内所有文件中查找文本, 通过在Shell执行ag命令完成, 需要安装the_silver_searcher the_silver_searcher # macOS 便签 # GitHub 安装 # # brew install the_silver_searcher ag支持目录中查找, 速度快, 高亮匹配 # # ag fact grep需给定文件信息 # # grep fact *.cpp counsel-安装 # (use-package counsel :ensure t :config (progn (global-set-key (kbd \u0026quot;M-x\u0026quot;) 'counsel-M-x) ;; M-x (global-set-key (kbd \u0026quot;C-x C-f\u0026quot;) 'counsel-find-file) ;; 查找文件 (global-set-key (kbd \u0026quot;C-c k\u0026quot;) 'counsel-ag) ;; 目录下查找 ;; (global-set-key (kbd \u0026quot;C-c C-r\u0026quot;) 'ivy-resume) ;; (global-set-key (kbd \u0026quot;\u0026lt;f1\u0026gt; f\u0026quot;) 'counsel-describe-function) ;; (global-set-key (kbd \u0026quot;\u0026lt;f1\u0026gt; v\u0026quot;) 'counsel-describe-variable) ;; (global-set-key (kbd \u0026quot;\u0026lt;f1\u0026gt; o\u0026quot;) 'counsel-describe-symbol) ;; (global-set-key (kbd \u0026quot;\u0026lt;f1\u0026gt; l\u0026quot;) 'counsel-find-library) ;; (global-set-key (kbd \u0026quot;\u0026lt;f2\u0026gt; i\u0026quot;) 'counsel-info-lookup-symbol) ;; (global-set-key (kbd \u0026quot;\u0026lt;f2\u0026gt; u\u0026quot;) 'counsel-unicode-char) ;; (global-set-key (kbd \u0026quot;C-c g\u0026quot;) 'counsel-git) ;; (global-set-key (kbd \u0026quot;C-c j\u0026quot;) 'counsel-git-grep) ;; (global-set-key (kbd \u0026quot;C-x l\u0026quot;) 'counsel-locate) ;; (global-set-key (kbd \u0026quot;C-S-o\u0026quot;) 'counsel-rhythmbox) ;; (define-key minibuffer-local-map (kbd \u0026quot;C-r\u0026quot;) 'counsel-minibuffer-history) )) counsel-快捷键 # - M-x提示 counsel-M-x M-x 打开文件 counsel-find-file C-x C-f 文件夹内所有文件中查找文本 counsel-ag C-c k 打开文件(版本控制) counsel-git C-c g buffer切换 counsel-switch-buffer C-x b 打开文件 # 不能使用Delete键删除路径, 输入..返回上层路径 counsel-ag # 文件夹内查找 - 在新窗口输出查询结果 ivy-occur C-c C-o 下一个 next-error M-g n C-x ` 上一个 previous-error M-g p "}),e.add({id:126,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8D%E5%BD%B1%E5%93%8D%E5%BF%AB%E6%8D%B7%E9%94%AE/",title:"使用中文输入法不影响快捷键",description:"说明 # C-c e g不用切换输入法 Vim除Insert模式外锁定英文 逗号和句号使用全角, 其他符号使用半角 安装并配置rime # rime ",content:"说明 # C-c e g不用切换输入法 Vim除Insert模式外锁定英文 逗号和句号使用全角, 其他符号使用半角 安装并配置rime # rime "}),e.add({id:127,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E7%BB%84%E4%BB%B6/%E8%A7%92%E8%89%B2%E8%BF%90%E5%8A%A8%E7%BB%84%E4%BB%B6/",title:"角色运动组件",description:"Character Movement UCharacterMovementComponent # 获取组件上级 # UPawnMovementComponent::GetPawnOwner ",content:"Character Movement UCharacterMovementComponent # 获取组件上级 # UPawnMovementComponent::GetPawnOwner "}),e.add({id:128,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E5%B0%84%E5%87%BB%E6%9C%8D%E5%8A%A1/",title:"射击服务",description:"说明 # 自定义服务: 对距离最近敌人射击 创建服务类 # - base BTService Public AI/Services STUFireService 添加构造函数: 设置名称 # public ShootThemUp: AI/Services/STUFireService.h USTUFireService(); ShootThemUp: AI/Services/STUFireService.cpp USTUFireService::USTUFireService() { NodeName = \u0026quot;Fire\u0026quot;; } 添加属性: 存放敌人信息 # protected ShootThemUp: AI/Services/STUFireService.h UPROPERTY(EditAnywhere, BlueprintReadWrite) FBlackboardKeySelector EnemyActorKey; 服务逻辑: 实现TickNode # protected ShootThemUp: AI/Services/STUFireService.h virtual void TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) override; 不需要检查EnemyActor的设置情况, 上节的Decorator提供检查; 还是推荐一个自给自足的逻辑闭环 ShootThemUp: AI/Services/STUFireService.cpp #include \u0026quot;BehaviorTree/BlackboardComponent.h\u0026quot; #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;Components/STUWeaponComponent.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; void USTUFireService::TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) { const auto Controller = OwnerComp.",content:"说明 # 自定义服务: 对距离最近敌人射击 创建服务类 # - base BTService Public AI/Services STUFireService 添加构造函数: 设置名称 # public ShootThemUp: AI/Services/STUFireService.h USTUFireService(); ShootThemUp: AI/Services/STUFireService.cpp USTUFireService::USTUFireService() { NodeName = \u0026quot;Fire\u0026quot;; } 添加属性: 存放敌人信息 # protected ShootThemUp: AI/Services/STUFireService.h UPROPERTY(EditAnywhere, BlueprintReadWrite) FBlackboardKeySelector EnemyActorKey; 服务逻辑: 实现TickNode # protected ShootThemUp: AI/Services/STUFireService.h virtual void TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) override; 不需要检查EnemyActor的设置情况, 上节的Decorator提供检查; 还是推荐一个自给自足的逻辑闭环 ShootThemUp: AI/Services/STUFireService.cpp #include \u0026quot;BehaviorTree/BlackboardComponent.h\u0026quot; #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;Components/STUWeaponComponent.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; void USTUFireService::TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) { const auto Controller = OwnerComp.GetAIOwner(); const auto Blackboard = OwnerComp.GetBlackboardComponent(); const auto HasAim = Blackboard \u0026amp;\u0026amp; Blackboard-\u0026gt;GetValueAsObject(EnemyActorKey.SelectedKeyName); if (Controller) { const auto WeaponComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUWeaponComponent\u0026gt;(Controller-\u0026gt;GetPawn()); if (WeaponComponent) { HasAim ? WeaponComponent-\u0026gt;FireStart() : WeaponComponent-\u0026gt;FireStop(); } } } 修改武器基类射击逻辑 # STUBaseWeapon NPC的控制器类型为AIController, 控制器相关逻辑需调整 获取子弹轨迹信息: GetTraceData; 调用GetPlayerViewPoint; 被武器派生类的MakeShot调用 APlayerController::GetPlayerViewPoint # AIController不具有类似功能的成员函数 若游戏角色的控制器类型为APlayerController, 走原有逻辑; 自行设置子弹起点和方向向量 ShootThemUp: Weapon/STUBaseWeapon.cpp // GetPlayerViewPoint const auto STUCharacter = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!STUCharacter) return false; if (STUCharacter-\u0026gt;IsPlayerControlled()) { // 原逻辑 } else { ViewLocation = GetMuzzleWorldLocation(); ViewRotation = WeaponMeshComponent-\u0026gt;GetSocketRotation(MuzzleSocketName); } return true; 查看 # 调整NPC视觉感知参数 # BP_STUAIController \u0026gt; STUAIPerceptionComponent - Sight Radius 2000 Lose Sight Radius 2500 PeripheralVisionHalfAngleDegrees 90 设置行为树 # BT_STUCharacter 为Attack添加射击服务 设置射击目标 选中 STUFireService , 设置 Details \u0026gt; STUFire Service \u0026gt; Enemy Actor Key 为EnemyActor 总结 # NPC注意到敌人就可以瞄准射击, 这一点太猛了 之前为NPC添加了转向过渡动画, 而射击在这之前 "}),e.add({id:129,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%8F%97%E4%BC%A4%E6%97%B6%E6%B7%BB%E5%8A%A0%E9%97%AA%E7%83%81%E7%BA%A2%E5%B1%8F/",title:"游戏角色受伤时添加闪烁红屏",description:"说明 # UMG Damage Effect 通过窗口部件实现. 游戏角色受伤时添加闪烁红屏, 作为流血特效 窗口部件 # WBP_PlayerHUD 添加图片 Image 元素, 命名为DamageImage, 移动到层级结构上方 铺满视口 Details \u0026gt; Anchors , 选择铺满 设置Offset Left = Offset Top = Offset Right = Offset Bottom = 0 设置颜色 Details \u0026gt; Appearance \u0026gt; Color and Opacity , 设置为红色; 设置Alpha分量为0 为DamageImage添加动画 # 选中DamageImage, 打开Animations窗口 点击 +Animation , 命名为DamageAnimation 为DamageAnimation添加Track 选择DamageImage 设置关键帧0.25 # 在DamageImage这一栏, 点击 +Track 选择Color and Opacity 设置Alpha通道为0.6 设置关键帧0.5 # 同上, 设置Alpha通道为0 播放DamageImage动画 # WBP_PlayerHUD \u0026gt; Event Graph 稍后在C++中定义事件 添加DamageAnimation变量 作为PlayAnimation的输入 生命值减少触发事件 # 定义蓝图事件 # 使用宏声明符创建蓝图事件, 该函数只声明不定义 ShootThemUp: UI/STUPlayerHUDWidget.",content:`说明 # UMG Damage Effect 通过窗口部件实现. 游戏角色受伤时添加闪烁红屏, 作为流血特效 窗口部件 # WBP_PlayerHUD 添加图片 Image 元素, 命名为DamageImage, 移动到层级结构上方 铺满视口 Details \u0026gt; Anchors , 选择铺满 设置Offset Left = Offset Top = Offset Right = Offset Bottom = 0 设置颜色 Details \u0026gt; Appearance \u0026gt; Color and Opacity , 设置为红色; 设置Alpha分量为0 为DamageImage添加动画 # 选中DamageImage, 打开Animations窗口 点击 +Animation , 命名为DamageAnimation 为DamageAnimation添加Track 选择DamageImage 设置关键帧0.25 # 在DamageImage这一栏, 点击 +Track 选择Color and Opacity 设置Alpha通道为0.6 设置关键帧0.5 # 同上, 设置Alpha通道为0 播放DamageImage动画 # WBP_PlayerHUD \u0026gt; Event Graph 稍后在C++中定义事件 添加DamageAnimation变量 作为PlayAnimation的输入 生命值减少触发事件 # 定义蓝图事件 # 使用宏声明符创建蓝图事件, 该函数只声明不定义 ShootThemUp: UI/STUPlayerHUDWidget.h public UFUNCTION(BlueprintImplementableEvent) void OnTakeDamage(); 生命值减少通知 # 两种方法 定义委托, 游戏角色受伤时通知客户端 修改当前委托定义, 添加额外参数, 显示生命值变化 修改委托 # 修改委托定义
STUCoreTypes.h DECLARE_MULTICAST_DELEGATE_OneParam(FChangeHealthSignature, float); 修改服务端广播
ShootThemUp: Components/STUHealthComponent.cpp // SetHealth const auto NextHealth = FMath::Clamp(NewHealth, 0.0f, MaxHealth); const auto HealthDelta = NextHealth - Health; Health = NextHealth; OnChangeHealth.Broadcast(HealthDelta); 修改客户端
处理函数声明 ShootThemUp: Player/STUBaseCharacter.h void OnChangeHealth(float HealthDelta); 处理函数定义 ShootThemUp: Player/STUBaseCharacter.cpp 窗口部件类订阅生命值减少委托, 并触发事件 # 处理函数
ShootThemUp: UI/STUPlayerHUDWidget.h private void OnChangeHealth(float HealthDelta); 触发事件 ShootThemUp: UI/STUPlayerHUDWidget.cpp void USTUPlayerHUDWidget::OnChangeHealth(float HealthDelta) { if (HealthDelta \u0026lt; 0.0f) { OnTakeDamage(); } } 在Initialize函数中完成订阅
ShootThemUp: UI/STUPlayerHUDWidget.h private virtual bool Initialize() override; ShootThemUp: UI/STUPlayerHUDWidget.cpp bool USTUPlayerHUDWidget::Initialize() { const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(GetOwningPlayerPawn()); if (HealthComponent) { HealthComponent-\u0026gt;OnChangeHealth.AddUObject(this, \u0026amp;USTUPlayerHUDWidget::OnChangeHealth); } return Super::Initialize(); } 在蓝图中添加事件 # WBP_PlayerHUD \u0026gt; EventGraph 事件发生时播放DamageAnimation动画 受到伤害时, 有序播放动画 # WBP_PlayerHUD \u0026gt; EventGraph 添加节点 IsAnimationPlaying 判断当前动画播放状态; 添加分支: 事件发生时, 若未播放动画, 播放动画 其他: 修改武器组件注册弹匣为空委托的处理函数名 # 由OnEmptyClip改为OnClipEmpty, 和委托成员一致 声明 ShootThemUp: Components/STUWeaponComponent.h void OnClipEmpty(ASTUBaseWeapon *AmmoEmptyWeapon); 定义 ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::OnClipEmpty(ASTUBaseWeapon *AmmoEmptyWeapon) { // ... } 注册处理函数 ShootThemUp: Components/STUWeaponComponent.cpp Weapon-\u0026gt;OnClipEmpty.AddUObject(this, \u0026amp;USTUWeaponComponent::OnClipEmpty); `}),e.add({id:130,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/swiper/",title:"swiper",description:"文本查找, 依赖ivy swiper-安装 # (use-package swiper :ensure t :config (progn (ivy-mode) (setq ivy-use-virtual-buffers t) (setq enable-recursive-minibuffers t) ;; enable this if you want `swiper' to use it ;; (setq search-default-mode #'char-fold-to-regexp) (global-set-key \u0026quot;\\C-s\u0026quot; 'swiper) )) swiper-快捷键 # - 文件内查找 C-s 下一个 C-n 上一个 C-p 跳转 RET ",content:"文本查找, 依赖ivy swiper-安装 # (use-package swiper :ensure t :config (progn (ivy-mode) (setq ivy-use-virtual-buffers t) (setq enable-recursive-minibuffers t) ;; enable this if you want `swiper' to use it ;; (setq search-default-mode #'char-fold-to-regexp) (global-set-key \u0026quot;\\C-s\u0026quot; 'swiper) )) swiper-快捷键 # - 文件内查找 C-s 下一个 C-n 上一个 C-p 跳转 RET "}),e.add({id:131,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E7%BB%84%E4%BB%B6/%E6%84%9F%E7%9F%A5%E7%BB%84%E4%BB%B6/",title:"感知组件",description:"Perception UPerceptionComponent # 用作AIController的组件 使用 # AIController构造函数 使用UObject::CreateDefaultSubobject\u0026lt;T\u0026gt;创建 使用AAIController::SetPerceptionComponent设置 ",content:"Perception UPerceptionComponent # 用作AIController的组件 使用 # AIController构造函数 使用UObject::CreateDefaultSubobject\u0026lt;T\u0026gt;创建 使用AAIController::SetPerceptionComponent设置 "}),e.add({id:132,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/npc%E8%87%AA%E8%A1%8C%E6%9B%B4%E6%8D%A2%E6%AD%A6%E5%99%A8/",title:"NPC自行更换武器",description:"说明 # AI Weapon Component 当前武器子弹耗尽时, 更换为仍有弹药的武器 查看当前NPC更换武器需求 # 调整武器顺序: 第一个为发射器 BP_STUAICharacter \u0026gt; WeaponComponent 拖动Index[1]到最上 修改发射器默认子弹数 BP_STULauncherWeapon \u0026gt; Details \u0026gt; Default Ammo 设置Clips = 2, Bullets = 1 修改步枪弹药库和伤害 BP_STURifleWeapon \u0026gt; Details Default Ammo 取消勾选 Infinite, 设置Clips = 3 设置DamageAmount = 0.0 查看: 射击完发射器榴弹后, 停止射击 NPC射击榴弹特效异常 # 在枪口处爆炸, 无移动 调试思路 # NPC和玩家游戏角色的区别, 刚好在上节子弹轨迹的修改; 上层控制器类型 GetPlayerViewPoint由 GetTraceData 调用: 能获取到ViewLocation和ViewRotation值 发射器MakeShot调用GetTraceData后, 调用 MakeHit 打印碰撞信息: 永远发生碰撞; 怀疑MuzzleSocket变换 输出碰撞点: 和枪口位置一致 将轨迹终点改为根据射程计算得到的终点: 轨迹和射击方向近乎垂直 原因 # MuzzleSocket变换配置存在失误; 已在 武器 \u0026gt; 榴弹类 更正 创建C++类 # - 基类 STUWeaponComponent 路径 Components Public 类名 STUAIWeaponComponent 调整武器基类接口的访问属性 # ShootThemUp: Weapon/STUBaseWeapon.",content:"说明 # AI Weapon Component 当前武器子弹耗尽时, 更换为仍有弹药的武器 查看当前NPC更换武器需求 # 调整武器顺序: 第一个为发射器 BP_STUAICharacter \u0026gt; WeaponComponent 拖动Index[1]到最上 修改发射器默认子弹数 BP_STULauncherWeapon \u0026gt; Details \u0026gt; Default Ammo 设置Clips = 2, Bullets = 1 修改步枪弹药库和伤害 BP_STURifleWeapon \u0026gt; Details Default Ammo 取消勾选 Infinite, 设置Clips = 3 设置DamageAmount = 0.0 查看: 射击完发射器榴弹后, 停止射击 NPC射击榴弹特效异常 # 在枪口处爆炸, 无移动 调试思路 # NPC和玩家游戏角色的区别, 刚好在上节子弹轨迹的修改; 上层控制器类型 GetPlayerViewPoint由 GetTraceData 调用: 能获取到ViewLocation和ViewRotation值 发射器MakeShot调用GetTraceData后, 调用 MakeHit 打印碰撞信息: 永远发生碰撞; 怀疑MuzzleSocket变换 输出碰撞点: 和枪口位置一致 将轨迹终点改为根据射程计算得到的终点: 轨迹和射击方向近乎垂直 原因 # MuzzleSocket变换配置存在失误; 已在 武器 \u0026gt; 榴弹类 更正 创建C++类 # - 基类 STUWeaponComponent 路径 Components Public 类名 STUAIWeaponComponent 调整武器基类接口的访问属性 # ShootThemUp: Weapon/STUBaseWeapon.h IsAmmoEmpty: protected \u0026gt; public 调整武器组件成员的访问属性 # ShootThemUp: Components/STUWeaponComponent.h 之前误把FireStart和FireStop声明成虚函数: 恢复FireStop void FireStop(); STUAIWeaponComponent需要重新实现下列接口逻辑 virtual void FireStart(); virtual void NextWeapon(); 派生类需要访问下列成员 private \u0026gt; protected Weapons数组 当前武器指针CurrentWeapon 当前武器在数组中的索引CurrentWeaponIndex 派生类需要使用下列成员函数 private \u0026gt; protected CanFire和CanEquip EquipWeapon 实现STUAIWeaponComponent # 覆写虚函数 # public ShootThemUp: Components/STUAIWeaponComponent.h virtual void FireStart() override; virtual void NextWeapon() override; 射击时, 若当前武器没有弹药, 尝试更换武器 # ShootThemUp: Components/STUAIWeaponComponent.cpp #include \u0026quot;Weapon/STUBaseWeapon.h\u0026quot; void USTUAIWeaponComponent::FireStart() { if (!CanFire()) return; if (CurrentWeapon-\u0026gt;IsAmmoEmpty()) { NextWeapon(); } else { CurrentWeapon-\u0026gt;FireStart(); } } 若存在武器弹药不为空, 切换到该武器 # ShootThemUp: Components/STUAIWeaponComponent.cpp void USTUAIWeaponComponent::NextWeapon() { if (!CanEquip()) return; int32 NextIndex = (CurrentWeaponIndex + 1) % Weapons.Num(); while (NextIndex != CurrentWeaponIndex) { if (!Weapons[NextIndex]-\u0026gt;IsAmmoEmpty()) break; NextIndex = (NextIndex + 1) % Weapons.Num(); } if (NextIndex != CurrentWeaponIndex) { CurrentWeaponIndex = NextIndex; EquipWeapon(CurrentWeaponIndex); } } AICharacter使用STUAIWeaponComponent # 参考STUBaseCharacter使用STUCharacterMovementComponent ShootThemUp: Player/STUBaseCharacter.cpp ShootThemUp: AI/STUAICharacter.cpp #include \u0026quot;Components/STUAIWeaponComponent.h\u0026quot; ASTUAICharacter::ASTUAICharacter(const FObjectInitializer \u0026amp;ObjInit) : Super(ObjInit.SetDefaultSubobjectClass\u0026lt;USTUAIWeaponComponent\u0026gt;(\u0026quot;WeaponComponent\u0026quot;)) { // ... } 查看 # 榴弹用完后自动更换武器, 步枪子弹用完后无法射击 "}),e.add({id:133,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E8%A7%82%E5%AF%9F%E8%80%85%E8%A7%86%E8%A7%92%E6%B7%BB%E5%8A%A0%E9%BB%91%E7%99%BD%E5%90%8E%E6%9C%9F/",title:"为观察者视角添加黑白后期",description:"说明 # 使用后期处理 Postprocessing , 应用于最终渲染帧的视觉特效 后期处理可以用来实现视觉特效, 也可以通过色彩矫正为帧营造氛围 属于美化范畴, 适合用蓝图实现 熟悉参数 # 运行游戏, 在世界大纲选择 BP_STUBaseCharacter , 在细节面板选择 Camera 组件, 查看后期处理 Post Process 设置: 很多设置都会对最终帧产生影响 设置虚光照 # 调暗图片边缘 添加噪音 # 饱和度 # 黑白后期: 设置Y = 0, 即亮度设置为0 创建观察者蓝图类 # Content/Player , 右键, 选择 Blueprint Class 基类选择 SpectatorPawn, 命名为BP_STUSpectatorPawn 设置关卡设置该观察者类 打开观察者类, 为其添加摄像机组件, 命名为CameraComponent 设置摄像机组件 # 摄像机受鼠标控制, 支持在垂直方向旋转 勾选 Details \u0026gt; Camera Options \u0026gt; UsePawnControlRotation 黑白后期 Global \u0026gt; Saturation , 设置Y = 0 查看 # ",content:"说明 # 使用后期处理 Postprocessing , 应用于最终渲染帧的视觉特效 后期处理可以用来实现视觉特效, 也可以通过色彩矫正为帧营造氛围 属于美化范畴, 适合用蓝图实现 熟悉参数 # 运行游戏, 在世界大纲选择 BP_STUBaseCharacter , 在细节面板选择 Camera 组件, 查看后期处理 Post Process 设置: 很多设置都会对最终帧产生影响 设置虚光照 # 调暗图片边缘 添加噪音 # 饱和度 # 黑白后期: 设置Y = 0, 即亮度设置为0 创建观察者蓝图类 # Content/Player , 右键, 选择 Blueprint Class 基类选择 SpectatorPawn, 命名为BP_STUSpectatorPawn 设置关卡设置该观察者类 打开观察者类, 为其添加摄像机组件, 命名为CameraComponent 设置摄像机组件 # 摄像机受鼠标控制, 支持在垂直方向旋转 勾选 Details \u0026gt; Camera Options \u0026gt; UsePawnControlRotation 黑白后期 Global \u0026gt; Saturation , 设置Y = 0 查看 # "}),e.add({id:134,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/avy/",title:"avy",description:"字符查找, 快速跳转 便签 # GitHub avy-安装 # ;; (use-package avy ;; :ensure t ;; :bind ((\u0026quot;C-:\u0026quot; . avy-goto-char) ;; (\u0026quot;C-;\u0026quot; . avy-goto-char-2) ;; )) ",content:"字符查找, 快速跳转 便签 # GitHub avy-安装 # ;; (use-package avy ;; :ensure t ;; :bind ((\u0026quot;C-:\u0026quot; . avy-goto-char) ;; (\u0026quot;C-;\u0026quot; . avy-goto-char-2) ;; )) "}),e.add({id:135,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E9%9A%8F%E6%9C%BA%E6%9B%B4%E6%8D%A2%E6%AD%A6%E5%99%A8%E6%9C%8D%E5%8A%A1/",title:"随机更换武器服务",description:"说明 # Homework - Change Weapon Service 和弹药耗尽更换武器性质不同; 使用当时实现的NextWeapon接口 NPC攻击时执行: 加入到Attack序列 设置参数, 生成随机数大于该值时不作操作 补充 # 应该在TickNode最后调用基类TickNode ShootThemUp: AI/Services/STUFireService.cpp // TickNode Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds); 创建服务类 # - 基类 BTService 路径 AI/Services 属性 Public 类名 STUChangeWeaponService 基本函数声明 # ShootThemUp: AI/Services/STUChangeWeaponService.h // public USTUChangeWeaponService(); // protected void TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds); 构造函数实现: 设置服务名称 # ShootThemUp: AI/Services/STUChangeWeaponService.cpp USTUChangeWeaponService::USTUChangeWeaponService() { NodeName = \u0026quot;Change Weapon\u0026quot;; } TickNode框架 # ShootThemUp: AI/Services/STUChangeWeaponService.cpp void USTUChangeWeaponService::TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) { // .",content:"说明 # Homework - Change Weapon Service 和弹药耗尽更换武器性质不同; 使用当时实现的NextWeapon接口 NPC攻击时执行: 加入到Attack序列 设置参数, 生成随机数大于该值时不作操作 补充 # 应该在TickNode最后调用基类TickNode ShootThemUp: AI/Services/STUFireService.cpp // TickNode Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds); 创建服务类 # - 基类 BTService 路径 AI/Services 属性 Public 类名 STUChangeWeaponService 基本函数声明 # ShootThemUp: AI/Services/STUChangeWeaponService.h // public USTUChangeWeaponService(); // protected void TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds); 构造函数实现: 设置服务名称 # ShootThemUp: AI/Services/STUChangeWeaponService.cpp USTUChangeWeaponService::USTUChangeWeaponService() { NodeName = \u0026quot;Change Weapon\u0026quot;; } TickNode框架 # ShootThemUp: AI/Services/STUChangeWeaponService.cpp void USTUChangeWeaponService::TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) { // ... Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds); } 添加属性: 更换武器概率 # 为0时, 不触发该服务 protected ShootThemUp: AI/Services/STUChangeWeaponService.h UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1.0\u0026quot;)) float Probability = 0.5f; 实现服务逻辑 # ShootThemUp: AI/Services/STUChangeWeaponService.cpp #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;Components/STUWeaponComponent.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; // TickNode const auto Controller = OwnerComp.GetAIOwner(); if (Controller) { const auto WeaponComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUWeaponComponent\u0026gt;(Controller-\u0026gt;GetPawn()); if (WeaponComponent \u0026amp;\u0026amp; Probability \u0026gt; 0 \u0026amp;\u0026amp; FMath::FRand() \u0026lt;= Probability) { WeaponComponent-\u0026gt;NextWeapon(); } } FMath::FRand # 返回[0, 1] 测试 # 为Selector添加STUChangeWeaponService 设置Probability = 0.8, Interval = 1 一切正常 查看 # 将Selector \u0026gt; STUChangeWeaponService拖动到Attack序列, 设置Interval = 3 勾选发射器和步枪的子弹数 Infinite 选项 BP_STURifleWeapon BP_STULauncherWeapon Details \u0026gt; Default Ammo \u0026gt; Infinite NPC捕获敌人时, 正常随机更换武器进行射击; 触发概率不高 可以改善的地方: 事件发生时不一定切换成功, 如动画播放中途, 如正在射击 "}),e.add({id:136,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E6%9E%AA%E5%8F%A3%E7%89%B9%E6%95%88/",title:"枪口特效",description:"说明 # 创建一个发射器NE_LauncherFlash, 两个粒子系统NS_LauncherMuzzle和NS_RiffleMuzzle 发射器的枪口特效较简单. 步枪的射击涉及定时器, 只创建一次粒子系统, 开始射击时, 令其开始并将其渲染, 停止射击时令其暂停, 不再对其进行渲染 创建Niagara粒子发射器 # 创建文件夹 Content/VFX/Muzzles 创建Niagara粒子发射器 使用模板 选择 Simple Sprite Burst , 命名为NE_LauncherFlash 设置纹理 使用默认发射器状态: 不循环; 设置时长 设置粒子数 设置外观 生存时间, 颜色, 聚集方式, 分布, 旋转模式 添加属性: Scale Sprite Size 起点 终点 添加属性: Sprite Rotation Rate 设置Rotation Rate为 Particles \u0026gt; Initial \u0026gt; MaterialRandom 基于NE_LauncherFlash创建发射器使用的Niagara粒子系统资产 # 右键NE_LauncherFlash, 命名为NS_LauncherMuzzle 设置不变, 只播放一次 基于NE_LauncherFlash创建步枪使用的Niagara粒子系统资产 # 命名为NS_RifleMuzzle 循环播放, 设置时长 添加属性: Spawn Rate 设置为90 设置颜色 优化榴弹冲击特效 # NS_ProjectileImpact 设置粒子数 设置分布 枪口特效 # 武器基类: 在枪口生成特效, 返回Niagara组件 # 添加属性: 保存特效类型 # ShootThemUp: Weapon/STUBaseWeapon.",content:`说明 # 创建一个发射器NE_LauncherFlash, 两个粒子系统NS_LauncherMuzzle和NS_RiffleMuzzle 发射器的枪口特效较简单. 步枪的射击涉及定时器, 只创建一次粒子系统, 开始射击时, 令其开始并将其渲染, 停止射击时令其暂停, 不再对其进行渲染 创建Niagara粒子发射器 # 创建文件夹 Content/VFX/Muzzles 创建Niagara粒子发射器 使用模板 选择 Simple Sprite Burst , 命名为NE_LauncherFlash 设置纹理 使用默认发射器状态: 不循环; 设置时长 设置粒子数 设置外观 生存时间, 颜色, 聚集方式, 分布, 旋转模式 添加属性: Scale Sprite Size 起点 终点 添加属性: Sprite Rotation Rate 设置Rotation Rate为 Particles \u0026gt; Initial \u0026gt; MaterialRandom 基于NE_LauncherFlash创建发射器使用的Niagara粒子系统资产 # 右键NE_LauncherFlash, 命名为NS_LauncherMuzzle 设置不变, 只播放一次 基于NE_LauncherFlash创建步枪使用的Niagara粒子系统资产 # 命名为NS_RifleMuzzle 循环播放, 设置时长 添加属性: Spawn Rate 设置为90 设置颜色 优化榴弹冲击特效 # NS_ProjectileImpact 设置粒子数 设置分布 枪口特效 # 武器基类: 在枪口生成特效, 返回Niagara组件 # 添加属性: 保存特效类型 # ShootThemUp: Weapon/STUBaseWeapon.h protected class UNiagaraSystem; UPROPERTY(EDitDefaultsOnly, BlueprintReadWrite) UNiagaraSystem *MuzzleFX; 添加接口: 在枪口生成特效, 播放完自动销毁, 返回Niagara组件 # ShootThemUp: Weapon/STUBaseWeapon.h protected class UNiagaraComponent; UNiagaraComponent *SpawnMuzzleFX(); ShootThemUp: Weapon/STUBaseWeapon.cpp #include \u0026quot;NiagaraFunctionLibrary.h\u0026quot; #include \u0026quot;NiagaraComponent.h\u0026quot; UNiagaraComponent *ASTUBaseWeapon::SpawnMuzzleFX() { return UNiagaraFunctionLibrary::SpawnSystemAttached(MuzzleFX, // WeaponMeshComponent, // MuzzleSocketName, // FVector::ZeroVector, // FRotator::ZeroRotator, // EAttachLocation::SnapToTarget,// true); } UNiagaraFunctionLibrary::SpawnSystemAttached
Niagaram粒子系统的变换与上级组件变换保持一致 static UNiagaraComponent* SpawnSystemAttached(UNiagaraSystem* SystemTemplate, USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, EAttachLocation::Type LocationType, bool bAutoDestroy, bool bAutoActivate = true, ENCPoolMethod PoolingMethod = ENCPoolMethod::None, bool bPreCullCheck = true); - SystemTemplate 粒子特效类型 AttachToComponent 上级组件 AttachPointName 挂载点 Location 位置 Rotation 方向向量 LocationType 挂载方式 bAutoDestroy 特效若没有循环, 结束后销毁 榴弹发射器 # 射击后生成枪口特效 ShootThemUp: Weapon/STULauncherWeapon.cpp // MakeShot SpawnMuzzleFX(); 步枪 # 添加属性: 保存Niagara组件 # ShootThemUp: Weapon/STURifleWeapon.h private class UNiagaraComponent; UPROPERTY() UNiagaraComponent *MuzzleFXComponent; 添加接口: 根据标志位设置特效 # ShootThemUp: Weapon/STURifleWeapon.h private void SetMuzzleFXVisibility(bool Visible); ShootThemUp: Weapon/STURifleWeapon.cpp #include \u0026quot;NiagaraComponent.h\u0026quot; void ASTURifleWeapon::SetMuzzleFXVisibility(bool Visible) { if (MuzzleFXComponent) { MuzzleFXComponent-\u0026gt;SetPaused(!Visible); MuzzleFXComponent-\u0026gt;SetVisibility(Visible, true); } } SetPaused
设置粒子系统暂停或继续, 即, 与Tick函数有关 SetVisibility
设置是否渲染粒子系统 第二个参数影响子节点的渲染, 此处设为true或false无影响 添加接口: 在枪口生成特效, 设置特效可见 # ShootThemUp: Weapon/STURifleWeapon.h private void InitMuzzleFX(); ShootThemUp: Weapon/STURifleWeapon.cpp void ASTURifleWeapon::InitMuzzleFX() { if (!MuzzleFXComponent) { MuzzleFXComponent = SpawnMuzzleFX(); } SetMuzzleFXVisibility(true); } 射击时生成特效或设置特效可见 # // FireStart InitMuzzleFX(); 停止射击时设置特效不可见 # // FireStop SetMuzzleFXVisibility(false); 查看 # 设置步枪枪口动画 设置发射器枪口动画 步枪射击时移动, 有神龙甩尾的效果\u0026hellip; `}),e.add({id:137,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/org-roam/",title:"org-roam",description:"构建个人知识网络 便签 # GitHub Manual org-roam-安装 # (use-package org-roam :ensure t :custom (org-roam-directory my/org-roam-directory) ;; custom (org-roam-completion-everywhere t) :bind ((\u0026quot;C-c n f\u0026quot; . org-roam-node-find) (\u0026quot;C-c n i\u0026quot; . org-roam-node-insert) (\u0026quot;C-c n l\u0026quot; . org-roam-buffer-toggle) (\u0026quot;C-c n s\u0026quot; . org-roam-db-sync) (\u0026quot;C-c n r\u0026quot; . org-roam-db-clear-all) ;; (\u0026quot;C-c n c\u0026quot; . org-roam-capture) ;; Dailies ;; (\u0026quot;C-c n j\u0026quot; . org-roam-dailies-capture-today) ;; (\u0026quot;C-c n g\u0026quot; . org-roam-graph) ;; 需安装Graphviz ;; custom ;; 使能 org-roam-completion-everywhere ;; (\u0026quot;C-M-i\u0026quot; .",content:"构建个人知识网络 便签 # GitHub Manual org-roam-安装 # (use-package org-roam :ensure t :custom (org-roam-directory my/org-roam-directory) ;; custom (org-roam-completion-everywhere t) :bind ((\u0026quot;C-c n f\u0026quot; . org-roam-node-find) (\u0026quot;C-c n i\u0026quot; . org-roam-node-insert) (\u0026quot;C-c n l\u0026quot; . org-roam-buffer-toggle) (\u0026quot;C-c n s\u0026quot; . org-roam-db-sync) (\u0026quot;C-c n r\u0026quot; . org-roam-db-clear-all) ;; (\u0026quot;C-c n c\u0026quot; . org-roam-capture) ;; Dailies ;; (\u0026quot;C-c n j\u0026quot; . org-roam-dailies-capture-today) ;; (\u0026quot;C-c n g\u0026quot; . org-roam-graph) ;; 需安装Graphviz ;; custom ;; 使能 org-roam-completion-everywhere ;; (\u0026quot;C-M-i\u0026quot; . completion-at-point) ) :config ;; If you're using a vertical completion framework, you might want a more informative completion interface (setq org-roam-node-display-template (concat \u0026quot;${title:*} \u0026quot; (propertize \u0026quot;${tags:10}\u0026quot; 'face 'org-tag))) (org-roam-db-autosync-mode) (org-roam-db-sync) ;; If using org-roam-protocol (require 'org-roam-protocol) (setq org-roam-capture-templates '( (\u0026quot;d\u0026quot; \u0026quot;default\u0026quot; plain \u0026quot;%?\u0026quot; :target (file+head \u0026quot;%^{目录}/${title}.org\u0026quot; \u0026quot;#+title: ${title}\\n\u0026quot;) :unarrowed t) ))) org-roam-快捷键 # - C-c n f 查找节点 （查找不到新增) C-c n i 在当前位置插入节点 （查找不到新增） C-c n l 查看所在节点引用 C-c n s 数据库同步 C-c n r 清除数据库 C-c C-l 查看节点链接 C-c C-o 打开节点 协作插件 # org-roam-ui\n"}),e.add({id:138,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E6%B8%85%E9%99%A4%E8%A1%8C%E4%B8%BA%E6%A0%91/",title:"清除行为树",description:"说明 # Behavior Tree Cleanup NPC死亡后清除行为树 验证NPC死亡后, 行为树仍在运行 # 添加调试信息 # 每次运行寻找敌人服务时, 输出日志 ShootThemUp: AI/Services/STUFindEnemyService.cpp // TickNode UE_LOG(LogTemp, Display, TEXT(\u0026quot;find enemy\u0026quot;)); 游戏角色死亡后输入日志 ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage UE_LOG(LogTemp, Display, TEXT(\u0026quot;character dead\u0026quot;)); 设置NPC生命值 # BP_STUAICharacter \u0026gt; Health Component \u0026gt; Details \u0026gt; Max Health 设置为5 查看 # NPC死亡后, 行为树仍在运行: 直到Character的Destroy函数被调用 AIController::RunBehaviorTree # UBehaviorTreeComponent派生自BrainComponent 调用UBrainComponent::StartTree实现 UBrainComponent::Cleanup # 停止行为树运行 在AICharacter中覆写OnDeath # 修改基类声明 # 使之为虚函数 移动到protected 派生类可以覆写基类私有函数, 但无法调用基类实现 ShootThemUp: Player/STUBaseCharacter.h virtual void OnDeath(); 在派生类覆写 # protected ShootThemUp: AI/STUAICharacter.",content:"说明 # Behavior Tree Cleanup NPC死亡后清除行为树 验证NPC死亡后, 行为树仍在运行 # 添加调试信息 # 每次运行寻找敌人服务时, 输出日志 ShootThemUp: AI/Services/STUFindEnemyService.cpp // TickNode UE_LOG(LogTemp, Display, TEXT(\u0026quot;find enemy\u0026quot;)); 游戏角色死亡后输入日志 ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage UE_LOG(LogTemp, Display, TEXT(\u0026quot;character dead\u0026quot;)); 设置NPC生命值 # BP_STUAICharacter \u0026gt; Health Component \u0026gt; Details \u0026gt; Max Health 设置为5 查看 # NPC死亡后, 行为树仍在运行: 直到Character的Destroy函数被调用 AIController::RunBehaviorTree # UBehaviorTreeComponent派生自BrainComponent 调用UBrainComponent::StartTree实现 UBrainComponent::Cleanup # 停止行为树运行 在AICharacter中覆写OnDeath # 修改基类声明 # 使之为虚函数 移动到protected 派生类可以覆写基类私有函数, 但无法调用基类实现 ShootThemUp: Player/STUBaseCharacter.h virtual void OnDeath(); 在派生类覆写 # protected ShootThemUp: AI/STUAICharacter.h virtual void OnDeath() override; ShootThemUp: AI/STUAICharacter.cpp #include \u0026quot;BrainComponent.h\u0026quot; void ASTUAICharacter::OnDeath() { Super::OnDeath(); const auto STUController = Cast\u0026lt;AAIController\u0026gt;(Controller); if (STUController \u0026amp;\u0026amp; STUController-\u0026gt;BrainComponent) { STUController-\u0026gt;BrainComponent-\u0026gt;Cleanup(); } } 查看 # 设置步枪伤害 BP_STURifleWeapon \u0026gt; Details \u0026gt; Damage Amount , 设置为10 移除日志打印 # ShootThemUp: AI/Services/STUFindEnemyService.cpp ShootThemUp: Components/STUHealthComponent.cpp ShootThemUp: Weapon/STUBaseWeapon.cpp // GetTraceData ShootThemUp: Weapon/STULauncherWeapon.cpp // MakeShot "}),e.add({id:139,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E5%AD%90%E5%BC%B9%E8%BD%A8%E8%BF%B9%E7%89%B9%E6%95%88/",title:"子弹轨迹特效",description:"说明 # 子弹在空间中的轨迹 图示只做说明 修正枪口特效 # NE_LauncherFlash 火花样式 弹射旋转 Sprite Rotation 调整 Scale Sprite Size 和 Sprite Rotation Rate 顺序, 设置旋转比例范围 解决神龙甩尾效果 减小火花 修正榴弹冲击特效 # NS_ProjectileImpact SimpleSpriteBurst # 腾云特效 设置时长 粒子数 生存时间和大小 分布属性 添加 设置半径和原型 排序 UpwardMeshBurst # 箭簇特效 粒子数 生存期, 颜色, 体积等 取消模块勾选 大小分布 移除不需要的网格体等 OmnidirectionalBurst # 击碎雪球特效 添加属性 调整属性位置, 设置圆形分布半径等 排序 实现轨迹特效 # 创建文件夹 Content/VFX/Trace , 创建下属文件夹 Projectile 和 Rifle 创建步枪子弹轨迹用粒子发射器 # Content/VFX/Trace/Rifle 基于模板Dynamic Beam, 命名为NE_RifleBeam Initialize Particle Beam Width Color 创建步枪子弹轨迹用粒子系统 # Content/VFX/Trace/Rifle 使用粒子发射器NE_RifleBeam 命名为NS_RifleBeam 创建榴弹轨迹用粒子发射器 # Content/VFX/Trace/Projectile NE_BlueCore # 基于模板SimpleSpriteBurst Properties Emitter State Spawn Burst Instantaneous Initialize Particle Scale Color 添加模块 Scale Sprite Size 添加模块 Sprite Rotation Rate Sprite Renderer NE_Electric # 基于模板SimpleSpriteBurst Properties Emitter State 添加模块: Spawn Rate Initialize Particle 添加模块: Shape Location Scale Color 添加模块: Scale Sprite Size 添加模块: Sprite Rotation Rate 添加模块: Sub UVAnimation Sprite Renderer NE_Fountain # 基于模板Fountain Spawn Rate Initialize Particle Shape Location Add Velocity Gravity Force 添加模块: Collision 添加模块: Acceleration Force Sprite Renderer 添加模块Scale Velocity",content:`说明 # 子弹在空间中的轨迹 图示只做说明 修正枪口特效 # NE_LauncherFlash 火花样式 弹射旋转 Sprite Rotation 调整 Scale Sprite Size 和 Sprite Rotation Rate 顺序, 设置旋转比例范围 解决神龙甩尾效果 减小火花 修正榴弹冲击特效 # NS_ProjectileImpact SimpleSpriteBurst # 腾云特效 设置时长 粒子数 生存时间和大小 分布属性 添加 设置半径和原型 排序 UpwardMeshBurst # 箭簇特效 粒子数 生存期, 颜色, 体积等 取消模块勾选 大小分布 移除不需要的网格体等 OmnidirectionalBurst # 击碎雪球特效 添加属性 调整属性位置, 设置圆形分布半径等 排序 实现轨迹特效 # 创建文件夹 Content/VFX/Trace , 创建下属文件夹 Projectile 和 Rifle 创建步枪子弹轨迹用粒子发射器 # Content/VFX/Trace/Rifle 基于模板Dynamic Beam, 命名为NE_RifleBeam Initialize Particle Beam Width Color 创建步枪子弹轨迹用粒子系统 # Content/VFX/Trace/Rifle 使用粒子发射器NE_RifleBeam 命名为NS_RifleBeam 创建榴弹轨迹用粒子发射器 # Content/VFX/Trace/Projectile NE_BlueCore # 基于模板SimpleSpriteBurst Properties Emitter State Spawn Burst Instantaneous Initialize Particle Scale Color 添加模块 Scale Sprite Size 添加模块 Sprite Rotation Rate Sprite Renderer NE_Electric # 基于模板SimpleSpriteBurst Properties Emitter State 添加模块: Spawn Rate Initialize Particle 添加模块: Shape Location Scale Color 添加模块: Scale Sprite Size 添加模块: Sprite Rotation Rate 添加模块: Sub UVAnimation Sprite Renderer NE_Fountain # 基于模板Fountain Spawn Rate Initialize Particle Shape Location Add Velocity Gravity Force 添加模块: Collision 添加模块: Acceleration Force Sprite Renderer 添加模块Scale Velocity
定位 Add Velocity 模块位置 Scale Velocity在库中隐藏 拖动 Scale Velocity 到NE_Fountain中, 添加该模块 设置 NE_Smoke # 基于模板Fountain Spawn Rate Initialize Particle Scale Color X、Y和Z终点 Z起点 Y起点 X起点 取消未使用模块勾选 添加模块: Scale Sprite Size 起点 终点 添加模块: Sub UVAnimation Sprite Renderer 创建榴弹轨迹用粒子系统 # Content/VFX/Trace/Projectile 使用现有发射器 依次选择NE_CoreBlue, NE_Electric, NE_Smoke, NE_Fountain 命名为NS_ProjectileTrace 为轨迹终点绑定变量 # Content/VFX/Trace/Rifle/NS_RifleBeam 调试终点 # Beam Emitter Setup 设置Beam End \u0026gt; X = 1200, 光束更长; 绘制轨迹时, 对该参数进行设置 不使用相对座标, 而是世界座标 # 勾选 Absolute Beam End 绑定变量 # NS_RifleBeam 添加变量, 设置变量类型为Vector Parameters \u0026gt; User Exposed 命名为TraceTarget 为Beam End绑定变量TraceTarget NE_RifleBeam \u0026gt; Beam Emitter Setup \u0026gt; Beam End 设置特效只播放一次 # NS_RifleBeam \u0026gt; NE_RifleBeam \u0026gt; Emitter State \u0026gt; Loop Behavior 在C++中为步枪子弹生成轨迹特效 # 生成轨迹特效, 设置TraceTarget变量 添加变量: 保存轨迹特效类型 # ShootThemUp: Weapon/STURifleWeapon.h protected class UNiagaraSystem; UPROPERTY(EditDefaultsOnly, BlueprintRead Write) UNiagaraSystem *TraceFX; 添加变量: 存放轨迹终点变量名 # ShootThemUp: Weapon/STURifleWeapon.h protected UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) FString TraceTargetName = \u0026quot;TraceTarget\u0026quot;; 添加函数: 绘制轨迹特效 # ShootThemUp: Weapon/STURifleWeapon.h private void SpawnTraceFX(const FVector \u0026amp;TraceStart, const FVector \u0026amp;TraceEnd); 射击时调用 # 之前有绘制轨迹示意图, 屏蔽未射中分支 若击中, 更新终点 生成轨迹特效 ShootThemUp: Weapon/STURifleWeapon.cpp // MakeShot FVector TraceFXEnd = TraceEnd; if (HitResult.bBlockingHit) { TraceFXEnd = HitResult.ImpactPoint; // ... } SpawnTraceFX(GetMuzzleWorldLocation(), TraceFXEnd); 实现 # #include \u0026quot;NiagaraFunctionLibrary.h\u0026quot; void ASTURifleWeapon::SpawnTraceFX(const FVector \u0026amp;TraceStart, const FVector \u0026amp;TraceEnd) { const auto TraceFXComponent = UNiagaraFunctionLibrary::SpawnSystemAtLocation(GetWorld(), TraceFX, TraceStart); if (TraceFXComponent) { TraceFXComponent-\u0026gt;SetNiagaraVariableVec3(TraceTargetName, TraceEnd); } } 查看步枪子弹轨迹 # BP_STURifleWeapon 设置特效类 为榴弹添加轨迹特效 # BP_STUProjectile 为其添加Niagara Particle System组件 # 命名为TraceFXComponent, 为其设置粒子系统 关闭特效渲染 # BP_STUProjectile TraceFXComponent \u0026gt; Details \u0026gt; Rendering \u0026gt; Visible , 取消勾选 使用发光材质 # 创建材质实例 # 拷贝MI_BlueGlow Ctrl-D, 命名为MI_ProjectileGlow 设置颜色Hex Linear = 006AE100 设置发光参数为500 使用材质实例 # BP_STUProjectile 为静态网格体应用材质MI_ProjectileGlow 添加点光源组件 # Point Light 设置颜色Hex Linear = 006AE100 Details \u0026gt; Light \u0026gt; Light Color 恢复特效渲染 # 遗留问题 # 榴弹爆炸时, 烟雾和其他特效一起消散. 一个更好的做法, 其他特效消散, 保留烟雾效果. 比如, 设置榴弹延后销毁 `}),e.add({id:140,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/org-roam-ui/",title:"org-roam-ui",description:"在网页展示org-roam节点 便签 # GitHub org-roam-ui-安装 # (use-package org-roam-ui :ensure t :after org-roam ;; normally we'd recommend hooking orui after org-roam, but since org-roam does not have ;; a hookable mode anymore, you're advised to pick something yourself ;; if you don't care about startup time, use ;; :hook (after-init . org-roam-ui-mode) :config (setq org-roam-ui-sync-theme t org-roam-ui-follow t org-roam-ui-update-on-save t org-roam-ui-open-on-start t) :bind ((\u0026quot;C-c n u\u0026quot; . org-roam-ui-open))) org-roam-ui-快捷键 # - C-c n u 打开视图 ",content:"在网页展示org-roam节点 便签 # GitHub org-roam-ui-安装 # (use-package org-roam-ui :ensure t :after org-roam ;; normally we'd recommend hooking orui after org-roam, but since org-roam does not have ;; a hookable mode anymore, you're advised to pick something yourself ;; if you don't care about startup time, use ;; :hook (after-init . org-roam-ui-mode) :config (setq org-roam-ui-sync-theme t org-roam-ui-follow t org-roam-ui-update-on-save t org-roam-ui-open-on-start t) :bind ((\u0026quot;C-c n u\u0026quot; . org-roam-ui-open))) org-roam-ui-快捷键 # - C-c n u 打开视图 "}),e.add({id:141,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E4%BD%BF%E7%94%A8eqs%E5%AE%9E%E7%8E%B0%E5%B7%A1%E9%80%BB/",title:"使用EQS实现巡逻",description:"说明 # AI / EQS / Random Roam AI系统 Environment Query System EQS帮助NPC在给定的条件下对空间进行分析 本节将给出满足条件的适合NPC的位置区域 目的在于使NPC巡逻更自然 创建类 # 创建文件夹 AI/EQS 创建EQS资产 AI/EQS 目录下空白处右键 \u0026gt; Artificial Intelligence \u0026gt; Environment Query, 命名为EQS_RandomRoam 使用EQS_RandomRoam取代巡逻时生成随机点逻辑 创建蓝图类 AI/EQS 目录下空白处右键 \u0026gt; Blueprint Class - 基类 EQSTestingPawn 名称 EQS_TestPawn 专门用于在虚幻编辑器对EQS进行测试. 游戏成品中不会使用到 添加到关卡中 在细节面板中设置EQS_TestPawn 在世界大纲选中 EQS_TestPawn Details \u0026gt; EQS \u0026gt; Query Template , 设置为EQS_RandomRoam 介绍EQS资产 # 随机目的地 设置EQS资产 # 添加生成器: 扇形点阵 配置 Cone Degrees 200 Angle Step 10 Range \u0026gt; Data Binding Random number Range \u0026gt; Data Binding \u0026gt; Min 1200 Range \u0026gt; Data Binding \u0026gt; Max 1600 Track Mode Navigation 为扇形点阵添加距离条件: Distance 设置Distance: 限定筛选类型为最小值, 最小值为400 小于给定最小值的点, 显示为蓝色, 权重为0 在行为树运行EQS # 断开ROOT节点到选择器的箭头 添加序列 为序列添加任务 Run EQSQuery Details \u0026gt; EQS \u0026gt; EQSRequest \u0026gt; Query Template, 选择EQS_RandomRoam Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 选择AimLocation: 对黑板变量AimLocation进行设置 为序列添加任务 MoveTo Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 选择AimLocation: 从黑板变量AimLocation获取目的位置 为序列添加任务 Wait 等待2s 查看 # 设置NPC生命值100 BP_STUAICharacter \u0026gt; Details \u0026gt; MaxHealth 在世界大纲选中AICharacter 按下 ' 打开AI调试界面, 按下小写键盘 3 显示EQS信息 选中位置点显示为浅绿色 ",content:"说明 # AI / EQS / Random Roam AI系统 Environment Query System EQS帮助NPC在给定的条件下对空间进行分析 本节将给出满足条件的适合NPC的位置区域 目的在于使NPC巡逻更自然 创建类 # 创建文件夹 AI/EQS 创建EQS资产 AI/EQS 目录下空白处右键 \u0026gt; Artificial Intelligence \u0026gt; Environment Query, 命名为EQS_RandomRoam 使用EQS_RandomRoam取代巡逻时生成随机点逻辑 创建蓝图类 AI/EQS 目录下空白处右键 \u0026gt; Blueprint Class - 基类 EQSTestingPawn 名称 EQS_TestPawn 专门用于在虚幻编辑器对EQS进行测试. 游戏成品中不会使用到 添加到关卡中 在细节面板中设置EQS_TestPawn 在世界大纲选中 EQS_TestPawn Details \u0026gt; EQS \u0026gt; Query Template , 设置为EQS_RandomRoam 介绍EQS资产 # 随机目的地 设置EQS资产 # 添加生成器: 扇形点阵 配置 Cone Degrees 200 Angle Step 10 Range \u0026gt; Data Binding Random number Range \u0026gt; Data Binding \u0026gt; Min 1200 Range \u0026gt; Data Binding \u0026gt; Max 1600 Track Mode Navigation 为扇形点阵添加距离条件: Distance 设置Distance: 限定筛选类型为最小值, 最小值为400 小于给定最小值的点, 显示为蓝色, 权重为0 在行为树运行EQS # 断开ROOT节点到选择器的箭头 添加序列 为序列添加任务 Run EQSQuery Details \u0026gt; EQS \u0026gt; EQSRequest \u0026gt; Query Template, 选择EQS_RandomRoam Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 选择AimLocation: 对黑板变量AimLocation进行设置 为序列添加任务 MoveTo Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 选择AimLocation: 从黑板变量AimLocation获取目的位置 为序列添加任务 Wait 等待2s 查看 # 设置NPC生命值100 BP_STUAICharacter \u0026gt; Details \u0026gt; MaxHealth 在世界大纲选中AICharacter 按下 ' 打开AI调试界面, 按下小写键盘 3 显示EQS信息 选中位置点显示为浅绿色 "}),e.add({id:142,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/%E9%87%8D%E6%9E%84%E5%92%8C%E6%89%93%E5%8C%85/",title:"重构和打包",description:"移除重叠事件打印 # BP_STUBaseCharacter 移除装备武器打印 # ABP_BaseCharacter 移除瞄准偏移辅助线 # ABP_BaseCharacter 修正榴弹弹痕体积 # BP_STUProjectile 屏蔽榴弹爆炸范围绘制 # ShootThemUp: Weapon/STUProjectile.cpp 创建榴弹爆炸特效 # 创建文件夹 Content/VFX/Projectile 创建粒子发射器NE_Burst # 使用模板Omnidirectional Burst Spawn Burst Instantaneous Initialize Particle 添加模块 Calculate Size and Rotational Inertia by Mass Shape Location Scale Color 添加模块 Collision 创建粒子发射器NE_Fireball # 使用模板Simple Sprite Burst Emitter State Spawn Burst Instantaneous Initialize Particle 添加模块 Shape Location 添加模块 Drag 调整位置 Solve Forces and Velocity 添加模块 Sub UVAnimation 消散效果不协调 Scale Color Render 添加模块 Add Velocity 无法在 Particle Update 添加 创建粒子发射器NE_Flash # 使用模板Simple Sprite Burst Emitter State Initialize Particle 取消未使用模块勾选 添加模块 Scale Sprite Size Render 创建粒子发射器NE_Smoke # 使用模板Simple Sprite Burst Emitter State Spawn Burst Instantaneous Initialize Particle 添加模块 Shape Location 添加模块 Drag 调整位置 Solve Forces and Velocity Scale Color 添加模块 Sub UVAnimation Render 添加模块 Add Velocity 无法在 Particle Update 添加 创建粒子系统NS_ProjectileExplosion # 使用现有粒子发射器, 有序添加NE_Burst, NE_Fireball, NE_Flash, NE_Smoke 配置榴弹使用 # 效果很不理想, 有待调整 创建撞击特效 # 创建文件夹 Content/VFX/Impacts 创建粒子发射器NE_BurstOut # 使用模板Directional Burst 创建粒子发射器NE_CoreFast # 使用模板Simple Sprite Burst 创建粒子发射器NE_ShortBurst1 # 使用模板Simple Sprite Burst 创建粒子发射器NE_ShortBurst2 # 使用模板Simple Sprite Burst 创建粒子系统NS_RifleDefaultImpact # 子弹射击金属的效果 创建空的粒子系统 依次添加NE_ShortBurst1和NE_ShortBurst2: 烟雾效果 添加两个NE_CoreFast, 分别命名为NE_CoreFastOrange, NE_CoreFastBlue; 修改NE_CoreFastBlue颜色 添加NE_LauncherFlash和NE_BurstOut 创建粒子系统NS_RifleGroundImpact # 拷贝NS_RifleDefaultImpact改名 创建粒子系统NS_RifleBodyImpact # 拷贝NS_RifleDefaultImpact改名, NE_BurstOut粒子数增加为40 创建粒子系统NS_RifleHeadImpact # 拷贝NS_RifleDefaultImpact改名 增加NE_BurstOut粒子数 修改NE_BurstOut粒子颜色 设置步枪击中特效的默认类型和映射 # 移动旧资产 # 创建文件夹 Content/VFX/Dev 将PS_Test, NE_BaseImpact移动到Dev目录下 将NS_DefaultImpact, NS_GroundImpact, NS_BodyImpact和NS_HeadImpact移动到Dev目录下 将NS_ProjectileImpact移动到Projectile目录下 打包游戏 # ",content:"移除重叠事件打印 # BP_STUBaseCharacter 移除装备武器打印 # ABP_BaseCharacter 移除瞄准偏移辅助线 # ABP_BaseCharacter 修正榴弹弹痕体积 # BP_STUProjectile 屏蔽榴弹爆炸范围绘制 # ShootThemUp: Weapon/STUProjectile.cpp 创建榴弹爆炸特效 # 创建文件夹 Content/VFX/Projectile 创建粒子发射器NE_Burst # 使用模板Omnidirectional Burst Spawn Burst Instantaneous Initialize Particle 添加模块 Calculate Size and Rotational Inertia by Mass Shape Location Scale Color 添加模块 Collision 创建粒子发射器NE_Fireball # 使用模板Simple Sprite Burst Emitter State Spawn Burst Instantaneous Initialize Particle 添加模块 Shape Location 添加模块 Drag 调整位置 Solve Forces and Velocity 添加模块 Sub UVAnimation 消散效果不协调 Scale Color Render 添加模块 Add Velocity 无法在 Particle Update 添加 创建粒子发射器NE_Flash # 使用模板Simple Sprite Burst Emitter State Initialize Particle 取消未使用模块勾选 添加模块 Scale Sprite Size Render 创建粒子发射器NE_Smoke # 使用模板Simple Sprite Burst Emitter State Spawn Burst Instantaneous Initialize Particle 添加模块 Shape Location 添加模块 Drag 调整位置 Solve Forces and Velocity Scale Color 添加模块 Sub UVAnimation Render 添加模块 Add Velocity 无法在 Particle Update 添加 创建粒子系统NS_ProjectileExplosion # 使用现有粒子发射器, 有序添加NE_Burst, NE_Fireball, NE_Flash, NE_Smoke 配置榴弹使用 # 效果很不理想, 有待调整 创建撞击特效 # 创建文件夹 Content/VFX/Impacts 创建粒子发射器NE_BurstOut # 使用模板Directional Burst 创建粒子发射器NE_CoreFast # 使用模板Simple Sprite Burst 创建粒子发射器NE_ShortBurst1 # 使用模板Simple Sprite Burst 创建粒子发射器NE_ShortBurst2 # 使用模板Simple Sprite Burst 创建粒子系统NS_RifleDefaultImpact # 子弹射击金属的效果 创建空的粒子系统 依次添加NE_ShortBurst1和NE_ShortBurst2: 烟雾效果 添加两个NE_CoreFast, 分别命名为NE_CoreFastOrange, NE_CoreFastBlue; 修改NE_CoreFastBlue颜色 添加NE_LauncherFlash和NE_BurstOut 创建粒子系统NS_RifleGroundImpact # 拷贝NS_RifleDefaultImpact改名 创建粒子系统NS_RifleBodyImpact # 拷贝NS_RifleDefaultImpact改名, NE_BurstOut粒子数增加为40 创建粒子系统NS_RifleHeadImpact # 拷贝NS_RifleDefaultImpact改名 增加NE_BurstOut粒子数 修改NE_BurstOut粒子颜色 设置步枪击中特效的默认类型和映射 # 移动旧资产 # 创建文件夹 Content/VFX/Dev 将PS_Test, NE_BaseImpact移动到Dev目录下 将NS_DefaultImpact, NS_GroundImpact, NS_BodyImpact和NS_HeadImpact移动到Dev目录下 将NS_ProjectileImpact移动到Projectile目录下 打包游戏 # "}),e.add({id:143,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/emms/",title:"emms",description:"播放器和Emacs之间的接口 便签 # GNU Emms Manual emms-安装 # (use-package emms :ensure t :init (emms-all) :config (setq emms-player-list '(emms-player-mpv) emms-info-function '(emms-info-native) emms-source-file-default-directory my/movie-path emms-seek-seconds 5) :bind ((\u0026quot;C-c e SPC\u0026quot; . emms-pause) (\u0026quot;C-c e f\u0026quot; . emms-seek-forward) (\u0026quot;C-c e b\u0026quot; . emms-seek-backward) (\u0026quot;C-c e p\u0026quot; . emms-previous) (\u0026quot;C-c e n\u0026quot; . emms-next) (\u0026quot;C-c e x\u0026quot; . emms-stop) (\u0026quot;C-c e e\u0026quot; . emms))) emms-快捷键 # 使用Emacs做视频笔记 - C-c e SPC 暂停/播放 C-c e f 前进 C-c e b 后退 C-c e p 上一个 C-c e n 下一个 C-c e x 关闭播放器 C-c e e 打开播放列表 C-c e i 插入时间戳 C-c e g 时间戳跳转 ",content:"播放器和Emacs之间的接口 便签 # GNU Emms Manual emms-安装 # (use-package emms :ensure t :init (emms-all) :config (setq emms-player-list '(emms-player-mpv) emms-info-function '(emms-info-native) emms-source-file-default-directory my/movie-path emms-seek-seconds 5) :bind ((\u0026quot;C-c e SPC\u0026quot; . emms-pause) (\u0026quot;C-c e f\u0026quot; . emms-seek-forward) (\u0026quot;C-c e b\u0026quot; . emms-seek-backward) (\u0026quot;C-c e p\u0026quot; . emms-previous) (\u0026quot;C-c e n\u0026quot; . emms-next) (\u0026quot;C-c e x\u0026quot; . emms-stop) (\u0026quot;C-c e e\u0026quot; . emms))) emms-快捷键 # 使用Emacs做视频笔记 - C-c e SPC 暂停/播放 C-c e f 前进 C-c e b 后退 C-c e p 上一个 C-c e n 下一个 C-c e x 关闭播放器 C-c e e 打开播放列表 C-c e i 插入时间戳 C-c e g 时间戳跳转 "}),e.add({id:144,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E6%AD%A6%E5%99%A8%E6%B4%BE%E7%94%9F%E7%B1%BB/",title:"武器派生类",description:"说明 # 当前的STUBaseWeapon类基本实现了Rifle的逻辑, Launcher无连续射击和瞄准偏离逻辑 创建STUBaseWeapon的派生类STURifleWeapon和STULauncherWeapon, 把Rifle的逻辑移动到STURifleWeapon, 使STUBaseWeapon成为一个武器意义上的抽象类 武器类 基类 STUBaseWeapon 派生类 Rifle STURifleWeapon Launcher STULauncherWeapon 概览 # 创建派生自STUBaseWeapon的C++类: STURifleWeapon和STULauncherWeapon 调整STUBaseWeapon逻辑 将Rifle的逻辑拷贝到STURifleWeapon 创建基于STURifleWeapon和STULauncherWeapon的蓝图类, 并为之绑定武器模型 验证Rifle逻辑正常 创建派生自STUBaseWeapon的C++类 # 类别 上级文件夹 STURifleWeapon Public Weapon STULauncherWeapon Public Weapon 在内容浏览器选中C++ Classes \u0026gt; ShootThemUp \u0026gt; Public \u0026gt; Weapon \u0026gt; STUBaseWeapon, 右键 调整STUBaseWeapon逻辑 # 屏蔽连续射击 # 屏蔽射击定时器和时间间隔 将MakeShot声明为虚函数, 定义为空 将FireStart和FireStop定义为空 屏蔽瞄准偏离 # 将GetTraceData定义为虚函数, 屏蔽瞄准偏离逻辑 屏蔽圆锥偏移角参数 屏蔽头文件 # // #include \u0026quot;DrawDebugHelpers.h\u0026quot; // #include \u0026quot;TimerManager.h\u0026quot; 将STUBaseWeapon屏蔽的Rifle逻辑拷贝到STURifleWeapon # 连续射击 # 定义射击定时器和时间间隔 ShootThemUp: Weapon/STURifleWeapon.",content:"说明 # 当前的STUBaseWeapon类基本实现了Rifle的逻辑, Launcher无连续射击和瞄准偏离逻辑 创建STUBaseWeapon的派生类STURifleWeapon和STULauncherWeapon, 把Rifle的逻辑移动到STURifleWeapon, 使STUBaseWeapon成为一个武器意义上的抽象类 武器类 基类 STUBaseWeapon 派生类 Rifle STURifleWeapon Launcher STULauncherWeapon 概览 # 创建派生自STUBaseWeapon的C++类: STURifleWeapon和STULauncherWeapon 调整STUBaseWeapon逻辑 将Rifle的逻辑拷贝到STURifleWeapon 创建基于STURifleWeapon和STULauncherWeapon的蓝图类, 并为之绑定武器模型 验证Rifle逻辑正常 创建派生自STUBaseWeapon的C++类 # 类别 上级文件夹 STURifleWeapon Public Weapon STULauncherWeapon Public Weapon 在内容浏览器选中C++ Classes \u0026gt; ShootThemUp \u0026gt; Public \u0026gt; Weapon \u0026gt; STUBaseWeapon, 右键 调整STUBaseWeapon逻辑 # 屏蔽连续射击 # 屏蔽射击定时器和时间间隔 将MakeShot声明为虚函数, 定义为空 将FireStart和FireStop定义为空 屏蔽瞄准偏离 # 将GetTraceData定义为虚函数, 屏蔽瞄准偏离逻辑 屏蔽圆锥偏移角参数 屏蔽头文件 # // #include \u0026quot;DrawDebugHelpers.h\u0026quot; // #include \u0026quot;TimerManager.h\u0026quot; 将STUBaseWeapon屏蔽的Rifle逻辑拷贝到STURifleWeapon # 连续射击 # 定义射击定时器和时间间隔 ShootThemUp: Weapon/STURifleWeapon.h protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float TimeBetweenShots = 0.1f; private FTimerHandle ShotTimerHandle; 覆写虚函数MakeShot ShootThemUp: Weapon/STURifleWeapon.h protected virtual void MakeShot() override; ShootThemUp: Weapon/STURifleWeapon.cpp #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;DrawDebugHelpers.h\u0026quot; void ASTURifleWeapon::MakeShot() { if (!GetWorld()) return; FVector TraceStart, TraceEnd; if (!GetTraceData(TraceStart, TraceEnd)) return; FHitResult HitResult; MakeHit(HitResult, TraceStart, TraceEnd); if (HitResult.bBlockingHit) { DrawDebugLine(GetWorld(), GetMuzzleWorldLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f); DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); MakeDamage(HitResult); } else { DrawDebugLine(GetWorld(), GetMuzzleWorldLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); } } 覆写FireStart和FireStop ShootThemUp: Weapon/STURifleWeapon.h public virtual void FireStart() override; virtual void FireStop() override; ShootThemUp: Weapon/STURifleWeapon.cpp #include \u0026quot;TimerManager.h\u0026quot; void ASTURifleWeapon::FireStart() { MakeShot(); GetWorldTimerManager().SetTimer(ShotTimerHandle, this, \u0026amp;ASTURifleWeapon::MakeShot, TimeBetweenShots, true); } void ASTURifleWeapon::FireStop() { GetWorldTimerManager().ClearTimer(ShotTimerHandle); } 瞄准偏离 # 定义偏移角 protected ShootThemUp: Weapon/STURifleWeapon.cpp UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float BulletSpread = 1.5f; 覆写GetTraceData ShootThemUp: Weapon/STURifleWeapon.h protected virtual void GetTraceData(FVector\u0026amp; TraceStart, FVector\u0026amp; TraceEnd) const override; ShootThemUp: Weapon/STURifleWeapon.cpp bool ASTURifleWeapon::GetTraceData(FVector\u0026amp; TraceStart, FVector\u0026amp; TraceEnd) const { FVector ViewLocation; FRotator ViewRotation; if (!GetPlayerViewPoint(ViewLocation, ViewRotation)) return false; TraceStart = ViewLocation; const auto HalfRad = FMath::DegreesToRadians(BulletSpread); const FVector ShootDirection = FMath::VRandCone(ViewRotation.Vector(), HalfRad); TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; return true; } 创建基于STURifleWeapon和STULauncherWeapon的蓝图类 # 保存到Content/Weapon/目录下 测试BP_STURifleWeapon # 为BP_STURifleWeapon绑定武器模型Rifle 设置游戏角色武器类属性为BP_STURifleWeapon 功能正常 测试BP_STULauncherWeapon # 为BP_STULauncherWeapon绑定武器模型Launcher 设置游戏角色武器类属性为BP_STULauncherWeapon 武器正常显示, 射击无反应 "}),e.add({id:145,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E4%BD%BF%E7%94%A8eqs%E5%9C%A8%E6%95%8C%E4%BA%BA%E9%99%84%E8%BF%91%E7%A7%BB%E5%8A%A8/",title:"使用EQS在敌人附近移动",description:"说明 # AI / EQS / Context 完成两点 在敌人周围生成具有随机性的点阵, 选择一个位置点, 去到那里 设置点阵中心为敌人 生成创建BP类 # Content/AI/EQS目录下, 创建EQS资产EQS_NextToEnemyLocation 为EQS_TestPawn设置EQS模板: 在世界大纲中选中EQS_TestPawn, Details \u0026gt; EQS \u0026gt; Query Template , 设置为EQS_NextToEnemyLocation 设置EQS资产 # EQS_NextToEnemyLocation 生成附近随机位置 添加生成器: 环形点阵 设置环形点阵 - Projection Data \u0026gt; Track Mode Navigation Inner Radius Data Binding = None, Inner Radius = 450 Outer Radius Data Binding = Random number, Outer Radius = 1000-1500 Number Of Rings Data Binding = Random number, Number Of Rings = 3-8 Points Per Ring Data Binding = Random number, Number Of Rings = 4-20 Arc Angle 360 Use Spiral Pattern 勾选 为环形点阵添加距离条件: Distance 设置Distance - Filter \u0026gt; Filter Type Range: 400-800 Score \u0026gt; Scoring Factor Data Binding = Random number, Scoring Factor = -1 ~ 1, 随机 使用蓝图类测试 # 创建蓝图类 # - 基类 EnvQueryContext_BlueprintBase 路径 AI/EQS 名称 EQS_ContextSTUCharacter 覆写函数 # 选择返回Actor或者位置 双击打开 EQS_NextToEnemyLocation 选择函数原型 # My Blueprint \u0026gt; Functions Override , 选择 Provide Single Actor - Provide Actors Set Actor数组 Provide Locations Set 位置数组 Provide Single Actor 单一Actor Provide Single Location 单一位置 覆写 # 筛选Actor类型 Provide Single Actor 之后, 添加节点: Get All Actors Of Class , 设置类类型为STUBaseCharacter Get All Actor Of Class 之后, 返回第一个元素, 添加节点: Get (a copy) 未作检查, 返回第一个元素 设置中心点 # 设置中心点 设置环状点阵生成器中心点使用EQS_ContextSTUCharacter 设置Distance距离计算参照点使用EQS_ContextSTUCharacter 查看 在场景中添加BP_STUBaseCharacter 移动游戏角色, 再次选中TestPawn, 环状点阵的中心一直是游戏角色 移除游戏角色 在行为树中使用 # 选择 Run EQS Query, 设置使用的模板为 EQS_NextToEnemyLocation Details \u0026gt; EQS \u0026gt; Query Template , 选择EQS_NextToEnemyLocation 运行游戏 NPC始终在游戏角色附近的圆环点阵中切换位置 学习EnvQueryContext_Querier # 构造函数 PrivideContext 该函数只用来计算Actor, 返回计算得到Actor 获取EQS上级, 并通过SetContextHelper设置给ContextData 我们要做的, 即获取黑板变量EnemyActor对应的Actor, 并设置给ContextData QueryOwener: Pawn或者Character, EQS的上级 使用C++类实现 # 设置黑板变量EnemyActor 创建C++类 # - EnvQueryContext STUEnemyEnvQueryContext AI/EQS Public 修改STUUtils.",content:`说明 # AI / EQS / Context 完成两点 在敌人周围生成具有随机性的点阵, 选择一个位置点, 去到那里 设置点阵中心为敌人 生成创建BP类 # Content/AI/EQS目录下, 创建EQS资产EQS_NextToEnemyLocation 为EQS_TestPawn设置EQS模板: 在世界大纲中选中EQS_TestPawn, Details \u0026gt; EQS \u0026gt; Query Template , 设置为EQS_NextToEnemyLocation 设置EQS资产 # EQS_NextToEnemyLocation 生成附近随机位置 添加生成器: 环形点阵 设置环形点阵 - Projection Data \u0026gt; Track Mode Navigation Inner Radius Data Binding = None, Inner Radius = 450 Outer Radius Data Binding = Random number, Outer Radius = 1000-1500 Number Of Rings Data Binding = Random number, Number Of Rings = 3-8 Points Per Ring Data Binding = Random number, Number Of Rings = 4-20 Arc Angle 360 Use Spiral Pattern 勾选 为环形点阵添加距离条件: Distance 设置Distance - Filter \u0026gt; Filter Type Range: 400-800 Score \u0026gt; Scoring Factor Data Binding = Random number, Scoring Factor = -1 ~ 1, 随机 使用蓝图类测试 # 创建蓝图类 # - 基类 EnvQueryContext_BlueprintBase 路径 AI/EQS 名称 EQS_ContextSTUCharacter 覆写函数 # 选择返回Actor或者位置 双击打开 EQS_NextToEnemyLocation 选择函数原型 # My Blueprint \u0026gt; Functions Override , 选择 Provide Single Actor - Provide Actors Set Actor数组 Provide Locations Set 位置数组 Provide Single Actor 单一Actor Provide Single Location 单一位置 覆写 # 筛选Actor类型 Provide Single Actor 之后, 添加节点: Get All Actors Of Class , 设置类类型为STUBaseCharacter Get All Actor Of Class 之后, 返回第一个元素, 添加节点: Get (a copy) 未作检查, 返回第一个元素 设置中心点 # 设置中心点 设置环状点阵生成器中心点使用EQS_ContextSTUCharacter 设置Distance距离计算参照点使用EQS_ContextSTUCharacter 查看 在场景中添加BP_STUBaseCharacter 移动游戏角色, 再次选中TestPawn, 环状点阵的中心一直是游戏角色 移除游戏角色 在行为树中使用 # 选择 Run EQS Query, 设置使用的模板为 EQS_NextToEnemyLocation Details \u0026gt; EQS \u0026gt; Query Template , 选择EQS_NextToEnemyLocation 运行游戏 NPC始终在游戏角色附近的圆环点阵中切换位置 学习EnvQueryContext_Querier # 构造函数 PrivideContext 该函数只用来计算Actor, 返回计算得到Actor 获取EQS上级, 并通过SetContextHelper设置给ContextData 我们要做的, 即获取黑板变量EnemyActor对应的Actor, 并设置给ContextData QueryOwener: Pawn或者Character, EQS的上级 使用C++类实现 # 设置黑板变量EnemyActor 创建C++类 # - EnvQueryContext STUEnemyEnvQueryContext AI/EQS Public 修改STUUtils.h的预编译命令的遗留错误 # STUUtils.h #pragma once 修改头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot;, \u0026quot;ShootThemUp/Public/Pickups\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon/Components\u0026quot;, \u0026quot;ShootThemUp/Public/AI\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Tasks\u0026quot;, \u0026quot;ShootThemUp/Public/AI/Services\u0026quot;, \u0026quot;ShootThemUp/Public/AI/EQS\u0026quot; }); 实现STUEnemyEnvQueryContext # 添加属性: EnemyActor变量名 # protected ShootThemUp: AI/EQS/STUEnemyEnvQueryContext.h UPROPERTY(EditAnywhere, BlueprintReadWrite) FName EnemyActorKeyName = \u0026quot;EnemyActor\u0026quot;; 覆写虚函数 # public ShootThemUp: AI/EQS/STUEnemyEnvQueryContext.h virtual void ProvideContext(FEnvQueryInstance \u0026amp;QueryInstance, FEnvQueryContextData \u0026amp;ContextData) const override; 获取EQS上级对应的Actor
FEnvQueryInstance在EnvQueryTypes.h中 #include \u0026quot;EnvironmentQuery/EnvQueryTypes.h\u0026quot; const auto QueryOwner = Cast\u0026lt;AActor\u0026gt;(QueryInstance.Owner.Get()); 获取黑板组件
通过转换EQS上级得到Pawn, 通过Pawn得到Controller; 指定组件类型, 通过Controller获取黑板组件 #include \u0026quot;Blueprint/AIBlueprintHelperLibrary.h\u0026quot; #include \u0026quot;BehaviorTree/BlackboardComponent.h\u0026quot; const auto Blackboard = UAIBlueprintHelperLibrary::GetBlackboard(QueryOwner); if (!Blackboard) return; 获取黑板变量
const auto ContextActor = Blackboard-\u0026gt;GetValueAsObject(EnemyActorKeyName); 将黑板变量用作中心点
#include \u0026quot;EnvironmentQuery/Items/EnvQueryItemType_Actor.h\u0026quot; UEnvQueryItemType_Actor::SetContextHelper(ContextData, Cast\u0026lt;AActor\u0026gt;(ContextActor)); 完整实现
ShootThemUp: AI/EQS/STUEnemyEnvQueryContext.cpp #include \u0026quot;EnvironmentQuery/EnvQueryTypes.h\u0026quot; #include \u0026quot;Blueprint/AIBlueprintHelperLibrary.h\u0026quot; #include \u0026quot;BehaviorTree/BlackboardComponent.h\u0026quot; #include \u0026quot;EnvironmentQuery/Items/EnvQueryItemType_Actor.h\u0026quot; void USTUEnemyEnvQueryContext::ProvideContext(FEnvQueryInstance \u0026amp;QueryInstance, FEnvQueryContextData \u0026amp;ContextData) const { const auto QueryOwner = Cast\u0026lt;AActor\u0026gt;(QueryInstance.Owner.Get()); const auto Blackboard = UAIBlueprintHelperLibrary::GetBlackboard(QueryOwner); if (!Blackboard) return; const auto ContextActor = Blackboard-\u0026gt;GetValueAsObject(EnemyActorKeyName); UEnvQueryItemType_Actor::SetContextHelper(ContextData, Cast\u0026lt;AActor\u0026gt;(ContextActor)); } 使用C++类STUEnemyEnvQueryContext # 设置行为树 # BT_STUCharacter 在环形点阵和距离限制条件中使用STUEnemyEnvQueryContext 恢复行为树框架, 移除Task 添加任务: RunEQSQuery - EQS_NextToEnemyLocation 添加任务: RunEQSQuery - EQS_RandomRoam 暂时移除Fire服务里目标: 点击恢复图标 查看 # 按下 ' 打开调试界面 选中AICharacter 按下小写键盘 3 显示EQS 当前存在两个EQS点阵, 按下小写键盘 * 显示当前EQS Project Settings \u0026gt; Engine \u0026gt; Gameplay Debugger 对于EQS的使用, 我们现在可以设置任意移动模板, 或者随机结合他们 可以移除楼梯和模拟爆炸 可以添加墙, 躲避NPC捕获 `}),e.add({id:146,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E6%A6%B4%E5%BC%B9%E7%B1%BB/",title:"榴弹类",description:"说明 # 榴弹发射器 Grenade Launcher 发射榴弹 榴弹没有对应网格体，也不属于某个粒子系统 Particle System 概览 # 为榴弹发射器网格体添加MuzzleSocket 创建榴弹类, 为其添加球体组件 初始化STULauncherWeapon; 发射时, 动态生成榴弹对象 创建基于榴弹类的蓝图类 创建用于榴弹类的材质类和材质实例类 球体组件 # USphereComponent Spherical Collision UCapsuleComponent Capsule Collision 外形是球， 提供碰撞功能 球体组件的碰撞相较Capsule组件的碰撞更为简单 为网格体Launcher添加MuzzleSocket # 虚幻编辑器 打开Contents/ExternalContent/Weapon/Weapons/Launcher 选中LauncherRoot, 右键, 选择Add Socket 选中Socket, 去到Details页面, 进行设置 - SocketName MuzzleSocket Location (0, -15, 65) Rotation (-90, 90, 0) 图示Relative Rotation \u0026gt; Y错误: 应为90, 失误填成9 创建榴弹类 # 创建C++类STUProjectile # 虚幻编辑器 Tools \u0026gt; New C++ Class.. - 基类 Actor 上级目录 Weapon 访问属性 Public 类名 STUProjectile 调整框架 # C++ 每帧调用false 无Tick ShootThemUp: Weapon/STUProjectile.",content:"说明 # 榴弹发射器 Grenade Launcher 发射榴弹 榴弹没有对应网格体，也不属于某个粒子系统 Particle System 概览 # 为榴弹发射器网格体添加MuzzleSocket 创建榴弹类, 为其添加球体组件 初始化STULauncherWeapon; 发射时, 动态生成榴弹对象 创建基于榴弹类的蓝图类 创建用于榴弹类的材质类和材质实例类 球体组件 # USphereComponent Spherical Collision UCapsuleComponent Capsule Collision 外形是球， 提供碰撞功能 球体组件的碰撞相较Capsule组件的碰撞更为简单 为网格体Launcher添加MuzzleSocket # 虚幻编辑器 打开Contents/ExternalContent/Weapon/Weapons/Launcher 选中LauncherRoot, 右键, 选择Add Socket 选中Socket, 去到Details页面, 进行设置 - SocketName MuzzleSocket Location (0, -15, 65) Rotation (-90, 90, 0) 图示Relative Rotation \u0026gt; Y错误: 应为90, 失误填成9 创建榴弹类 # 创建C++类STUProjectile # 虚幻编辑器 Tools \u0026gt; New C++ Class.. - 基类 Actor 上级目录 Weapon 访问属性 Public 类名 STUProjectile 调整框架 # C++ 每帧调用false 无Tick ShootThemUp: Weapon/STUProjectile.h ShootThemUp: Weapon/STUProjectile.cpp 添加球体组件, 提供碰撞功能 # C++ 添加组件 protected ShootThemUp: Weapon/STUProjectile.h class USphereComponent; UPROPERTY(VisibleDefaultsOnly) USphereComponent *CollisionComponent; 初始化组件: 碰撞半径为5, 设为根组件 ShootThemUp: Weapon/STUProjectile.cpp #include \u0026quot;Components/SphereComponent.h\u0026quot; // Constructor CollisionComponent = CreateDefaultSubobject\u0026lt;USphereComponent\u0026gt;(\u0026quot;SphereComponent\u0026quot;); // set collision radius CollisionComponent-\u0026gt;InitSphereRadius(5.0f); SetRootComponent(CollisionComponent); 初始化STULauncherWeapon # 覆写虚函数FireStart和MakeShot ShootThemUp: Weapon/STULauncherWeapon.h // public virtual void FireStart() override; // protected virtual void MakeShot() override; 在FireStart中调用MakeShot ShootThemUp: Weapon/STULauncherWeapon.cpp void ASTULauncherWeapon::FireStart() { MakeShot(); } void ASTULauncherWeapon::MakeShot() { } 榴弹发射器发射榴弹时, 动态生成榴弹对象 # 添加榴弹类属性 # protected ShootThemUp: Weapon/STULauncherWeapon.h class ASTUProjectile; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) TSubclassOf\u0026lt;ASTUProjectile\u0026gt; ProjectileClass; 在MakeShot动态创建榴弹对象 # 榴弹初始位置在枪口 之后需要对榴弹进行参数配置, 延后调用BeginPlay ShootThemUp: Weapon/STULauncherWeapon.cpp #include \u0026quot;Weapon/STUProjectile.h\u0026quot; #include \u0026quot;Kismet/GameplayStatics.h\u0026quot; #include \u0026quot;Engine/World.h\u0026quot; void ASTULauncherWeapon::MakeShot() { const FTransform SpawnTransform(FRotator::ZeroRotator, GetMuzzleWorldLocation()); auto Projectile = UGameplayStatics::BeginDeferredActorSpawnFromClass(GetWorld(), ProjectileClass, SpawnTransform); // 设置榴弹参数 UGameplayStatics::FinishSpawningActor(Projectile, SpawnTransform); } 创建基于STUProjectile的蓝图类 # 虚幻编辑器 选中C++ Classed \u0026gt; ShootThemUp \u0026gt; Public \u0026gt; Weapon \u0026gt; STUProjectile, 右键, 选择Create Blueprint class based on STUProjectile 命名为BP_STUProjectile, 保存到Content/Weapon 查看BP_STUProjectile # 有CollisionComponent 添加静态网格体组件 # 点击Add, 搜索Sphere, 选择Basic Shapes \u0026gt; Sphere 选中Sphere, 去到细节面板, 设置缩放属性, 与碰撞大小匹配 - Transfrom \u0026gt; Scale (0.095, 0.095, 0.095) 设置BP_STULauncherWeapon的榴弹类属性为BP_STUProjectile # 为榴弹类应用材质 # 创建材质类 # 创建文件夹Content/Materials 在材质目录创建材质类 命名为M_BaseColor 设置材质类 # 双击打开M_BaseColor 在Material Graph空白处点击鼠标左键, 同时按下数字4, 创建四维常量, 作为Base Color的输入 右键四维常量, 将其转换为参数, 命名为Color 创建材质实例类 # 选中M_BaseColor, 右键 命名为MI_RedColor 配置材质实例类 # 双击打开MI_RedColor 在细节面板勾选Color参数 设置Color参数 为BP_STUProjectile设置材质 # 选择Sphere 去到Details \u0026gt; Materials, 设置Element 0 查看 # 点击鼠标左键射击, 榴弹发射器发射红色小球 "}),e.add({id:147,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/prettry-hydra/",title:"prettry-hydra",description:"自定义快捷键菜单 pretty-hydra-安装 # (use-package pretty-hydra :ensure t :init (pretty-hydra-define emms-video-hydra (:title \u0026quot;Emms-hydra\u0026quot; :quit-key \u0026quot;q\u0026quot; :color blue) ;; 为Emms定制播放菜单 (\u0026quot;Control\u0026quot; ((\u0026quot;SPC\u0026quot; emms-pause \u0026quot;Pause\u0026quot;) (\u0026quot;f\u0026quot; emms-seek-forward \u0026quot;Fast Forward\u0026quot;) (\u0026quot;b\u0026quot; emms-seek-backward \u0026quot;Rewind\u0026quot;) (\u0026quot;p\u0026quot; emms-previous \u0026quot;Previous\u0026quot;) (\u0026quot;n\u0026quot; emms-next \u0026quot;Next\u0026quot;) (\u0026quot;x\u0026quot; emms-stop \u0026quot;Stop\u0026quot;)))) :bind(\u0026quot;C-c e m\u0026quot; . emms-video-hydra/body)) pretty-hydra-快捷键 # - C-c e m 打开Emms菜单 ",content:"自定义快捷键菜单 pretty-hydra-安装 # (use-package pretty-hydra :ensure t :init (pretty-hydra-define emms-video-hydra (:title \u0026quot;Emms-hydra\u0026quot; :quit-key \u0026quot;q\u0026quot; :color blue) ;; 为Emms定制播放菜单 (\u0026quot;Control\u0026quot; ((\u0026quot;SPC\u0026quot; emms-pause \u0026quot;Pause\u0026quot;) (\u0026quot;f\u0026quot; emms-seek-forward \u0026quot;Fast Forward\u0026quot;) (\u0026quot;b\u0026quot; emms-seek-backward \u0026quot;Rewind\u0026quot;) (\u0026quot;p\u0026quot; emms-previous \u0026quot;Previous\u0026quot;) (\u0026quot;n\u0026quot; emms-next \u0026quot;Next\u0026quot;) (\u0026quot;x\u0026quot; emms-stop \u0026quot;Stop\u0026quot;)))) :bind(\u0026quot;C-c e m\u0026quot; . emms-video-hydra/body)) pretty-hydra-快捷键 # - C-c e m 打开Emms菜单 "}),e.add({id:148,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E4%B8%BA%E6%A6%B4%E5%BC%B9%E7%B1%BB%E6%B7%BB%E5%8A%A0%E8%BF%90%E5%8A%A8/",title:"为榴弹类添加运动",description:"说明 # 我们可以在Tick函数中, 根据时间间隔 Delta 改变Actor位置; 本节在于介绍榴弹类运动组件 为榴弹类添加抛物运动组件, 给组件设置速度, 使榴弹对象以恒定速度运动 UProjectileMovementComponent 概览 # 为榴弹类添加抛物运动组件, 并添加相关接口和数据成员 重新实现榴弹类创建榴弹对象逻辑 在榴弹类中, 计算并配置榴弹运动方向 设置榴弹蓝图类抛物运动组件相关参数 为榴弹对象添加销毁定时器 提供参数期待值 抛物运动组件 # UProjectileMovementComponent 根据组件参数, 计算Actor位置, 在Tick函数中进行设置 游戏角色运动逻辑在UCharacterMovementComponent，榴弹类有UProjectileMovementComponent, 二者有共同的基类UMovementComponent, 具有改变Actor在空间中位置的能力 可以用来实现寻的导弹 Homing Missile ; 可以设置与其他物体发生碰撞时的反弹次数 我们希望榴弹以恒定速度运动, 主要使用以下参数 - Velocity 矢量, 方向 + 标量 InitialSpeed 可配置的初始速度 ProjectileGravityScale 默认值为1, 受到重力影响; 设置为0 注意到InitialSpeed是组件自带的属性, 我们认为所有的运动信息应该储存在运动组件中 纯逻辑组件 为榴弹类添加抛物运动组件 # 添加数据成员存放运动方向 # private ShootThemUp: Weapon/STUProjectile.h FVector ShotDirection; 提供设置运动方向的接口 # public ShootThemUp: Weapon/STUProjectile.h void SetShotDirection(const FVector\u0026amp; Direction) { ShotDirection = Direction; } 添加抛物运动组件 # protected ShootThemUp: Weapon/STUProjectile.",content:"说明 # 我们可以在Tick函数中, 根据时间间隔 Delta 改变Actor位置; 本节在于介绍榴弹类运动组件 为榴弹类添加抛物运动组件, 给组件设置速度, 使榴弹对象以恒定速度运动 UProjectileMovementComponent 概览 # 为榴弹类添加抛物运动组件, 并添加相关接口和数据成员 重新实现榴弹类创建榴弹对象逻辑 在榴弹类中, 计算并配置榴弹运动方向 设置榴弹蓝图类抛物运动组件相关参数 为榴弹对象添加销毁定时器 提供参数期待值 抛物运动组件 # UProjectileMovementComponent 根据组件参数, 计算Actor位置, 在Tick函数中进行设置 游戏角色运动逻辑在UCharacterMovementComponent，榴弹类有UProjectileMovementComponent, 二者有共同的基类UMovementComponent, 具有改变Actor在空间中位置的能力 可以用来实现寻的导弹 Homing Missile ; 可以设置与其他物体发生碰撞时的反弹次数 我们希望榴弹以恒定速度运动, 主要使用以下参数 - Velocity 矢量, 方向 + 标量 InitialSpeed 可配置的初始速度 ProjectileGravityScale 默认值为1, 受到重力影响; 设置为0 注意到InitialSpeed是组件自带的属性, 我们认为所有的运动信息应该储存在运动组件中 纯逻辑组件 为榴弹类添加抛物运动组件 # 添加数据成员存放运动方向 # private ShootThemUp: Weapon/STUProjectile.h FVector ShotDirection; 提供设置运动方向的接口 # public ShootThemUp: Weapon/STUProjectile.h void SetShotDirection(const FVector\u0026amp; Direction) { ShotDirection = Direction; } 添加抛物运动组件 # protected ShootThemUp: Weapon/STUProjectile.h class UProjectileMovementComponent; UPROPERTY(VisibleDefaultsOnly) UProjectileMovementComponent *MovementComponent; 初始化抛物运动组件 # ShootThemUp: Weapon/STUProjectile.cpp 初始化组件 #include \u0026quot;GameFramework/ProjectileMovementComponent.h\u0026quot; // Constructor MovementComponent = CreateDefaultSubobject\u0026lt;UProjectileMovementComponent\u0026gt;(\u0026quot;ProjectileMovementComponent\u0026quot;); 设置速度 // BeginPlay check(MovementComponent); MovementComponent-\u0026gt;Velocity = ShotDirection * MovementComponent-\u0026gt;InitialSpeed; 榴弹发射器类的射击逻辑 # 重新实现动态创建榴弹对象逻辑 # UGameplayStatics::BeginDeferredActorSpawnFromClass返回指向Actor对象的指针, 使用Actor派生类对象前需进行转换 UWorld::SpawnActorDeferred返回指向Actor派生类对象的指针 屏蔽UGamePlayStatics头文件 ShootThemUp: Weapon/STULauncherWeapon.cpp if (!GetWorld()) return; ASTUProjectile *Projectile = GetWorld()-\u0026gt;SpawnActorDeferred\u0026lt;ASTUProjectile\u0026gt;(ProjectileClass, SpawnTransform); if (Projectile) { // 设置Projectile参数 Projectile-\u0026gt;FinishSpawning(SpawnTransform); } 设置榴弹对象运动方向 # 榴弹真实轨迹 # 参考ASTUBaseWeapon::GetTraceData, 游戏角色Camera组件的位置+旋转 ShootThemUp: Weapon/STUBaseWeapon.cpp 榴弹呈现的运动方向 # 修改起始位置为枪口, 根据最终位置计算其运动方向 参考ASTURifleWeapon::MakeShot中绘制子弹轨迹 ShootThemUp: Weapon/STURifleWeapon.cpp - 起点 枪口位置 终点 碰撞点或计算得到的终点 运动方向 终点 - 起点 计算榴弹运动方向 ShootThemUp: Weapon/STULauncherWeapon.cpp // MakeShot FVector TraceStart, TraceEnd; if (!GetTraceData(TraceStart, TraceEnd)) return; FHitResult HitResult; MakeHit(HitResult, TraceStart, TraceEnd); const FVector EndPoint = HitResult.bBlockingHit ? HitResult.ImpactPoint : TraceEnd; const FVector Direction = (EndPoint - GetMuzzleWorldLocation()).GetSafeNormal(); 设置榴弹对象的运动方向 ShootThemUp: Weapon/STULauncherWeapon.cpp // MakeShot Projectile-\u0026gt;SetShotDirection(Direction); 设置BP_STUProjectile # 新增ProjectileMovementComponent # InitialSpeed默认值为0, 榴弹发射器射击时, 榴弹做自由落体运动 # 设置IntialSpeed为2000, 榴弹在垂直方向受到重力的影响 # MovementComponent \u0026gt; Details \u0026gt; Projectile \u0026gt; Initial Speed, 设置为2000 ProjectileGravityScale默认为1 # 设置ProjectileGravityScale为0, 使榴弹不受重力影响, 可以经过绿色瞄准十字 # MovementComponent \u0026gt; Details \u0026gt; Projectile Gravity Scale, 设置为0 注意到除非发生碰撞, 榴弹会一直运动 # 创建榴弹后, 开启销毁定时器 # ShootThemUp: Weapon/STULauncherWeapon.cpp Projectile-\u0026gt;SetLifeSpan(5.0f); 榴弹创建后5s消失 在代码中设置抛物运动组件 # 开发时, 抛物运动组件有其合适的参数. 为避免在虚幻编辑器做出不当设置, 我们可以在BeginPlay中进行检查 在这之前, 需要在初始化组件时, 给出期待值 ShootThemUp: Weapon/STUProjectile.cpp // Constructor MovementComponent-\u0026gt;InitialSpeed = 2000.0f; MovementComponent-\u0026gt;ProjectileGravityScale = 0.0f; "}),e.add({id:149,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/ox-hugo/",title:"ox-hugo",description:"导出Hugo兼容Markdown文件, 支持批量(子树)导出 ox-hugo-安装 # (use-package ox-hugo :ensure t ;Auto-install the package from Melpa :pin melpa ;`package-archives' should already have (\u0026quot;melpa\u0026quot; . \u0026quot;https://melpa.org/packages/\u0026quot;) :after ox :config ;; 不处理图片 (setq org-hugo-external-file-extensions-allowed-for-copying nil)) ox-hugo-快捷键 # 使用ox-hugo导出博客 - C-c h s 导出所属子树 C-c h a 导出文件内所有子树 ",content:"导出Hugo兼容Markdown文件, 支持批量(子树)导出 ox-hugo-安装 # (use-package ox-hugo :ensure t ;Auto-install the package from Melpa :pin melpa ;`package-archives' should already have (\u0026quot;melpa\u0026quot; . \u0026quot;https://melpa.org/packages/\u0026quot;) :after ox :config ;; 不处理图片 (setq org-hugo-external-file-extensions-allowed-for-copying nil)) ox-hugo-快捷键 # 使用ox-hugo导出博客 - C-c h s 导出所属子树 C-c h a 导出文件内所有子树 "}),e.add({id:150,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E4%BD%BF%E7%94%A8eqs%E5%AF%BB%E6%89%BE%E5%BC%B9%E8%8D%AF%E8%A1%A5%E7%BB%99/",title:"使用EQS寻找弹药补给",description:"说明 # AI / EQS / Find Ammo Pickup 寻找弹药补给的EQS: EQS_FindAmmoPickup 判断是否需要领取弹药补给的Decorator类名STUNeedAmmoDecorator 指定武器类型, 自然弹药不是无限模式, 而这里暂时设置为当弹药耗尽才去领取补给 要求武器类型和弹药补给类型一致 可以参考上节当作练习, 再和给出的答案进行比较 创建EQS资产并测试 # 预备工作 # 设置弹药补给材质为黑色 双击打开 Content/Pickups/BP_STUAmmoPickup 内容浏览器选中 Content/Materials/M_BaseColor 应用材质 拖动复制弹药补给为3个 确保发射器的弹药不是无限模式 BP_STULauncherWeapon \u0026gt; Default Ammo \u0026gt; Infinite , 取消勾选 创建EQS资产, 命名为EQS_FindAmmoPickup # Content/AI/EQS 目录下 可以使用Ctrl-W对EQS_FindHealthPickup进行拷贝, 并修改筛选Actor类型 设置EQS_TestPawn应用EQS_FindAmmoPickup, 查看 # Details \u0026gt; EQS \u0026gt; Query Template , 选择EQS_FindAmmoPickup 添加生成器: 设置补给类型 # Generators \u0026gt; Actors Of Class - Searched Actor Class 指定Actor类型 STUAmmoPickup Search Radius 搜索半径 1500 为生成器添加限制条件: 视线可见 # Add Test \u0026gt; Trace 要求无阻挡 - Filter \u0026gt; Bool Match 取消勾选 为生成器添加限制条件: 距离最近 # Add Test \u0026gt; Distance - Filter \u0026gt; Filter Type Minimum Filter \u0026gt; Float Value Min 0 Score \u0026gt; Scoring Factor -1 距离越近, 权重越大 为生成器添加限制条件: 存在可到达路径 # Add Test \u0026gt; Path Finding 在行为树中使用EQS资产 # 暂时停止当前逻辑 添加节点: Selector NPC寻找弹药补给, 或等待 添加节点: Wait 设置时长为2s 添加序列 为序列添加任务: RunEQSQuery 设置EQS Details \u0026gt; EQS \u0026gt; EQSRequest \u0026gt; Query Template , 设置为EQS_FindAmmoPickup Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 设置为AimLocation 为序列添加任务: MoveTo Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 设置为AimLocation 查看 # 按下 F8 或者点击 Eject 拖动距离NPC最近的弹药补给: NPC寻找并去到此时距离最近的弹药补给位置 点击 Pause simulation , 将所有弹药补给移动到墙后, 点击 Resume play-in-editor session 序列停止, NPC循环执行Wait任务 实现STUNeedAmmoDecorator # 创建C++类 # - 基类 BTDecorator 名称 STUNeedAmmoDecorator 路径 AI/Decorators 属性 Public 武器组件添加接口: 指定类型武器弹药是否为空 # 课程中只要检测到弹药不是满的, 就会去领取弹药补给; 为此, 将ASTUBaseWeapon::IsAmmoFull从protected移动到public public ShootThemUp: Components/STUWeaponComponent.",content:"说明 # AI / EQS / Find Ammo Pickup 寻找弹药补给的EQS: EQS_FindAmmoPickup 判断是否需要领取弹药补给的Decorator类名STUNeedAmmoDecorator 指定武器类型, 自然弹药不是无限模式, 而这里暂时设置为当弹药耗尽才去领取补给 要求武器类型和弹药补给类型一致 可以参考上节当作练习, 再和给出的答案进行比较 创建EQS资产并测试 # 预备工作 # 设置弹药补给材质为黑色 双击打开 Content/Pickups/BP_STUAmmoPickup 内容浏览器选中 Content/Materials/M_BaseColor 应用材质 拖动复制弹药补给为3个 确保发射器的弹药不是无限模式 BP_STULauncherWeapon \u0026gt; Default Ammo \u0026gt; Infinite , 取消勾选 创建EQS资产, 命名为EQS_FindAmmoPickup # Content/AI/EQS 目录下 可以使用Ctrl-W对EQS_FindHealthPickup进行拷贝, 并修改筛选Actor类型 设置EQS_TestPawn应用EQS_FindAmmoPickup, 查看 # Details \u0026gt; EQS \u0026gt; Query Template , 选择EQS_FindAmmoPickup 添加生成器: 设置补给类型 # Generators \u0026gt; Actors Of Class - Searched Actor Class 指定Actor类型 STUAmmoPickup Search Radius 搜索半径 1500 为生成器添加限制条件: 视线可见 # Add Test \u0026gt; Trace 要求无阻挡 - Filter \u0026gt; Bool Match 取消勾选 为生成器添加限制条件: 距离最近 # Add Test \u0026gt; Distance - Filter \u0026gt; Filter Type Minimum Filter \u0026gt; Float Value Min 0 Score \u0026gt; Scoring Factor -1 距离越近, 权重越大 为生成器添加限制条件: 存在可到达路径 # Add Test \u0026gt; Path Finding 在行为树中使用EQS资产 # 暂时停止当前逻辑 添加节点: Selector NPC寻找弹药补给, 或等待 添加节点: Wait 设置时长为2s 添加序列 为序列添加任务: RunEQSQuery 设置EQS Details \u0026gt; EQS \u0026gt; EQSRequest \u0026gt; Query Template , 设置为EQS_FindAmmoPickup Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 设置为AimLocation 为序列添加任务: MoveTo Details \u0026gt; Blackboard \u0026gt; Blackboard Key , 设置为AimLocation 查看 # 按下 F8 或者点击 Eject 拖动距离NPC最近的弹药补给: NPC寻找并去到此时距离最近的弹药补给位置 点击 Pause simulation , 将所有弹药补给移动到墙后, 点击 Resume play-in-editor session 序列停止, NPC循环执行Wait任务 实现STUNeedAmmoDecorator # 创建C++类 # - 基类 BTDecorator 名称 STUNeedAmmoDecorator 路径 AI/Decorators 属性 Public 武器组件添加接口: 指定类型武器弹药是否为空 # 课程中只要检测到弹药不是满的, 就会去领取弹药补给; 为此, 将ASTUBaseWeapon::IsAmmoFull从protected移动到public public ShootThemUp: Components/STUWeaponComponent.h bool IsAmmoEmpty(TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponType) const; ShootThemUp: Components/STUWeaponComponent.cpp bool USTUWeaponComponent::IsAmmoEmpty(TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponType) const { for (const auto Weapon : Weapons) { if (Weapon \u0026amp;\u0026amp; Weapon-\u0026gt;IsA(WeaponType)) { return Weapon-\u0026gt;IsAmmoEmpty(); } } return false; } 添加构造函数 # public ShootThemUp: AI/Decorators/STUNeedAmmoDecorator.h USTUNeedAmmoDecorator(); ShootThemUp: AI/Decorators/STUNeedAmmoDecorator.cpp USTUNeedAmmoDecorator::USTUNeedAmmoDecorator() { NodeName = \u0026quot;Need Ammo\u0026quot;; } 添加属性: 设置武器类型 # protected ShootThemUp: AI/Decorators/STUNeedAmmoDecorator.h class ASTUBaseWeapon; UPROPERTY(EditAnywhere, BlueprintReadWrite) TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponType; 覆写条件 # protected ShootThemUp: AI/Decorators/STUNeedAmmoDecorator.h virtual bool CalculateRawConditionValue(UBehaviorTreeComponent\u0026amp; OwnerComp, uint8* NodeMemory) const override; 参考拾取弹药逻辑: 要求游戏角色存活 ShootThemUp: Pickups/STUAmmoPickup.cpp GivePickupTo ShootThemUp: AI/Decorators/STUNeedAmmoDecorator.cpp #include \u0026quot;Weapon/STUBaseWeapon.h\u0026quot; #include \u0026quot;AIController.h\u0026quot; #include \u0026quot;STUUtils.h\u0026quot; #include \u0026quot;Components/STUHealthComponent.h\u0026quot; #include \u0026quot;Components/STUWeaponComponent.h\u0026quot; bool USTUNeedAmmoDecorator::CalculateRawConditionValue(UBehaviorTreeComponent\u0026amp; OwnerComp, uint8* NodeMemory) const { const auto Controller = OwnerComp.GetAIOwner(); if (!Controller) return false; const auto HealthComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUHealthComponent\u0026gt;(Controller-\u0026gt;GetPawn()); if (!HealthComponent || HealthComponent-\u0026gt;IsDead()) return false; const auto WeaponComponent = STUUtils::GetSTUPlayerComponent\u0026lt;USTUWeaponComponent\u0026gt;(Controller-\u0026gt;GetPawn()); if (!WeaponComponent) return false; return WeaponComponent-\u0026gt;IsAmmoEmpty(WeaponType); } 使用STUNeedAmmoDecorator # BT_STUCharacter 为Sequence添加Decorator 设置STUHealthPercentDecorator - Observer aborts Self Weapon Type BP_STULauncherWeapon 调整行为树 # 由于弹药初始不为空, 需要射击逻辑 将本节新建序列移动到拾取生命补给逻辑之后: 优先级其次 恢复行为树框架 确保射击服务有目标 暂时不更换武器 步枪伤害设为0 BP_STURifleWeapon \u0026gt; Damage Amount 可以在拾取生命补给和拾取弹药补给移动之前添加Wait任务, 用来判断NPC发现补给情况 恢复设置 # 更换武器 弹药补给材质 "}),e.add({id:151,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E6%A6%B4%E5%BC%B9%E7%B1%BB%E9%80%A0%E6%88%90%E4%BC%A4%E5%AE%B3/",title:"榴弹类造成伤害",description:"说明 # 榴弹发生碰撞时对爆炸半径内Actor造成伤害 可以在榴弹发射器中定义伤害相关参数, 如ShotDirection那样对榴弹进行设置; 选择直接在榴弹类中定义 概览 # 重构武器 注册碰撞委托, 在处理函数中对伤害半径内Actor造成伤害 重构武器 # 可配置参数的蓝图属性为EditDefaultsOnly # ShootThemUp: Weapon/STUBaseWeapon.h VisiableAnywhere -\u0026gt; EditDefaultsOnly - DamageAmount TraceMaxDistance MuzzleSocketName ShootThemUp: Weapon/STURifleWeapon.h VisiableAnywhere -\u0026gt; EditDefaultsOnly - TimeBetweenShots BulletSpread 组件在原型和实例中均可见 # VisibleDefaultsOnly -\u0026gt; VisibleAnywhere ShootThemUp: Weapon/STUProjectile.h - CollisionComponent MovementComponent ASTUBaseWeapon::MakeDamage是STURifleWeapon的专属逻辑 # 将ASTUBaseWeapon::MakeDamage移动到Rifle 移动数据成员 ShootThemUp: Weapon/STUBaseWeapon.h -\u0026gt; ShootThemUp: Weapon/STURifleWeapon.h UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) float DamageAmount = 10.0f; 移动函数声明 ShootThemUp: Weapon/STUBaseWeapon.h -\u0026gt; ShootThemUp: Weapon/STURifleWeapon.h protected void MakeDamage(const FHitResult\u0026amp; HitResult); 移动函数定义 ShootThemUp: Weapon/STUBaseWeapon.",content:"说明 # 榴弹发生碰撞时对爆炸半径内Actor造成伤害 可以在榴弹发射器中定义伤害相关参数, 如ShotDirection那样对榴弹进行设置; 选择直接在榴弹类中定义 概览 # 重构武器 注册碰撞委托, 在处理函数中对伤害半径内Actor造成伤害 重构武器 # 可配置参数的蓝图属性为EditDefaultsOnly # ShootThemUp: Weapon/STUBaseWeapon.h VisiableAnywhere -\u0026gt; EditDefaultsOnly - DamageAmount TraceMaxDistance MuzzleSocketName ShootThemUp: Weapon/STURifleWeapon.h VisiableAnywhere -\u0026gt; EditDefaultsOnly - TimeBetweenShots BulletSpread 组件在原型和实例中均可见 # VisibleDefaultsOnly -\u0026gt; VisibleAnywhere ShootThemUp: Weapon/STUProjectile.h - CollisionComponent MovementComponent ASTUBaseWeapon::MakeDamage是STURifleWeapon的专属逻辑 # 将ASTUBaseWeapon::MakeDamage移动到Rifle 移动数据成员 ShootThemUp: Weapon/STUBaseWeapon.h -\u0026gt; ShootThemUp: Weapon/STURifleWeapon.h UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) float DamageAmount = 10.0f; 移动函数声明 ShootThemUp: Weapon/STUBaseWeapon.h -\u0026gt; ShootThemUp: Weapon/STURifleWeapon.h protected void MakeDamage(const FHitResult\u0026amp; HitResult); 移动函数定义 ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::MakeDamage(const FHitResult \u0026amp;HitResult) { const auto DamagedActor = HitResult.GetActor(); if (!DamagedActor) return; DamagedActor-\u0026gt;TakeDamage(DamageAmount, FDamageEvent(), GetPlayerController(), this); } ShootThemUp: Weapon/STURifleWeapon.cpp #include \u0026quot;GameFramework/PlayerController.h\u0026quot; // TakeDamage的参数是AController void ASTURifleWeapon::MakeDamage(const FHitResult \u0026amp;HitResult) { const auto DamagedActor = HitResult.GetActor(); if (!DamagedActor) return; DamagedActor-\u0026gt;TakeDamage(DamageAmount, FDamageEvent(), GetPlayerController(), this); } 将榴弹延时销毁逻辑从榴弹发射器类移动到榴弹类, 并添加参数 # 添加数据成员 protected ShootThemUp: Weapon/STUProjectile.h UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) float LifeSeconds = 5.0f; 在BeginPlay中销毁榴弹 ShootThemUp: Weapon/STUProjectile.cpp SetLifeSpan(LifeSeconds); 屏蔽榴弹发射器中的销毁逻辑 ShootThemUp: Weapon/STULauncherWeapon.cpp 榴弹发生碰撞时, 对半径内Actor造成伤害 # 注册碰撞委托, 调用处理函数 处理函数中, 绘制爆炸半径, 并对半径内Actor造成伤害, 参照STUDevDamageActor ShootThemUp: Dev/STUDevDamageActor.cpp 注册碰撞委托 # 给出处理函数声明, 根据委托定义 # 委托定义 UE_5.1/Engine/Source/Runtime/Engine/Classes/Components/PrimitiveComponent.h 184 DECLARE_DYNAMIC_MULTICAST_SPARSE_DELEGATE_FiveParams( FComponentHitSignature, UPrimitiveComponent, OnComponentHit, UPrimitiveComponent*, HitComponent, AActor*, OtherActor, UPrimitiveComponent*, OtherComp, FVector, NormalImpulse, const FHitResult\u0026amp;, Hit ); 处理函数声明 private ShootThemUp: Weapon/STUProjectile.h UFUNCTION() void OnProjectileHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult\u0026amp; Hit); 给出空定义 ShootThemUp: Weapon/STUProjectile.cpp void ASTUProjectile::OnProjectileHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult\u0026amp; Hit) {} 注册委托 # 委托成员 UE_5.1/Engine/Source/Runtime/Engine/Classes/Components/PrimitiveComponent.h 1189 // //	Event called when a component hits (or is hit by) something solid. This could happen due to things like Character movement, using Set Location with 'sweep' enabled, or physics simulation. //	For events when objects overlap (e.g. walking into a trigger) see the 'Overlap' event. // //	@note For collisions during physics simulation to generate hit events, 'Simulation Generates Hit Events' must be enabled for this component. //	@note When receiving a hit from another object's movement, the directions of 'Hit.Normal' and 'Hit.ImpactNormal' //	will be adjusted to indicate force from the other object against this object. //	@note NormalImpulse will be filled in for physics-simulating bodies, but will be zero for swept-component blocking collisions. // UPROPERTY(BlueprintAssignable, Category=\u0026quot;Collision\u0026quot;) FComponentHitSignature OnComponentHit; 注册委托 ShootThemUp: Weapon/STUProjectile.cpp // BeginPlay check(CollisionComponent); CollisionComponent-\u0026gt;OnComponentHit.AddDynamic(this, \u0026amp;ASTUProjectile::OnProjectileHit); 为榴弹设置上级 # 动态生成榴弹对象时, 设置上级为游戏角色 不对发射榴弹的游戏角色造成伤害 不与发射榴弹的游戏角色发生碰撞 ShootThemUp: Weapon/STULauncherWeapon.cpp Projectile-\u0026gt;SetOwner(GetOwner()); 设置碰撞组件 # ShootThemUp: Weapon/STUProjectile.cpp 仅在计算轨迹时发生碰撞 // Constructor CollisionComponent-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly); 和所有通道发生碰撞 // Constructor CollisionComponent-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block); 不与发射榴弹的游戏角色发生碰撞 // BeginPlay CollisionComponent-\u0026gt;IgnoreActorWhenMoving(GetOwner(), true); 实现处理函数: 对爆炸半径内Actor造成伤害 # 伤害参数 # - 伤害半径 DamageRadius 伤害数值 DamageAmount 伤害计算模型 DoFullDamage 伤害来源 忽略Actor列表 添加数据成员, 存放伤害参数 # protected ShootThemUp: Weapon/STUProjectile.h UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) float DamageRadius = 200.0f; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) float DamageAmount = 50.0f; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) bool DoFullDamage = false; 实现函数, 返回游戏角色控制器 # ShootThemUp: Weapon/STUProjectile.h private AController* GetController() const; ShootThemUp: Weapon/STUProjectile.cpp AController* ASTUProjectile::GetController() const { const auto Pawn = Cast\u0026lt;APawn\u0026gt;(GetOwner()); return Pawn ? Pawn-\u0026gt;GetController() : nullptr; } 实现处理函数 # ShootThemUp: Weapon/STUProjectile.cpp 发生碰撞时, 榴弹不再运动 通过将运动速度设为0实现; 联想到游戏角色死亡后调用DisableMovement MovementComponent-\u0026gt;StopMovementImmediately(); 绘制爆炸范围 #include \u0026quot;DrawDebugHelpers.h\u0026quot; if (!GetWorld()) return; DrawDebugSphere(GetWorld(), GetActorLocation(), DamageRadius, 24, FColor::Red, false, 5.0f); 对爆炸半径内Actor造成伤害 排除榴弹上级 #include \u0026quot;Kismet/GameplayStatics.h\u0026quot; #include \u0026quot;GameFramework/DamageType.h\u0026quot; UGameplayStatics::ApplyRadialDamage(GetWorld(), DamageAmount, GetActorLocation(), DamageRadius, UDamageType::StaticClass(), { GetOwner() }, this, GetController(), DoFullDamage); 销毁榴弹对象 Destroy(); 查看 # 无法伤害自己: 打地上 根据到球心的距离造成伤害 对处在爆炸半径内的游戏角色, 同时造成伤害 "}),e.add({id:152,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/evil/",title:"evil",description:"在Emacs使用Vim命令编辑文本 便签 # Manual GitHub 安装依赖 # - goto-chg GitHub undo-tree Elpa undo-fu Melpa ;; (use-package goto-chg ;; :ensure t) ;; (use-package undo-tree ;; :ensure t) ;; (use-package undo-fu ;; :ensure t) evil-安装 # ;; (use-package evil ;; :ensure t ;; :config (progn (evil-mode t) ;; (setq evil-default-state 'emacs) ;; ;; (evil-set-initial-state evil-mode 'emacs) ;; (setq evil-emacs-state-cursor '(\u0026quot;grey\u0026quot; box)) ;; C-z ;; (setq evil-normal-state-cursor '(\u0026quot;green\u0026quot; box)) ;; esc ;; (setq evil-insert-state-cursor '(\u0026quot;red\u0026quot; box)) ;; i ;; (setq evil-replace-state-cursor '(\u0026quot;red\u0026quot; hollow)) ;; r ;; (setq evil-visual-state-cursor '(\u0026quot;yellow\u0026quot; box)))) 相关插件 # - evil-tabs tabs标签 evil-leader 定义evil-mode下使用的快捷键 evil-tabs # ;; (use-package evil-tabs ;; :ensure t ;; :config (global-evil-tabs-mode t)) evil-leader # GitHub ;; (use-package evil-leader ;; :ensure t ;; :init (progn ;; (global-evil-leader-mode t) ;; (evil-leader/set-leader \u0026quot;\u0026lt;SPC\u0026gt;\u0026quot;) ;; (evil-leader/set-key ;; \u0026quot;e\u0026quot; 'find-file))) ",content:"在Emacs使用Vim命令编辑文本 便签 # Manual GitHub 安装依赖 # - goto-chg GitHub undo-tree Elpa undo-fu Melpa ;; (use-package goto-chg ;; :ensure t) ;; (use-package undo-tree ;; :ensure t) ;; (use-package undo-fu ;; :ensure t) evil-安装 # ;; (use-package evil ;; :ensure t ;; :config (progn (evil-mode t) ;; (setq evil-default-state 'emacs) ;; ;; (evil-set-initial-state evil-mode 'emacs) ;; (setq evil-emacs-state-cursor '(\u0026quot;grey\u0026quot; box)) ;; C-z ;; (setq evil-normal-state-cursor '(\u0026quot;green\u0026quot; box)) ;; esc ;; (setq evil-insert-state-cursor '(\u0026quot;red\u0026quot; box)) ;; i ;; (setq evil-replace-state-cursor '(\u0026quot;red\u0026quot; hollow)) ;; r ;; (setq evil-visual-state-cursor '(\u0026quot;yellow\u0026quot; box)))) 相关插件 # - evil-tabs tabs标签 evil-leader 定义evil-mode下使用的快捷键 evil-tabs # ;; (use-package evil-tabs ;; :ensure t ;; :config (global-evil-tabs-mode t)) evil-leader # GitHub ;; (use-package evil-leader ;; :ensure t ;; :init (progn ;; (global-evil-leader-mode t) ;; (evil-leader/set-leader \u0026quot;\u0026lt;SPC\u0026gt;\u0026quot;) ;; (evil-leader/set-key ;; \u0026quot;e\u0026quot; 'find-file))) "}),e.add({id:153,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%88%87%E6%8D%A2%E6%AD%A6%E5%99%A8/",title:"切换武器",description:"概览 # 为HeroTPP添加Socket, 在背后挂载未使用武器 绑定键位, 按下Tab或滚动鼠标时切换武器 游戏角色死亡后, 销毁武器 处理Rifle开火定时器 为骨骼网格体添加Socket # 虚幻编辑器 打开Content/ExternalContent/Animation/Characters/HeroTPP/HeroTPP 选择骨骼b_Spine1, 添加Socket 在细节面板设置Socket - Socket Name ArmorySocket Relative Location (-9, -26, -23) Relative Rotation (-10, 70, -29) 为Socket添加预览资产, 选择Launcher 武器未使用时背在背上 绑定切换武器键位 # 项目设置 \u0026gt; Engine \u0026gt; Input \u0026gt; Action Mappings - 函数描述 NextWeapon 键位 Tab / MouseWheelUp / MouseWheelDown 不论滚轮方向, 切换到下一个武器 搭建框架 # 切换逻辑在STUWeaponComponent中 添加空的回调函数 # ShootThemUp: Components/STUWeaponComponent.h public void NextWeapon(); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::NextWeapon() { } 绑定回调函数和函数描述 # ShootThemUp: Player/STUBaseCharacter.",content:"概览 # 为HeroTPP添加Socket, 在背后挂载未使用武器 绑定键位, 按下Tab或滚动鼠标时切换武器 游戏角色死亡后, 销毁武器 处理Rifle开火定时器 为骨骼网格体添加Socket # 虚幻编辑器 打开Content/ExternalContent/Animation/Characters/HeroTPP/HeroTPP 选择骨骼b_Spine1, 添加Socket 在细节面板设置Socket - Socket Name ArmorySocket Relative Location (-9, -26, -23) Relative Rotation (-10, 70, -29) 为Socket添加预览资产, 选择Launcher 武器未使用时背在背上 绑定切换武器键位 # 项目设置 \u0026gt; Engine \u0026gt; Input \u0026gt; Action Mappings - 函数描述 NextWeapon 键位 Tab / MouseWheelUp / MouseWheelDown 不论滚轮方向, 切换到下一个武器 搭建框架 # 切换逻辑在STUWeaponComponent中 添加空的回调函数 # ShootThemUp: Components/STUWeaponComponent.h public void NextWeapon(); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::NextWeapon() { } 绑定回调函数和函数描述 # ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;NextWeapon\u0026quot;, IE_Pressed, WeaponComponent, \u0026amp;USTUWeaponComponent::NextWeapon); 调整当前逻辑 # 修改Socket名 # 现在附加武器的Socket有两个, 原先的Socket为装载武器Socket ShootThemUp: Components/STUWeaponComponent.h WeaponAttachPointName -\u0026gt; WeaponEquipSocketName ShootThemUp: Components/STUWeaponComponent.cpp // SpawnWeapon WeaponAttachPointName -\u0026gt; WeaponEquipSocketName 添加接口: 将武器挂载到指定Socket # 切换武器时使用 定义 # ShootThemUp: Components/STUWeaponComponent.h private void AttachWeaponToSocket(ASTUBaseWeapon *Weapon, USceneComponent *SceneComponent, const FName \u0026amp;SocketName); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::AttachWeaponToSocket(ASTUBaseWeapon *Weapon, USceneComponent *SceneComponent, const FName \u0026amp;SocketName) { if (!Weapon || !SceneComponent) return; FAttachmentTransformRules AttachmentRules(EAttachmentRule::SnapToTarget, false); Weapon-\u0026gt;AttachToComponent(SceneComponent, AttachmentRules, SocketName); } 调用 # ShootThemUp: Components/STUWeaponComponent.cpp // SpawnWeapon AttachWeaponToSocket(CurrentWeapon, Character-\u0026gt;GetMesh(), WeaponEquipSocketName); 武器数组 # 武器组件管理武器数组 将武器类属性改为武器类属性数组 # protected ShootThemUp: Components/STUWeaponComponent.h UPROPERTY(EditDefaultsOnly) TArray\u0026lt;TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt;\u0026gt; WeaponClasses; 添加武器数组 # private ShootThemUp: Components/STUWeaponComponent.h UPROPERTY() TArray\u0026lt;ASTUBaseWeapon*\u0026gt; Weapons; 添加数据成员: 保存挂载点名称 # protected ShootThemUp: Components/STUWeaponComponent.h UPROPERTY(EditDefaultsOnly) FName WeaponArmorySocketName = \u0026quot;ArmorySocket\u0026quot;; 动态生成武器时, 生成Rifle和Launcher, 先全部挂载到背上 # SpawnWeapons定义 # ShootThemUp: Components/STUWeaponComponent.h SpawnWeapon -\u0026gt; SpawnWeapons ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::SpawnWeapons() { if (!GetWorld()) return; ACharacter *Character = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Character) return; for (auto WeaponClass : WeaponClasses) { auto Weapon = GetWorld()-\u0026gt;SpawnActor\u0026lt;ASTUBaseWeapon\u0026gt;(WeaponClass); if (!Weapon) return; Weapons.Add(Weapon); Weapon-\u0026gt;SetOwner(Character); AttachWeaponToSocket(Weapon, Character-\u0026gt;GetMesh(), WeaponArmorySocketName); } } 在BeginPlay中调用 # ShootThemUp: Components/STUWeaponComponent.cpp 装载武器 # 添加数据成员: 保存当前武器标号 # private 和CurrentWeapon相对应 ShootThemUp: Components/STUWeaponComponent.h int32 CurrentWeaponIndex = 0; EquipWeapon定义 # ShootThemUp: Components/STUWeaponComponent.h private void EquipWeapon(int32 WeaponIndex); ShootThemUp: Components/STUWeaponComponent.cpp 设置CurrentWeapon指针, 将武器挂载到WeaponEquipSocketName void USTUWeaponComponent::EquipWeapon(int32 WeaponIndex) { ACharacter *Character = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Character) return; if (CurrentWeapon) { AttachWeaponToSocket(CurrentWeapon, Character-\u0026gt;GetMesh(), WeaponArmorySocketName); } CurrentWeapon = Weapons[WeaponIndex]; AttachWeaponToSocket(CurrentWeapon, Character-\u0026gt;GetMesh(), WeaponEquipSocketName); } 动态生成武器后, 需装载武器 # ShootThemUp: Components/STUWeaponComponent.cpp // BeginPlay CurrentWeaponIndex = 0; EquipWeapon(CurrentWeaponIndex); 实现切换武器回调函数 # ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::NextWeapon() { CurrentWeaponIndex = (1 + CurrentWeaponIndex) % Weapons.Num(); EquipWeapon(CurrentWeaponIndex); } 查看 # 设置游戏角色武器类属性数组 武器切换和使用正常 游戏角色死亡时, 销毁武器 # 对游戏角色调用Destroy, 会对游戏角色调用EndPlay 先调用组件的EndPlay, 再对游戏角色调用EndPlay 覆写EndPlay, 销毁武器Actor ShootThemUp: Components/STUWeaponComponent.h protected virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override; ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::EndPlay(const EEndPlayReason::Type EndPlayReason) { CurrentWeapon = nullptr; for (auto Weapon : Weapons) { // 卸载Actor的网格体, 与AttachToComponent相反 Weapon-\u0026gt;DetachFromActor(FDetachmentTransformRules::KeepWorldTransform); // 此处是静态结构体, 不是枚举成员 // 销毁Actor Weapon-\u0026gt;Destroy(); } Weapons.Empty(); // 清空数组 // 也可以关闭武器的物理碰撞, 将武器保留在关卡, 几秒钟后销毁武器 Super::EndPlay(EndPlayReason); } 处理Rifle开火定时器 # 切换武器时, 关闭定时器 # ShootThemUp: Components/STUWeaponComponent.cpp // EquipWeapon if (CurrentWeapon) { // 其他处理 CurrentWeapon-\u0026gt;FireStop(); } 游戏角色死亡后, 关闭定时器 # ShootThemUp: Player/STUBaseCharacter.cpp // OnDeath WeaponComponent-\u0026gt;FireStop(); "}),e.add({id:154,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/rime/",title:"rime",description:"Emacs中使用的中文输入法, 区分快捷键和中文输入 便签 # GitHub 依赖 # 支持动态模块的Emacs # Emacs Rime依赖动态模块 重新安装Emacs, 选择emacs-plus Rime应用程序 # Rime librime # macOS 下载编译好的librime # # curl -L -O https://github.com/rime/librime/releases/download/1.7.1/rime-1.7.1-osx.zip # unzip rime-1.7.1-osx.zip -d ~/.emacs.d/librime # rm -rf rime-1.7.1-osx.zip 配置 # librime路径 # ;; (setq my/rime-librime-root \u0026quot;~/.emacs.d/librime/dist\u0026quot;) 用户数据路径 # ;; (setq my/rime-user-data-dir \u0026quot;path/to/rime/user/data\u0026quot;) rime-安装 # (use-package rime :ensure t :custom (rime-librime-root my/rime-librime-root) (default-input-method \u0026quot;rime\u0026quot;) (rime-user-data-dir my/rime-user-data-dir) (rime-show-candidate 'posframe) :bind (:map rime-mode-map (\u0026quot;C-`\u0026quot; . 'rime-send-keybinding))) rime-快捷键 # - 配置简繁、全半角 C-` Rime输入法切换 C-\\ ",content:"Emacs中使用的中文输入法, 区分快捷键和中文输入 便签 # GitHub 依赖 # 支持动态模块的Emacs # Emacs Rime依赖动态模块 重新安装Emacs, 选择emacs-plus Rime应用程序 # Rime librime # macOS 下载编译好的librime # # curl -L -O https://github.com/rime/librime/releases/download/1.7.1/rime-1.7.1-osx.zip # unzip rime-1.7.1-osx.zip -d ~/.emacs.d/librime # rm -rf rime-1.7.1-osx.zip 配置 # librime路径 # ;; (setq my/rime-librime-root \u0026quot;~/.emacs.d/librime/dist\u0026quot;) 用户数据路径 # ;; (setq my/rime-user-data-dir \u0026quot;path/to/rime/user/data\u0026quot;) rime-安装 # (use-package rime :ensure t :custom (rime-librime-root my/rime-librime-root) (default-input-method \u0026quot;rime\u0026quot;) (rime-user-data-dir my/rime-user-data-dir) (rime-show-candidate 'posframe) :bind (:map rime-mode-map (\u0026quot;C-`\u0026quot; . 'rime-send-keybinding))) rime-快捷键 # - 配置简繁、全半角 C-` Rime输入法切换 C-\\ "}),e.add({id:155,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/%E6%89%93%E5%8C%85/",title:"打包",description:"移除工作 # 移除榴弹爆炸模拟 从场景中移除 DamageSphere-Blue 和 DamageSphere-Red 移除楼梯 从场景中移除 step1-4 移除EQS_TestPawn 移除贴花测试 DecalActor 移除位置指示 Actor 和 Actor2 移除碰撞测试的立方体和球体 Cube 和 Sphere 移除物理材质测试立方体 Cube2 移除粒子系统 NS_BaseImpact 和 NewNiagaraSystem 移除静态网格体 StaticMeshActor 整理工作 # 使补给均匀分布: 各4个 设置NPC: 3个 设置 # NPC默认使用步枪 BP_STUAICharacter \u0026gt; Details \u0026gt; Weapon Data , 调整武器顺序 步枪伤害 BP_STURifleWeapon \u0026gt; Damage Amount, 设为2 多个NPC时: 调整行为树 # BT_STUCharacter 出现复选框, 根据控制器选择要观察NPC 打包 # Platforms \u0026gt; Mac \u0026gt; Package Project ",content:"移除工作 # 移除榴弹爆炸模拟 从场景中移除 DamageSphere-Blue 和 DamageSphere-Red 移除楼梯 从场景中移除 step1-4 移除EQS_TestPawn 移除贴花测试 DecalActor 移除位置指示 Actor 和 Actor2 移除碰撞测试的立方体和球体 Cube 和 Sphere 移除物理材质测试立方体 Cube2 移除粒子系统 NS_BaseImpact 和 NewNiagaraSystem 移除静态网格体 StaticMeshActor 整理工作 # 使补给均匀分布: 各4个 设置NPC: 3个 设置 # NPC默认使用步枪 BP_STUAICharacter \u0026gt; Details \u0026gt; Weapon Data , 调整武器顺序 步枪伤害 BP_STURifleWeapon \u0026gt; Damage Amount, 设为2 多个NPC时: 调整行为树 # BT_STUCharacter 出现复选框, 根据控制器选择要观察NPC 打包 # Platforms \u0026gt; Mac \u0026gt; Package Project "}),e.add({id:156,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E8%A3%85%E5%A4%87%E6%AD%A6%E5%99%A8%E5%8A%A8%E7%94%BB/",title:"装备武器动画",description:"说明 # 装备武器时, 播放动画, 使用动画剪辑 AnimMontage 资产实现 播放装备武器动画时, 锁定其他操作, 使用动画提醒 AnimNotify 资产实现 概览 # 使用动画剪辑播放装备武器动画 创建动画剪辑资产 在蓝图中实现Notify 创建UAnimNotify派生类 在C++中实现Notify 在委托处理函数中判断骨骼网格体所属 使用动画剪辑资产播放装备武器动画 # 添加数据成员, 指向装备武器动画剪辑 # protected ShootThemUp: Components/STUWeaponComponent.h class UAnimMontage; UPROPERTY(EditDefaultsOnly) UAnimMontage *EquipAnimMontage; 添加函数, 播放动画剪辑 # 定义 # ShootThemUp: Components/STUWeaponComponent.h private void PlayAnimMontage(UAnimMontage *Animation); ShootThemUp: Components/STUWeaponComponent.cpp #include \u0026quot;Animation/AnimMontage.h\u0026quot; void USTUWeaponComponent::PlayAnimMontage(UAnimMontage *Animation) { ACharacter *Character = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Character) return; Character-\u0026gt;PlayAnimMontage(Animation); } 调用 # ShootThemUp: Components/STUWeaponComponent.cpp // EquipWeapon PlayAnimMontage(EquipAnimMontage); 创建动画剪辑资产 # 虚幻编辑器 选中Content/ExternalContent/Animation/Animations/TTP_Animations/Equip, 右键, 选择 Create AnimMontage 命名为AM_Equip 移动到Content/Player/Animations 打开BP_STUBaseCharacter, 设置EquipAnimMontage为AM_Equip 当前问题 # 频繁快速切换武器, 持续调用PlayAnimMontage, 表现为最后一次才完整播放装备武器动画 播放动画时, 可以射击 引入动画提醒资产, 设想是, 在动画剪辑播放将近结束之前, 锁定其他操作 # 提醒机制 # Notify 在动画剪辑资产的时间线上添加Notify事件; 动画提醒的实现基于把事件和特定帧绑定在一起 蓝图 # 在动画蓝图 \u0026gt; EventGraph中对事件进行处理 C++ # Decorator 覆写Notify函数, 添加处理 查看动画资产 # 双击打开AM_Equip, 点击暂停 移动滑杆, 可以查看时间线上对应的帧 时间线右侧有Notifies栏 Notifies栏 # 有Track按钮, 可以添加其他轨道, 用于成组的事件 Grouping Events 在蓝图中测试提醒机制 # 添加Notify事件 # 双击打开AM_Equip 将滑杆拖动到动画较后位置 在轨道1右键, 选择 Add Notify \u0026gt; New Notify 命名为 EquipFinished 查看 在动画蓝图中处理事件 # 打开ABP_BaseCharacter, 去到EventGraph 在空白处右键, 选择 Add Anim Notify Event \u0026gt; Event AnimNotify_EquipFinished 执行字符串打印 切换武器时, 屏幕有输出 在C++中实现Notify # 创建AnimNotify的派生类, 作为委托服务的服务端 武器组件注册委托服务, 搭建好框架, 之后再实现播放装备武器动画的锁定和解锁逻辑 在装备武器动画剪辑中添加AnimNotify派生类事件 新建AnimNotify的派生类 # 虚幻编辑器 - 基类 AnimNotify 上级文件夹 Animations 访问属性 Public 名称 STUEquipFinishedAnimNotify 添加头文件搜索路径 # ShootThemUp: ShootThemUp.",content:`说明 # 装备武器时, 播放动画, 使用动画剪辑 AnimMontage 资产实现 播放装备武器动画时, 锁定其他操作, 使用动画提醒 AnimNotify 资产实现 概览 # 使用动画剪辑播放装备武器动画 创建动画剪辑资产 在蓝图中实现Notify 创建UAnimNotify派生类 在C++中实现Notify 在委托处理函数中判断骨骼网格体所属 使用动画剪辑资产播放装备武器动画 # 添加数据成员, 指向装备武器动画剪辑 # protected ShootThemUp: Components/STUWeaponComponent.h class UAnimMontage; UPROPERTY(EditDefaultsOnly) UAnimMontage *EquipAnimMontage; 添加函数, 播放动画剪辑 # 定义 # ShootThemUp: Components/STUWeaponComponent.h private void PlayAnimMontage(UAnimMontage *Animation); ShootThemUp: Components/STUWeaponComponent.cpp #include \u0026quot;Animation/AnimMontage.h\u0026quot; void USTUWeaponComponent::PlayAnimMontage(UAnimMontage *Animation) { ACharacter *Character = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Character) return; Character-\u0026gt;PlayAnimMontage(Animation); } 调用 # ShootThemUp: Components/STUWeaponComponent.cpp // EquipWeapon PlayAnimMontage(EquipAnimMontage); 创建动画剪辑资产 # 虚幻编辑器 选中Content/ExternalContent/Animation/Animations/TTP_Animations/Equip, 右键, 选择 Create AnimMontage 命名为AM_Equip 移动到Content/Player/Animations 打开BP_STUBaseCharacter, 设置EquipAnimMontage为AM_Equip 当前问题 # 频繁快速切换武器, 持续调用PlayAnimMontage, 表现为最后一次才完整播放装备武器动画 播放动画时, 可以射击 引入动画提醒资产, 设想是, 在动画剪辑播放将近结束之前, 锁定其他操作 # 提醒机制 # Notify 在动画剪辑资产的时间线上添加Notify事件; 动画提醒的实现基于把事件和特定帧绑定在一起 蓝图 # 在动画蓝图 \u0026gt; EventGraph中对事件进行处理 C++ # Decorator 覆写Notify函数, 添加处理 查看动画资产 # 双击打开AM_Equip, 点击暂停 移动滑杆, 可以查看时间线上对应的帧 时间线右侧有Notifies栏 Notifies栏 # 有Track按钮, 可以添加其他轨道, 用于成组的事件 Grouping Events 在蓝图中测试提醒机制 # 添加Notify事件 # 双击打开AM_Equip 将滑杆拖动到动画较后位置 在轨道1右键, 选择 Add Notify \u0026gt; New Notify 命名为 EquipFinished 查看 在动画蓝图中处理事件 # 打开ABP_BaseCharacter, 去到EventGraph 在空白处右键, 选择 Add Anim Notify Event \u0026gt; Event AnimNotify_EquipFinished 执行字符串打印 切换武器时, 屏幕有输出 在C++中实现Notify # 创建AnimNotify的派生类, 作为委托服务的服务端 武器组件注册委托服务, 搭建好框架, 之后再实现播放装备武器动画的锁定和解锁逻辑 在装备武器动画剪辑中添加AnimNotify派生类事件 新建AnimNotify的派生类 # 虚幻编辑器 - 基类 AnimNotify 上级文件夹 Animations 访问属性 Public 名称 STUEquipFinishedAnimNotify 添加头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot;, \u0026quot;ShootThemUp/Public/Animations\u0026quot; }); 查看UAnimNotify派生类 # ShootThemUp: Animations/STUEquipFinishedAnimNotify.h 事件发生时, 会调用UAnimNotify::Notify函数 UE_5.1/Engine/Source/Runtime/Engine/Classes/Animation/AnimNotifies/AnimNotify.h 定义委托类型, 使STUEquipFinishedAnimNotify作为服务端 覆写Notify函数, 通知客户端 实现STUEquipFinishedAnimNotify # 定义委托类型, 并添加数据成员 # public ShootThemUp: Animations/STUEquipFinishedAnimNotify.h DECLARE_MULTICAST_DELEGATE(FOnNotifiedSignature); FOnNotifiedSignature OnNotified; 覆写Notify函数, 通知客户端 # ShootThemUp: Animations/STUEquipFinishedAnimNotify.h public virtual void Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference\u0026amp; EventReference) override; ShootThemUp: Animations/STUEquipFinishedAnimNotify.cpp - Decorator 为已存在函数添加额外逻辑 void USTUEquipFinishedAnimNotify::Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference\u0026amp; EventReference) { OnNotified.Broadcast(); Super::Notify(MeshComp, Animation, EventReference); } 武器组件中, 对装备武器事件进行订阅 # 实现处理函数, 事件发生时打印 # 定义日志类型 ShootThemUp: Components/STUWeaponComponent.cpp DEFINE_LOG_CATEGORY_STATIC(LogWeaponComponent, All, All); ShootThemUp: Components/STUWeaponComponent.h private void OnEquipFinished(); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::OnEquipFinished() { UE_LOG(LogWeaponComponent, Display, TEXT(\u0026quot;Equip Finished!\u0026quot;)); } 订阅委托 # 声明
private ShootThemUp: Components/STUWeaponComponent.h void InitAnimations(); 获取AM_Equip中所有的提醒事件
UAnimMontage派生自UAnimCompositeBase, UAnimCompositeBase派生自UAnimSequnceBase UAnimSequnceBase是动画基础类 Base Animation Class UAnimSequnceBase有数据成员Notifies数组, 存放FAnimNotifyEvent FAnimNotifyEvent存放Notify事件信息; 该结构体有一个指向UAnimNotify对象的指针 UAnimSequenceBase还有一个属性AnimNotifyTracks, 即在动画资产Notify一栏添加的Tracks, 只能在开发时访问 if (!EquipAnimMontage) return; const auto NotifyEvents = EquipAnimMontage-\u0026gt;Notifies; 遍历所有事件, 注册STUEquipFinishedAnimNotify
#include \u0026quot;Animations/STUEquipFinishedAnimNotify.h\u0026quot; for (auto NotifyEvent : NotifyEvents) { auto EquipFinishedNotify = Cast\u0026lt;USTUEquipFinishedAnimNotify\u0026gt;(NotifyEvent.Notify); if (EquipFinishedNotify) { EquipFinishedNotify-\u0026gt;OnNotified.AddUObject(this, \u0026amp;USTUWeaponComponent::OnEquipFinished); break; } } 完整实现
ShootThemUp: Components/STUWeaponComponent.cpp #include \u0026quot;Animations/STUEquipFinishedAnimNotify.h\u0026quot; void USTUWeaponComponent::InitAnimations() { if (!EquipAnimMontage) return; const auto NotifyEvents = EquipAnimMontage-\u0026gt;Notifies; for (auto NotifyEvent : NotifyEvents) { auto EquipFinishedNotify = Cast\u0026lt;USTUEquipFinishedAnimNotify\u0026gt;(NotifyEvent.Notify); if (EquipFinishedNotify) { EquipFinishedNotify-\u0026gt;OnNotified.AddUObject(this, \u0026amp;USTUWeaponComponent::OnEquipFinished); break; } } } 在BeginPlay中调用
ShootThemUp: Components/STUWeaponComponent.cpp 在AM_Equip添加动画提醒事件 # 打开AM_Equip 在时间线最后添加Notify: STUEquipFinishedAnimNotify 可在细节面板进行设置: 如修改Notify Color 查看 # 装备武器时, 日志成对打印: 所有的游戏角色均收到通知 武器组件收到通知时, 判断装备武器的骨骼网格体所属 # 修改委托定义, 增加一个参数, 指向骨骼网格体 # ShootThemUp: Animations/STUEquipFinishedAnimNotify.h // DECLARE_MULTICAST_DELEGATE(FOnNotifiedSignature); DECLARE_MULTICAST_DELEGATE_OneParam(FOnNotifiedSignature, USkeletalMeshComponent*); 通知客户端时, 传参骨骼网格体 # ShootThemUp: Animations/STUEquipFinishedAnimNotify.cpp // Notify OnNotified.Broadcast(MeshComp); 修改客户端处理函数声明 # ShootThemUp: Components/STUWeaponComponent.h void OnEquipFinished(USkeletalMeshComponent *MeshComp); 修改客户端处理函数定义, 判断骨骼网格体所属 # ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::OnEquipFinished(USkeletalMeshComponent *MeshComp) { ACharacter *Character = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Character || (Character-\u0026gt;GetMesh() != MeshComp)) return; UE_LOG(LogWeaponComponent, Display, TEXT(\u0026quot;Equip Finished!\u0026quot;)); } 查看 # `}),e.add({id:157,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/treemacs/",title:"treemacs",description:"工作区管理 treemacs-安装 # (use-package treemacs :ensure t :defer t :init (with-eval-after-load 'winum (define-key winum-keymap (kbd \u0026quot;M-0\u0026quot;) #'treemacs-select-window)) :config (progn (with-eval-after-load 'treemacs (define-key treemacs-mode-map [mouse-1] #'treemacs-single-click-expand-action)) ;; 单击打开文件 (setq treemacs-show-hidden-files nil) ;; (setq treemacs-show-cursor -1) ;; (treemacs-resize-icons 15) ) :bind (:map global-map (\u0026quot;M-0\u0026quot; . treemacs-select-window) ;; (\u0026quot;C-x t 1\u0026quot; . treemacs-delete-other-windows) ;; (\u0026quot;C-x t t\u0026quot; . treemacs) ;; (\u0026quot;C-x t d\u0026quot; . treemacs-select-directory) ;; (\u0026quot;C-x t B\u0026quot; . treemacs-bookmark) ;; (\u0026quot;C-x t C-t\u0026quot; .",content:"工作区管理 treemacs-安装 # (use-package treemacs :ensure t :defer t :init (with-eval-after-load 'winum (define-key winum-keymap (kbd \u0026quot;M-0\u0026quot;) #'treemacs-select-window)) :config (progn (with-eval-after-load 'treemacs (define-key treemacs-mode-map [mouse-1] #'treemacs-single-click-expand-action)) ;; 单击打开文件 (setq treemacs-show-hidden-files nil) ;; (setq treemacs-show-cursor -1) ;; (treemacs-resize-icons 15) ) :bind (:map global-map (\u0026quot;M-0\u0026quot; . treemacs-select-window) ;; (\u0026quot;C-x t 1\u0026quot; . treemacs-delete-other-windows) ;; (\u0026quot;C-x t t\u0026quot; . treemacs) ;; (\u0026quot;C-x t d\u0026quot; . treemacs-select-directory) ;; (\u0026quot;C-x t B\u0026quot; . treemacs-bookmark) ;; (\u0026quot;C-x t C-t\u0026quot; . treemacs-find-file) )) treemacs-快捷键 # - 打开文件目录 M-0 "}),e.add({id:158,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E8%A3%85%E5%A4%87%E6%AD%A6%E5%99%A8%E6%A0%87%E5%BF%97%E4%BD%8D/",title:"装备武器标志位",description:"说明 # 添加标志位, 播放装备武器动画时置为true, 播放结束置为false 概览 # 装备武器动画播放结束之前, 不允许切换武器 装备武器动画播放结束之前, 不允许射击 装备武器标志位 # 定义 # private ShootThemUp: Components/STUWeaponComponent.h bool EquipAnimInProgress = false; 设置 # ShootThemUp: Components/STUWeaponComponent.cpp //EquipWeapon EquipAnimInProgress = true; // OnEquipFinished EquipAnimInProgress = false; 添加接口: 允许更换武器 # 定义 # ShootThemUp: Components/STUWeaponComponent.h bool CanEquip() const; ShootThemUp: Components/STUWeaponComponent.cpp bool USTUWeaponComponent::CanFire() const { return (CurrentWeapon \u0026amp;\u0026amp; !EquipAnimInProgress); } 调用 # ShootThemUp: Components/STUWeaponComponent.cpp // NextWeapon if (!CanEquip()) return; 添加接口: 允许射击 # 定义 # ShootThemUp: Components/STUWeaponComponent.",content:"说明 # 添加标志位, 播放装备武器动画时置为true, 播放结束置为false 概览 # 装备武器动画播放结束之前, 不允许切换武器 装备武器动画播放结束之前, 不允许射击 装备武器标志位 # 定义 # private ShootThemUp: Components/STUWeaponComponent.h bool EquipAnimInProgress = false; 设置 # ShootThemUp: Components/STUWeaponComponent.cpp //EquipWeapon EquipAnimInProgress = true; // OnEquipFinished EquipAnimInProgress = false; 添加接口: 允许更换武器 # 定义 # ShootThemUp: Components/STUWeaponComponent.h bool CanEquip() const; ShootThemUp: Components/STUWeaponComponent.cpp bool USTUWeaponComponent::CanFire() const { return (CurrentWeapon \u0026amp;\u0026amp; !EquipAnimInProgress); } 调用 # ShootThemUp: Components/STUWeaponComponent.cpp // NextWeapon if (!CanEquip()) return; 添加接口: 允许射击 # 定义 # ShootThemUp: Components/STUWeaponComponent.h private bool CanFire() const; ShootThemUp: Components/STUWeaponComponent.cpp bool USTUWeaponComponent::CanEquip() const { return !EquipAnimInProgress; } 调用 # ShootThemUp: Components/STUWeaponComponent.cpp // FireStart if (!CanFire()) return; "}),e.add({id:159,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/treemacs-all-the-icons/",title:"treemacs-all-the-icons",description:"设置treemacs图标主题 依赖 # all-the-icons是一个插件, 可以在文本中插入字体图标 treemacs-all-the-icons并不依赖all-the-icons, 但使用all-the-icons提供的字体 all-the-icons # GitHub 字体存放在fonts目录下 treemacs-all-the-icons-安装 # (use-package treemacs-all-the-icons :ensure t :config (treemacs-load-theme \u0026quot;all-the-icons\u0026quot;) ) ",content:"设置treemacs图标主题 依赖 # all-the-icons是一个插件, 可以在文本中插入字体图标 treemacs-all-the-icons并不依赖all-the-icons, 但使用all-the-icons提供的字体 all-the-icons # GitHub 字体存放在fonts目录下 treemacs-all-the-icons-安装 # (use-package treemacs-all-the-icons :ensure t :config (treemacs-load-theme \u0026quot;all-the-icons\u0026quot;) ) "}),e.add({id:160,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E8%A3%85%E5%A4%87%E6%AD%A6%E5%99%A8%E5%8A%A8%E7%94%BB%E5%8F%AA%E5%BD%B1%E5%93%8D%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%BA%AB%E4%BD%93%E4%B8%8A%E9%83%A8%E5%88%86/",title:"装备武器动画只影响游戏角色身体上部分",description:"说明 # 向前移动时更换武器, 动画有卡顿 当前, 四个方向移动 + 跑步动画的输出 \u0026gt; 瞄准偏移 \u0026gt; 左手固定在枪托 \u0026gt; Slot \u0026gt; 动画蓝图输出 卡顿的原因时, 通过Slot拼接动画和动画剪辑时, 动画的姿势被擦除了, 卡顿时, 只有装备武器动画在播放 在动画蓝图使用按骨骼分层混合节点, 混合装备武器动画和状态机输出, 只应用于游戏角色上半部分 概览 # 在动画蓝图添加游戏角色身体上半部分Slot, 并设置装备武器动画剪辑亦属于该Slot 在动画蓝图中将状态机输出缓存 在动画蓝图中使用按骨骼分层混合节点, 混合装备武器动画和状态机输出, 只应用于游戏角色上半部分 在动画蓝图添加Slot # 去到ABP_BaseCharacter \u0026gt; AnimGraph 添加Slot 设置 - SlotName DefaultGroup.UpperBody 设置装备武器动画剪辑分组 # 打开AM_Equip 设置 - SlotName DefaultGroup.UpperBody 添加姿势缓存 # Animation Cache 去到ABP_BaseCharacter \u0026gt; AnimGraph 缓存Locomotion的输出 命名为LocomotionCache 像使用变量一样使用LocomotionCache, 作为瞄准偏移输入 使用按骨骼分层混合节点 # Layered Blend per Bone 去到ABP_BaseCharacter \u0026gt; AnimGraph 添加节点: 按骨骼分层混合节点 查看游戏角色骨骼 # 打开HeroTPP_Skeleton, 去到骨骼树面板 b_Spine将身体分为上下两部分 设置节点 # 输入 - BasePose LocomotionCache BlendPoses0 Slot \u0026lsquo;UpperBody\u0026rsquo; 设置骨骼 选中按骨骼分层混合节点 去到细节面板 设置骨骼为b_Spine 输出连接到Slot \u0026lsquo;DefaultSlot\u0026rsquo; 完整实现 # 查看 # 向前移动时更换武器, 只有身体上半部分动画受影响 ",content:"说明 # 向前移动时更换武器, 动画有卡顿 当前, 四个方向移动 + 跑步动画的输出 \u0026gt; 瞄准偏移 \u0026gt; 左手固定在枪托 \u0026gt; Slot \u0026gt; 动画蓝图输出 卡顿的原因时, 通过Slot拼接动画和动画剪辑时, 动画的姿势被擦除了, 卡顿时, 只有装备武器动画在播放 在动画蓝图使用按骨骼分层混合节点, 混合装备武器动画和状态机输出, 只应用于游戏角色上半部分 概览 # 在动画蓝图添加游戏角色身体上半部分Slot, 并设置装备武器动画剪辑亦属于该Slot 在动画蓝图中将状态机输出缓存 在动画蓝图中使用按骨骼分层混合节点, 混合装备武器动画和状态机输出, 只应用于游戏角色上半部分 在动画蓝图添加Slot # 去到ABP_BaseCharacter \u0026gt; AnimGraph 添加Slot 设置 - SlotName DefaultGroup.UpperBody 设置装备武器动画剪辑分组 # 打开AM_Equip 设置 - SlotName DefaultGroup.UpperBody 添加姿势缓存 # Animation Cache 去到ABP_BaseCharacter \u0026gt; AnimGraph 缓存Locomotion的输出 命名为LocomotionCache 像使用变量一样使用LocomotionCache, 作为瞄准偏移输入 使用按骨骼分层混合节点 # Layered Blend per Bone 去到ABP_BaseCharacter \u0026gt; AnimGraph 添加节点: 按骨骼分层混合节点 查看游戏角色骨骼 # 打开HeroTPP_Skeleton, 去到骨骼树面板 b_Spine将身体分为上下两部分 设置节点 # 输入 - BasePose LocomotionCache BlendPoses0 Slot \u0026lsquo;UpperBody\u0026rsquo; 设置骨骼 选中按骨骼分层混合节点 去到细节面板 设置骨骼为b_Spine 输出连接到Slot \u0026lsquo;DefaultSlot\u0026rsquo; 完整实现 # 查看 # 向前移动时更换武器, 只有身体上半部分动画受影响 "}),e.add({id:161,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/hungry-delete/",title:"hungry-delete",description:"删除连续空格 hungry-delete-安装 # (use-package hungry-delete :ensure t :config (global-hungry-delete-mode) ) ",content:"删除连续空格 hungry-delete-安装 # (use-package hungry-delete :ensure t :config (global-hungry-delete-mode) ) "}),e.add({id:162,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%BC%B9%E8%8D%AF%E6%95%B0%E6%8D%AE/",title:"弹药数据",description:"概览 # 在武器类所属源文件中定义数据结构, 存放弹药数据 在武器类中添加数据结构, 保存弹药规格和数据 使用武器时, 更新弹药库存, 无存货停止射击 无弹药时, 关闭步枪连续射击定时器 定义弹药数据结构体 # 两种使用场景: 当前弹药数据; 弹药规格 / 初始值 Infinite配置 步枪 true 榴弹发射器 false 步枪 # 当前弹药数据 弹药规格 / 初始值 Bullets 弹夹中的子弹数 弹夹中的子弹上限 Infinite 无限模式 Clips 只在Infinite为false时使用; 弹夹或个数 榴弹发射器 # 当前弹药数据 Bullets - Infinite 无限模式 Clips 只在Infinite为false时使用; 弹药个数 定义结构体 # ShootThemUp: Weapon/STUBaseWeapon.h USTRUCT(BlueprintType) struct FAmmoData { GENERATED_USTRUCT_BODY() UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) int32 Bullets; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) bool Infinite; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta = (EditConditon = (!",content:"概览 # 在武器类所属源文件中定义数据结构, 存放弹药数据 在武器类中添加数据结构, 保存弹药规格和数据 使用武器时, 更新弹药库存, 无存货停止射击 无弹药时, 关闭步枪连续射击定时器 定义弹药数据结构体 # 两种使用场景: 当前弹药数据; 弹药规格 / 初始值 Infinite配置 步枪 true 榴弹发射器 false 步枪 # 当前弹药数据 弹药规格 / 初始值 Bullets 弹夹中的子弹数 弹夹中的子弹上限 Infinite 无限模式 Clips 只在Infinite为false时使用; 弹夹或个数 榴弹发射器 # 当前弹药数据 Bullets - Infinite 无限模式 Clips 只在Infinite为false时使用; 弹药个数 定义结构体 # ShootThemUp: Weapon/STUBaseWeapon.h USTRUCT(BlueprintType) struct FAmmoData { GENERATED_USTRUCT_BODY() UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) int32 Bullets; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) bool Infinite; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta = (EditConditon = (!Infinite))) int32 Clips; }; 添加数据成员 # - DefaultAmmo 弹药规格 / 初始值 CurrentAmmo 当前弹药数据 ShootThemUp: Weapon/STUBaseWeapon.h // protected UPROPERTY(EditDefaultsOnly, BlueprintReadWrite) FAmmoData DefaultAmmo {15, 10, false}; // private FAmmoData CurrentAmmo; 设置弹药初始值 # ShootThemUp: Weapon/STUBaseWeapon.cpp // BeginPlay CurrentAmmo = DefaultAmmo; 使用武器时, 更新弹药库存, 无存货停止射击 # 添加接口: 弹夹是否为空 # ShootThemUp: Weapon/STUBaseWeapon.cpp bool ASTUBaseWeapon::IsClipEmpty() const { return CurrentAmmo.Bullets == 0; } 添加接口: 更换弹夹 # ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::ChangeClip() { CurrentAmmo.Bullets = DefaultAmmo.Bullets; if (!CurrentAmmo.Infinite) { --CurrentAmmo.Clips; } UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;---------Change Clip----------\u0026quot;)); } 添加接口: 是否还有弹药 # ShootThemUp: Weapon/STUBaseWeapon.cpp bool ASTUBaseWeapon::IsAmmoEmpty() const { return CurrentAmmo.Infinite ? false : (!CurrentAmmo.Bullets \u0026amp;\u0026amp; !CurrentAmmo.Clips); } 添加接口: 输出弹药信息 # 目前没有UI, 在终端输入信息 ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::LogAmmo() { FString AmmoInfo = \u0026quot;Ammo: \u0026quot; + FString::FromInt(CurrentAmmo.Bullets) + \u0026quot; / \u0026quot;; AmmoInfo += CurrentAmmo.Infinite ? \u0026quot;Infinite\u0026quot; : FString::FromInt(CurrentAmmo.Clips); UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;%s\u0026quot;), *AmmoInfo); } 添加接口: 更新弹药库存 # ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::DecreaseAmmo() { --CurrentAmmo.Bullets; LogAmmo(); if (IsClipEmpty() \u0026amp;\u0026amp; !IsAmmoEmpty()) { ChangeClip(); } } 添加声明 # protected ShootThemUp: Weapon/STUBaseWeapon.h bool IsClipEmpty() const; void ChangeClip(); bool IsAmmoEmpty() const; void LogAmmo(); void DecreaseAmmo(); 射击时判断弹药库存, 更新弹药数据 # 步枪 ShootThemUp: Weapon/STURifleWeapon.cpp // MakeShot if (IsAmmoEmpty()) return; DecreaseAmmo(); 榴弹发射器 ShootThemUp: Weapon/STULauncherWeapon.cpp // MakeShot if (IsAmmoEmpty()) return; DecreaseAmmo(); 查看 # 设置步枪和榴弹发射器的初始弹药 DefaultAmmo Infinite Bullets Clips BP_STULauncherWeapon false 1 5 BP_STURifleWeapon true 15 10 日志 步枪能不停换弹夹(可以把Clips初始值设为0) 榴弹发射器可以射击6次: 已装载弹夹和剩余弹夹 步枪连续射击定时器问题 # ShootThemUp: Weapon/STURifleWeapon.cpp 弹药结束时关闭定时器 // MakeShot if (IsAmmoEmpty()) { FireStop(); return; } "}),e.add({id:163,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/smartparens/",title:"smartparens",description:"成对键入括号 说明 # 若开启smartparens-strict-mode, 会成对删除括号和其包含的内容 smartparens-安装 # (use-package smartparens :ensure t :hook ( (prog-mode . smartparens-mode) (c++-mode . smartparens-mode) (c-mode . smartparens-strict-mode) ) :custom (sp-escape-quotes-after-insert nil) :config (require 'smartparens-config) (smartparens-global-mode t)) ",content:"成对键入括号 说明 # 若开启smartparens-strict-mode, 会成对删除括号和其包含的内容 smartparens-安装 # (use-package smartparens :ensure t :hook ( (prog-mode . smartparens-mode) (c++-mode . smartparens-mode) (c-mode . smartparens-strict-mode) ) :custom (sp-escape-quotes-after-insert nil) :config (require 'smartparens-config) (smartparens-global-mode t)) "}),e.add({id:164,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E8%A3%85%E5%BC%B9%E5%8A%A8%E7%94%BB/",title:"装弹动画",description:"说明 # 已在弹夹子弹耗尽时实现自动装弹逻辑 现在实现手动装弹的第一步, 播放装弹动画 步枪和发射器各有一个装弹动画, 使用动画剪辑实现 概览 # 创建两个动画剪辑资产, 并设置SlotName 绑定手动装弹键位 将武器信息封装到数据结构 更换武器时, 更新对应的装弹动画 创建动画剪辑资产 # 为装弹动画绑定骨骼HeroTPP_Skeleton, 创建对应的动画剪辑资产, 保存到Player/Animations - Launcher_Reload AM_Launcher_Reload Reload AM_Reload 设置动画剪辑的SlotName, 选择UpperBody 绑定装弹键位 # 项目设置 \u0026gt; Engine \u0026gt; Input - 类型 Action Mappings 函数描述 Reload 键位 R 搭建手动装弹框架 # 添加空的Reload函数 # ShootThemUp: Components/STUWeaponComponent.h public void Reload(); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::Reload() { PlayAnimMontage(CurrentReloadAnimMontage); } 绑定函数描述和回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Reload\u0026quot;, IE_Pressed, WeaponComponent, \u0026amp;USTUWeaponComponent::Reload); 将武器信息封装到数据结构 # 当前, 不同武器有各自的武器类属性, 结合装弹动画, 定义存放武器信息的数据结构 定义数据结构存放武器信息 # ShootThemUp: Components/STUWeaponComponent.",content:"说明 # 已在弹夹子弹耗尽时实现自动装弹逻辑 现在实现手动装弹的第一步, 播放装弹动画 步枪和发射器各有一个装弹动画, 使用动画剪辑实现 概览 # 创建两个动画剪辑资产, 并设置SlotName 绑定手动装弹键位 将武器信息封装到数据结构 更换武器时, 更新对应的装弹动画 创建动画剪辑资产 # 为装弹动画绑定骨骼HeroTPP_Skeleton, 创建对应的动画剪辑资产, 保存到Player/Animations - Launcher_Reload AM_Launcher_Reload Reload AM_Reload 设置动画剪辑的SlotName, 选择UpperBody 绑定装弹键位 # 项目设置 \u0026gt; Engine \u0026gt; Input - 类型 Action Mappings 函数描述 Reload 键位 R 搭建手动装弹框架 # 添加空的Reload函数 # ShootThemUp: Components/STUWeaponComponent.h public void Reload(); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::Reload() { PlayAnimMontage(CurrentReloadAnimMontage); } 绑定函数描述和回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Reload\u0026quot;, IE_Pressed, WeaponComponent, \u0026amp;USTUWeaponComponent::Reload); 将武器信息封装到数据结构 # 当前, 不同武器有各自的武器类属性, 结合装弹动画, 定义存放武器信息的数据结构 定义数据结构存放武器信息 # ShootThemUp: Components/STUWeaponComponent.h USTRUCT(BlueprintType) struct FWeaponData { GENERATED_USTRUCT_BODY() UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = \u0026quot;Weapon\u0026quot;) TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponClass; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = \u0026quot;Weapon\u0026quot;) UAnimMontage *ReloadAnimMontage; }; 在武器组件类添加数组成员, 存放武器信息 # protected ShootThemUp: Components/STUWeaponComponent.h UPROPERTY(EditDefaultsOnly, Category = \u0026quot;Weapon\u0026quot;) TArray\u0026lt;FWeaponData\u0026gt; WeaponData; 屏蔽武器类属性 # ShootThemUp: Components/STUWeaponComponent.h 创建武器时, 依据数组信息 # 注意: 若创建武器失败, 继续创建其他武器 ShootThemUp: Components/STUWeaponComponent.cpp // SpawnWeapons for (auto OneWeaponData : WeaponData) { auto Weapon = GetWorld()-\u0026gt;SpawnActor\u0026lt;ASTUBaseWeapon\u0026gt;(OneWeaponData.WeaponClass); if (!Weapon) continue; Weapons.Add(Weapon); Weapon-\u0026gt;SetOwner(Character); AttachWeaponToSocket(Weapon, Character-\u0026gt;GetMesh(), WeaponArmorySocketName); } 添加属性, 指向当前装弹动画 # private 经常需要播放装弹动画 ShootThemUp: Components/STUWeaponComponent.h UPROPERTY() UAnimMontage *CurrentReloadAnimMontage = nullptr; 更换武器时, 更新装弹动画 # EquipWeapon ShootThemUp: Components/STUWeaponComponent.cpp 进入时检查WeaponIndex # if (WeaponIndex \u0026lt; 0 || WeaponIndex \u0026gt;= Weapons.Num()) { UE_LOG(LogWeaponComponent, Warning, TEXT(\u0026quot;Invalid weapon index\u0026quot;)); return; } 不使用武器标号获取动画剪辑 # 创建武器时, 根据WeaponData元素顺序 存在武器创建失败的情况, 后续可能需要对武器进行排序 // CurrentReloadAnimMontage = WeaponData[WeaponIndex].ReloadAnimMontage; 根据武器类型, 查找对应的武器信息 # 使用lambda表达式实现查找谓语 对调用运算符进行重载 使用lambda表达式实现一元谓语, 捕获引用, 比对武器类型, 返回true或false 若匹配元素个数为0或大于1, 查找函数返回nullptr const auto CurrentWeaponData = WeaponData.FindByPredicate([\u0026amp;](const FWeaponData \u0026amp;Data){ // return Data.WeaponClass == CurrentWeapon-\u0026gt;GetClass(); // }); 设置当前武器的装弹动画剪辑 # CurrentReloadAnimMontage = CurrentWeaponData ? CurrentWeaponData-\u0026gt;ReloadAnimMontage : nullptr; 设置游戏角色的WeaponData数组 # 打开BP_STUBaseCharacter, 选中WeaponComponent, 去到Details \u0026gt; Weapon \u0026gt; WeaponData "}),e.add({id:165,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/rainbow-delimiters/",title:"rainbow-delimiters",description:"为匹配括号设置相同颜色 rainbow-delimiters-安装 # (use-package rainbow-delimiters :ensure t :init (progn (rainbow-delimiters-mode t) (add-hook 'prog-mode-hook #'rainbow-delimiters-mode) ;; (add-hook 'org-mode-hook #'rainbow-delimiters-mode) ) ) ",content:"为匹配括号设置相同颜色 rainbow-delimiters-安装 # (use-package rainbow-delimiters :ensure t :init (progn (rainbow-delimiters-mode t) (add-hook 'prog-mode-hook #'rainbow-delimiters-mode) ;; (add-hook 'org-mode-hook #'rainbow-delimiters-mode) ) ) "}),e.add({id:166,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E4%B8%BA%E8%A3%85%E5%BC%B9%E5%8A%A8%E7%94%BB%E5%89%AA%E8%BE%91%E6%B7%BB%E5%8A%A0%E9%80%9A%E7%9F%A5/",title:"为装弹动画剪辑添加通知",description:"说明 # 播放动画时, 不允许其他操作, 使用动画通知 AnimNotify 实现 概览 # 为更换武器和装弹创建动画通知基类 将动画通知逻辑移动到STUAnimNotify, 使STUEquipFinishedAnimNotify派生自STUAnimNotify 在装弹动画中添加结束事件, 注册处理函数 手动装弹时检查, 完善开火和更换武器检查 创建AnimNotify派生类 # 创建STUAnimNotify # - 基类 AnimNotify 路径 Animations 属性 Public 创建STUReloadFinishedAnimNotify # - 基类 STUAnimNOtify 路径 Animations 属性 Public 把动画通知逻辑从STUEquipFinishedAnimNotify移动到STUAnimNotify # 实现STUAnimNotify # 定义委托类型 ShootThemUp: Animations/STUAnimNotify.h DECLARE_MULTICAST_DELEGATE_OneParam(FOnNotifiedSignature, USkeletalMeshComponent*); 添加数据成员 public ShootThemUp: Animations/STUAnimNotify.h FOnNotifiedSignature OnNotified; 覆写虚函数 public ShootThemUp: Animations/STUAnimNotify.h virtual void Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference\u0026amp; EventReference) override; ShootThemUp: Animations/STUAnimNotify.cpp void USTUAnimNotify::Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference\u0026amp; EventReference) { OnNotified.",content:"说明 # 播放动画时, 不允许其他操作, 使用动画通知 AnimNotify 实现 概览 # 为更换武器和装弹创建动画通知基类 将动画通知逻辑移动到STUAnimNotify, 使STUEquipFinishedAnimNotify派生自STUAnimNotify 在装弹动画中添加结束事件, 注册处理函数 手动装弹时检查, 完善开火和更换武器检查 创建AnimNotify派生类 # 创建STUAnimNotify # - 基类 AnimNotify 路径 Animations 属性 Public 创建STUReloadFinishedAnimNotify # - 基类 STUAnimNOtify 路径 Animations 属性 Public 把动画通知逻辑从STUEquipFinishedAnimNotify移动到STUAnimNotify # 实现STUAnimNotify # 定义委托类型 ShootThemUp: Animations/STUAnimNotify.h DECLARE_MULTICAST_DELEGATE_OneParam(FOnNotifiedSignature, USkeletalMeshComponent*); 添加数据成员 public ShootThemUp: Animations/STUAnimNotify.h FOnNotifiedSignature OnNotified; 覆写虚函数 public ShootThemUp: Animations/STUAnimNotify.h virtual void Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference\u0026amp; EventReference) override; ShootThemUp: Animations/STUAnimNotify.cpp void USTUAnimNotify::Notify(USkeletalMeshComponent *MeshComp, UAnimSequenceBase *Animation, const FAnimNotifyEventReference\u0026amp; EventReference) { OnNotified.Broadcast(MeshComp); Super::Notify(MeshComp, Animation, EventReference); } 修改STUEquipFinishedAnimNotify # 派生自STUAnimNotify, 修改头文件 ShootThemUp: Animations/STUEquipFinishedAnimNotify.h // #include \u0026quot;Animation/AnimNotifies/AnimNotify.h\u0026quot; #include \u0026quot;Animations/STUAnimNotify.h\u0026quot; class SHOOTTHEMUP_API USTUEquipFinishedAnimNotify : public STUAnimNotify 屏蔽数据成员OnNotified ShootThemUp: Animations/STUEquipFinishedAnimNotify.h 屏蔽函数成员Notify ShootThemUp: Animations/STUEquipFinishedAnimNotify.h ShootThemUp: Animations/STUEquipFinishedAnimNotify.cpp 实现模板函数, 给定动画剪辑, 查找指定类型的通知事件 # private ShootThemUp: Components/STUWeaponComponent.h #include \u0026quot;Animation/AnimSequenceBase.h\u0026quot; template\u0026lt;typename T\u0026gt; T* FindNotifyByClass(UAnimSequenceBase *Animation) { if (!Animation) return nullptr; const auto NotifyEvents = Animation-\u0026gt;Notifies; for (auto NotifyEvent : NotifyEvents) { auto AnimNotify = Cast\u0026lt;T\u0026gt;(NotifyEvent.Notify); if (AnimNotify) { return AnimNotify; } } return nullptr; } 修改InitAnimations中查找更换武器结束事件的方式 # ShootThemUp: Components/STUWeaponComponent.cpp auto EquipFinishedNotify = FindNotifyByClass\u0026lt;USTUEquipFinishedAnimNotify\u0026gt;(EquipAnimMontage); if (EquipFinishedNotify) { EquipFinishedNotify-\u0026gt;OnNotified.AddUObject(this, \u0026amp;USTUWeaponComponent::OnEquipFinished); } 搭建装弹动画结束通知框架 # 在装弹动画剪辑中添加通知事件 # 定义空的回调函数 # private ShootThemUp: Components/STUWeaponComponent.h void OnReloadFinished(USkeletalMeshComponent *MeshComp); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::OnReloadFinished(USkeletalMeshComponent *MeshComp) { } 为装弹动画结束事件注册处理函数 # ShootThemUp: Components/STUWeaponComponent.cpp #include \u0026quot;Animations/STUReloadFinishedAnimNotify.h\u0026quot; for (auto OneWeaponData : WeaponData) { auto ReloadFinishedNotify = FindNotifyByClass\u0026lt;USTUReloadFinishedAnimNotify\u0026gt;(OneWeaponData.ReloadAnimMontage); if (ReloadFinishedNotify) { ReloadFinishedNotify-\u0026gt;OnNotified.AddUObject(this, \u0026amp;USTUWeaponComponent::OnReloadFinished); } } 手动装弹时进行检查 # 添加标志位 # private ShootThemUp: Components/STUWeaponComponent.h bool ReloadAnimInProgress = false; 实现检查接口 # private ShootThemUp: Components/STUWeaponComponent.h bool CanReload() const; ShootThemUp: Components/STUWeaponComponent.cpp bool USTUWeaponComponent::CanReload() const { return CurrentWeapon \u0026amp;\u0026amp; !EquipAnimInProgress \u0026amp;\u0026amp; !ReloadAnimInProgress; } 播放装弹动画前进行检查, 设置标志位 # ShootThemUp: Components/STUWeaponComponent.cpp // Reload if (!CanReload()) return; ReloadAnimInProgress = true; 修改开火检查 # ShootThemUp: Components/STUWeaponComponent.cpp // CanFire return CurrentWeapon \u0026amp;\u0026amp; !EquipAnimInProgress \u0026amp;\u0026amp; !ReloadAnimInProgress; 修改更换武器检查 # ShootThemUp: Components/STUWeaponComponent.cpp // CanEquip return !EquipAnimInProgress \u0026amp;\u0026amp; !ReloadAnimInProgress; 实现回调函数 # ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::OnReloadFinished(USkeletalMeshComponent *MeshComp) { ACharacter *Character = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Character || (Character-\u0026gt;GetMesh() != MeshComp)) return; ReloadAnimInProgress = false; } "}),e.add({id:167,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/yasnippet/",title:"yasnippet",description:"预定义模板 yasnippet-安装 # (use-package yasnippet :config (progn (let ((yas-snippet (concat my/emacs-config \u0026quot;/snippets\u0026quot;))) (setq yas-snippet-dirs '()) (add-to-list 'yas-snippet-dirs yas-snippet) ) (require 'yasnippet) (yas-global-mode 1) ) :ensure t ) ",content:"预定义模板 yasnippet-安装 # (use-package yasnippet :config (progn (let ((yas-snippet (concat my/emacs-config \u0026quot;/snippets\u0026quot;))) (setq yas-snippet-dirs '()) (add-to-list 'yas-snippet-dirs yas-snippet) ) (require 'yasnippet) (yas-global-mode 1) ) :ensure t ) "}),e.add({id:168,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%AE%8C%E5%96%84%E8%A3%85%E5%BC%B9%E9%80%BB%E8%BE%91/",title:"完善装弹逻辑",description:"说明 # 自动装弹时播放动画 手动装弹时更新弹药库存 概览 # 定义委托类型, 用于自动装弹 提取封装装弹逻辑, 供手动/自动装弹时使用 在武器类定义委托, 需要更换弹夹时进行通知 # 定义委托, 在弹药用完时行通知客户端 # ShootThemUp: Weapon/STUBaseWeapon.h DECLARE_MULTICAST_DELEGATE(FOnClipEmptySignature); 添加数据成员 # public ShootThemUp: Weapon/STUBaseWeapon.h FOnClipEmptySignature OnClipEmpty; 弹药用完时, 通知客户端, 由客户端负责后续处理 # ShootThemUp: Weapon/STUBaseWeapon.cpp // DecreaseAmmo if (IsClipEmpty() \u0026amp;\u0026amp; !IsAmmoEmpty()) { // ChangeClip(); OnClipEmpty.Broadcast(); } 将ChangeClip改为public, 供武器组件在处理函数中调用 # ShootThemUp: Weapon/STUBaseWeapon.h 在武器类中添加接口 # 是否满足手动更换弹夹条件 # 当前弹夹不是满的 还有其他弹夹 ShootThemUp: Weapon/STUBaseWeapon.h public bool CanReload(); ShootThemUp: Weapon/STUBaseWeapon.cpp bool ASTUBaseWeapon::CanReload() { return CurrentAmmo.Bullets \u0026lt; DefaultAmmo.Bullets \u0026amp;\u0026amp; CurrentAmmo.Clips \u0026gt; 0; } 更换弹夹时, 检查剩余弹夹数 # DecreaseAmmo中调用ChangeClip时, 已检查过弹药库存; 手动装弹时需要该判断 ShootThemUp: Weapon/STUBaseWeapon.",content:"说明 # 自动装弹时播放动画 手动装弹时更新弹药库存 概览 # 定义委托类型, 用于自动装弹 提取封装装弹逻辑, 供手动/自动装弹时使用 在武器类定义委托, 需要更换弹夹时进行通知 # 定义委托, 在弹药用完时行通知客户端 # ShootThemUp: Weapon/STUBaseWeapon.h DECLARE_MULTICAST_DELEGATE(FOnClipEmptySignature); 添加数据成员 # public ShootThemUp: Weapon/STUBaseWeapon.h FOnClipEmptySignature OnClipEmpty; 弹药用完时, 通知客户端, 由客户端负责后续处理 # ShootThemUp: Weapon/STUBaseWeapon.cpp // DecreaseAmmo if (IsClipEmpty() \u0026amp;\u0026amp; !IsAmmoEmpty()) { // ChangeClip(); OnClipEmpty.Broadcast(); } 将ChangeClip改为public, 供武器组件在处理函数中调用 # ShootThemUp: Weapon/STUBaseWeapon.h 在武器类中添加接口 # 是否满足手动更换弹夹条件 # 当前弹夹不是满的 还有其他弹夹 ShootThemUp: Weapon/STUBaseWeapon.h public bool CanReload(); ShootThemUp: Weapon/STUBaseWeapon.cpp bool ASTUBaseWeapon::CanReload() { return CurrentAmmo.Bullets \u0026lt; DefaultAmmo.Bullets \u0026amp;\u0026amp; CurrentAmmo.Clips \u0026gt; 0; } 更换弹夹时, 检查剩余弹夹数 # DecreaseAmmo中调用ChangeClip时, 已检查过弹药库存; 手动装弹时需要该判断 ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::ChangeClip() { if (!CurrentAmmo.Infinite) { if (CurrentAmmo.Clips == 0) { UE_LOG(LogBaseWeapon, Warning, TEXT(\u0026quot;No more clips\u0026quot;)); return; } --CurrentAmmo.Clips; } CurrentAmmo.Bullets = DefaultAmmo.Bullets; UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;---------Change Clip----------\u0026quot;)); } 减少子弹时, 检查子弹数 # 在MakeShot中调用DecreaseAmmo, 已检查过弹药库存 ShootThemUp: Weapon/STUBaseWeapon.cpp // DecreaseAmmo if (CurrentAmmo.Bullets == 0) { UE_LOG(LogBaseWeapon, Warning, TEXT(\u0026quot;Clips is empty\u0026quot;)); return; } 武器组件注册更换弹夹通知服务 # 添加空的处理函数 # private ShootThemUp: Components/STUWeaponComponent.h void OnEmptyClip(); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::OnEmptyClip() {} 创建武器后, 为武器注册服务 # ShootThemUp: Components/STUWeaponComponent.cpp Weapon-\u0026gt;OnClipEmpty.AddUObject(this, \u0026amp;USTUWeaponComponent::OnEmptyClip); 实现装弹逻辑 # 装弹检查时, 检查弹药库存 # ShootThemUp: Components/STUWeaponComponent.cpp // CanReload return CurrentWeapon // \u0026amp;\u0026amp; !EquipAnimInProgress // \u0026amp;\u0026amp; !ReloadAnimInProgress // \u0026amp;\u0026amp; CurrentWeapon-\u0026gt;CanReload(); 添加接口, 实现更换弹夹逻辑 # 关闭连续开火定时器 调用武器更换弹夹逻辑 ShootThemUp: Components/STUWeaponComponent.h private void ChangeClip(); ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::ChangeClip() { if (!CanReload()) return; CurrentWeapon-\u0026gt;FireStop(); CurrentWeapon-\u0026gt;ChangeClip(); ReloadAnimInProgress = true; PlayAnimMontage(CurrentReloadAnimMontage); } 手动装弹时, 调用ChangeClip # 屏蔽Reload原逻辑 ShootThemUp: Components/STUWeaponComponent.cpp // Reload ChangeClip(); 自动装弹时, 调用ChangeClip # ShootThemUp: Components/STUWeaponComponent.cpp // OnEmptyClip ChangeClip(); 查看 # 当弹夹里的子弹只剩最后一个时, 持续射击, 自动更换完弹夹后, 射击继续 - FireStart MakeShot \u0026gt; DecreaseAmmo 子弹数减为0, 通知客户端 OnEmptyClip中更换了弹夹并关闭了定时器 开启定时器 解决方法 # FireStart中, 先开启定时器, 再射击 ShootThemUp: Weapon/STURifleWeapon.cpp // FireStart GetWorldTimerManager().SetTimer(ShotTimerHandle, this, \u0026amp;ASTURifleWeapon::MakeShot, TimeBetweenShots, true); MakeShot(); 通知弹夹为空之前, 关闭开火定时器 ShootThemUp: Weapon/STUBaseWeapon.cpp // DecreaseAmmo if (IsClipEmpty() \u0026amp;\u0026amp; !IsAmmoEmpty()) { FireStop(); OnClipEmpty.Broadcast(); } "}),e.add({id:169,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/company/",title:"company",description:"提供文本补全 company-安装 # (use-package company :ensure t :init (add-hook 'after-init-hook 'global-company-mode) ;; 全局有效 :config (setq company-idle-delay 0.08 ;; 提示时延 company-minimum-prefix-length 2 ;; 触发提示的字符数 company-show-numbers t ;; 给选项编号 M-编号选择 company-dabbrev-downcase nil ;; 关闭转小写 )) 协作插件 # company-box",content:`提供文本补全 company-安装 # (use-package company :ensure t :init (add-hook 'after-init-hook 'global-company-mode) ;; 全局有效 :config (setq company-idle-delay 0.08 ;; 提示时延 company-minimum-prefix-length 2 ;; 触发提示的字符数 company-show-numbers t ;; 给选项编号 M-编号选择 company-dabbrev-downcase nil ;; 关闭转小写 )) 协作插件 # company-box
`}),e.add({id:170,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/company-box/",title:"company-box",description:"修改文本补全备选框样式 company-box-安装 # (use-package company-box :ensure t :if window-system :hook (company-mode . company-box-mode)) ",content:"修改文本补全备选框样式 company-box-安装 # (use-package company-box :ensure t :if window-system :hook (company-mode . company-box-mode)) "}),e.add({id:171,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/dashboard/",title:"dashboard",description:"自定义Emacs打开页面 dashboard-安装 # (use-package dashboard :ensure t :config (setq dashboard-banner-logo-title \u0026quot;Emacs\u0026quot;) (setq dashboard-startup-banner 'official) (setq dashboard-center-content t) (setq dashboard-show-shortcuts nil) (setq dashboard-items '((recents . 5) (bookmarks . 5) ;; (projects . 5) (agenda . 5) (registers . 5))) (setq dashboard-set-heading-icons t) (setq dashboard-set-file-icons t) (setq dashboard-set-navigator nil) (dashboard-setup-startup-hook) ) ",content:"自定义Emacs打开页面 dashboard-安装 # (use-package dashboard :ensure t :config (setq dashboard-banner-logo-title \u0026quot;Emacs\u0026quot;) (setq dashboard-startup-banner 'official) (setq dashboard-center-content t) (setq dashboard-show-shortcuts nil) (setq dashboard-items '((recents . 5) (bookmarks . 5) ;; (projects . 5) (agenda . 5) (registers . 5))) (setq dashboard-set-heading-icons t) (setq dashboard-set-file-icons t) (setq dashboard-set-navigator nil) (dashboard-setup-startup-hook) ) "}),e.add({id:172,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/csharp-mode/",title:"csharp-mode",description:"代码框语法高亮, 文件语法高亮 csharp-mode-安装 # (use-package csharp-mode :ensure t) ",content:"代码框语法高亮, 文件语法高亮 csharp-mode-安装 # (use-package csharp-mode :ensure t) "}),e.add({id:173,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/yaml-mode/",title:"yaml-mode",description:"代码框语法高亮, 文件语法高亮 yaml-mode-安装 # (use-package yaml-mode :ensure t) ",content:"代码框语法高亮, 文件语法高亮 yaml-mode-安装 # (use-package yaml-mode :ensure t) "}),e.add({id:174,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/markdown-mode/",title:"markdown-mode",description:"代码框语法高亮, 文件语法高亮 markdown-mode-安装 # (use-package markdown-mode :ensure t) ",content:"代码框语法高亮, 文件语法高亮 markdown-mode-安装 # (use-package markdown-mode :ensure t) "}),e.add({id:175,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/json-mode/",title:"json-mode",description:"代码框语法高亮 说明 # Unreal项目文件类似json语法 json-mode-安装 # (use-package json-mode :ensure t) ",content:"代码框语法高亮 说明 # Unreal项目文件类似json语法 json-mode-安装 # (use-package json-mode :ensure t) "}),e.add({id:176,href:"/docs/game/",title:"🎮",description:"",content:""}),e.add({id:177,href:"/docs/build-blog/",title:"🔨📓",description:"",content:""}),e.add({id:178,href:"/docs/brick/",title:"🧱",description:"",content:""}),e.add({id:179,href:"/docs/",title:"笔记",description:"",content:""}),e.add({id:180,href:"/docs/%E5%88%86%E4%BA%AB/",title:"分享",description:"",content:""}),e.add({id:181,href:"/docs/%E5%88%86%E4%BA%AB/emacs/",title:"Emacs",description:"",content:""}),e.add({id:182,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/",title:"开发工具",description:"",content:""}),e.add({id:183,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/",title:"开发语言",description:"",content:""}),e.add({id:184,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/",title:"专题",description:"",content:""}),e.add({id:185,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/",title:"API",description:"",content:""}),e.add({id:186,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/",title:"虚幻引擎",description:"",content:""}),e.add({id:187,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/",title:"进阶课程",description:"",content:""}),e.add({id:188,href:"/docs/%E5%88%86%E4%BA%AB/macos%E5%BA%94%E7%94%A8/",title:"macOS应用",description:"",content:""}),e.add({id:189,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2/",title:"游戏角色",description:"",content:""}),e.add({id:190,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE/",title:"动画蓝图",description:"",content:""}),e.add({id:191,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%8F%92%E4%BB%B6/",title:"插件",description:"",content:""}),e.add({id:192,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/",title:"需求",description:"",content:""}),e.add({id:193,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/",title:"角色和动画",description:"",content:""}),e.add({id:194,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E7%BB%84%E4%BB%B6/",title:"组件",description:"",content:""}),e.add({id:195,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/npc%E8%A1%8C%E4%B8%BA/",title:"NPC行为",description:"",content:""}),e.add({id:196,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%83%B3%E6%B3%95/",title:"想法",description:"",content:""}),e.add({id:197,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/",title:"健康系统",description:"",content:""}),e.add({id:198,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E6%8E%A7%E5%88%B6%E5%99%A8/",title:"控制器",description:"",content:""}),e.add({id:199,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/",title:"武器",description:"",content:""}),e.add({id:200,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%99%9A%E5%B9%BB%E8%BF%90%E5%8A%A8%E5%9B%BE%E8%A1%A8/",title:"虚幻运动图表",description:"",content:""}),e.add({id:201,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A1%A5%E7%BB%99/",title:"补给",description:"",content:""}),e.add({id:202,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/",title:"粒子系统",description:"",content:""}),e.add({id:203,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E9%9D%9E%E7%8E%A9%E5%AE%B6%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A1%8C%E4%B8%BA/",title:"非玩家游戏角色行为",description:"",content:""}),e.add({id:204,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99/",title:"游戏规则",description:"",content:""}),e.add({id:205,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BB%E7%BC%96%E8%BE%91%E5%99%A8/",title:"虚幻编辑器",description:"",content:""}),e.add({id:206,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BBc++/",title:"虚幻C++",description:"",content:""}),e.add({id:207,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/",title:"虚幻C++",description:"",content:""}),e.add({id:208,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/engine/",title:"Engine",description:"",content:""}),e.add({id:209,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E5%85%B3%E5%8D%A1%E8%AE%BE%E7%BD%AE/",title:"关卡设置",description:"",content:""}),e.add({id:210,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",title:"数据结构",description:"",content:""}),e.add({id:211,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E5%8A%A8%E7%94%BB/",title:"动画",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()