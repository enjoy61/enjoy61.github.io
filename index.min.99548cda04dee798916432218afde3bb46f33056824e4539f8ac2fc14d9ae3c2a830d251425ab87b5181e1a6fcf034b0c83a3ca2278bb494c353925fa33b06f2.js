var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E7%BB%84%E4%BB%B6/textrender%E7%BB%84%E4%BB%B6/",title:"TextRender组件",description:"UTextRenderComponent # 基类 # UPrimitiveComponent 相关函数 # UPrimitiveComponent::SetOwnerNoSee ",content:"UTextRenderComponent # 基类 # UPrimitiveComponent 相关函数 # UPrimitiveComponent::SetOwnerNoSee "}),e.add({id:1,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BB%E7%BC%96%E8%BE%91%E5%99%A8/%E7%BB%99%E9%AA%A8%E9%AA%BC%E7%BD%91%E6%A0%BC%E4%BD%93%E6%B7%BB%E5%8A%A0%E8%A3%85%E8%BD%BD%E7%82%B9/",title:"给骨骼网格体添加装载点",description:"概览 # 骨骼网格体: HeroTPP Content/ExternalContent/Animation/Characters/HeroTPP/HeroTPP.uasset 挂载点: b_Right_Weapon Socket: WeaponSocket 在骨骼网格体上添加挂载点 # 直接打开HeroTPP，或者 打开BP_STUBaseCharacter \u0026gt; Skeletal Mesh \u0026gt; 双击HeroTPP 左侧骨骼树面板，选中骨骼，可以在右侧细节面板查看骨骼的相对变换 Character的骨骼模型有虚拟骨骼，无图形表示，但支持变换 b_RightWeapon就是虚拟骨骼 选中b_RightWeapon，右键 \u0026gt; Add Socket 设置socket参数 Details socket是骨骼网格体中的特殊object，可以为任何骨骼添加socket socket的实质是骨骼网格体的命名变换，可以在蓝图和C++中获取 骨骼中的socket有多种用途，我们可以在socket上附加武器，之后，还会用作集火点 选中socket，可以右侧细节面板查看参数 - Socket Name WeaponSocket Relative Rotation X: -90 为挂载点添加预览 # WeaponSocket \u0026gt; Add Preview Asset \u0026gt; Rifle 在多个地方调试socket参数 # - 动画资产 BS_Locomotion_Run 动画蓝图 ABP_BaseCharacter 骨骼网格体 HeroTPP \u0026hellip; 通过编辑器的选项卡，我们可以调试某个具体Character姿势中socket的变换 动画资产 搜索 动画蓝图 ",content:"概览 # 骨骼网格体: HeroTPP Content/ExternalContent/Animation/Characters/HeroTPP/HeroTPP.uasset 挂载点: b_Right_Weapon Socket: WeaponSocket 在骨骼网格体上添加挂载点 # 直接打开HeroTPP，或者 打开BP_STUBaseCharacter \u0026gt; Skeletal Mesh \u0026gt; 双击HeroTPP 左侧骨骼树面板，选中骨骼，可以在右侧细节面板查看骨骼的相对变换 Character的骨骼模型有虚拟骨骼，无图形表示，但支持变换 b_RightWeapon就是虚拟骨骼 选中b_RightWeapon，右键 \u0026gt; Add Socket 设置socket参数 Details socket是骨骼网格体中的特殊object，可以为任何骨骼添加socket socket的实质是骨骼网格体的命名变换，可以在蓝图和C++中获取 骨骼中的socket有多种用途，我们可以在socket上附加武器，之后，还会用作集火点 选中socket，可以右侧细节面板查看参数 - Socket Name WeaponSocket Relative Rotation X: -90 为挂载点添加预览 # WeaponSocket \u0026gt; Add Preview Asset \u0026gt; Rifle 在多个地方调试socket参数 # - 动画资产 BS_Locomotion_Run 动画蓝图 ABP_BaseCharacter 骨骼网格体 HeroTPP \u0026hellip; 通过编辑器的选项卡，我们可以调试某个具体Character姿势中socket的变换 动画资产 搜索 动画蓝图 "}),e.add({id:2,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BBc++/%E5%9C%A8%E5%8F%AF%E5%8F%98%E6%8D%A2%E7%BB%84%E4%BB%B6%E4%B8%8A%E6%8C%82%E8%BD%BDactor/",title:"在可变换组件上挂载Actor",description:"概览 # - 可变换组件 USceneComponent及其派生类 挂载函数 AActor::AttachToComponent 获取骨骼网格体组件 ACharacter::GetMesh 挂载规则集合 FAttachmentTransformRules 应用于挂载规则的枚举类型 EAttachmentRule EAttachmentRule # 概览 # API 应用于挂载规则的枚举类型 UE_5.1/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h 枚举成员 # Actor最终变换矩阵 SnapToTarget 组件变换矩阵 x 组件和Actor的相对变换 KeepWorld ？ 计算Actor和组件在世界坐标系中的相对变换，并在最终变换矩阵中使用 socket相对b_Right_Weapon的变换对Actor的最终位置无影响 与组件的变换矩阵无关 与BP_STUBaseCharacter对象在世界坐标系中的变换有关 KeepRelative ？ 使用Actor相对变换矩阵乘以最终变换矩阵 Actor也能挂载到合适位置 FAttachmentTransformRules # 数据成员 # - LocationRule RotationRule SacleRule 使用EAttachmentRule进行设置 bWeldSimulatedBodies 连接两部分时，是否将其焊接 构造函数 # 对变换分量使用相同规则 分别设置变换分量 ACharacter::GetMesh # 获取Character USkeletalComponent组件 AActor::AttachToComponent # 说明 # 将Actor挂载到可变换组件 参数 # - Parent 要挂载的可变换组件 AttachmentRules 挂载后变换矩阵的计算规则 SocketName 挂载点名字 ",content:"概览 # - 可变换组件 USceneComponent及其派生类 挂载函数 AActor::AttachToComponent 获取骨骼网格体组件 ACharacter::GetMesh 挂载规则集合 FAttachmentTransformRules 应用于挂载规则的枚举类型 EAttachmentRule EAttachmentRule # 概览 # API 应用于挂载规则的枚举类型 UE_5.1/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h 枚举成员 # Actor最终变换矩阵 SnapToTarget 组件变换矩阵 x 组件和Actor的相对变换 KeepWorld ？ 计算Actor和组件在世界坐标系中的相对变换，并在最终变换矩阵中使用 socket相对b_Right_Weapon的变换对Actor的最终位置无影响 与组件的变换矩阵无关 与BP_STUBaseCharacter对象在世界坐标系中的变换有关 KeepRelative ？ 使用Actor相对变换矩阵乘以最终变换矩阵 Actor也能挂载到合适位置 FAttachmentTransformRules # 数据成员 # - LocationRule RotationRule SacleRule 使用EAttachmentRule进行设置 bWeldSimulatedBodies 连接两部分时，是否将其焊接 构造函数 # 对变换分量使用相同规则 分别设置变换分量 ACharacter::GetMesh # 获取Character USkeletalComponent组件 AActor::AttachToComponent # 说明 # 将Actor挂载到可变换组件 参数 # - Parent 要挂载的可变换组件 AttachmentRules 挂载后变换矩阵的计算规则 SocketName 挂载点名字 "}),e.add({id:3,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E7%BB%84%E4%BB%B6/springarm%E7%BB%84%E4%BB%B6/",title:"SpringArm组件",description:"USpringArmComponent # USpringArmComponent::SocketOffset # 设置下级组件的相对偏移 ",content:"USpringArmComponent # USpringArmComponent::SocketOffset # 设置下级组件的相对偏移 "}),e.add({id:4,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E7%BB%84%E4%BB%B6/skeletal%E7%BB%84%E4%BB%B6/",title:"Skeletal组件",description:"USkeletalComponent # 骨骼网格体外形是多边形，内里由具有层级结构的骨骼组成，因此，可以为骨骼网格体编排动画 可以是人，可以是物 可以为骨骼网格体绑定模型 头文件 # #include \u0026quot;Components/SkeletalMeshComponent.h\u0026quot; 相关函数 # - ACharacter::GetMesh 获取Character的骨骼网格体组件 ",content:"USkeletalComponent # 骨骼网格体外形是多边形，内里由具有层级结构的骨骼组成，因此，可以为骨骼网格体编排动画 可以是人，可以是物 可以为骨骼网格体绑定模型 头文件 # #include \u0026quot;Components/SkeletalMeshComponent.h\u0026quot; 相关函数 # - ACharacter::GetMesh 获取Character的骨骼网格体组件 "}),e.add({id:5,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E7%BB%84%E4%BB%B6/primitive%E7%BB%84%E4%BB%B6/",title:"Primitive组件",description:"UPrimitiveComponent # UPrimitiveComponent::SetOwnerNoSee # Owner无法看见本组件的渲染，可以看见别家的 ",content:"UPrimitiveComponent # UPrimitiveComponent::SetOwnerNoSee # Owner无法看见本组件的渲染，可以看见别家的 "}),e.add({id:6,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2/character%E7%B1%BB/",title:"Character类",description:"ACharacter # ACharacter::GetMesh # ",content:"ACharacter # ACharacter::GetMesh # "}),e.add({id:7,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/interval%E6%A8%A1%E6%9D%BF%E7%B1%BB/",title:"Interval模板类",description:"TInterval # 模板类型，由两个元素组成，通常用来存放区间，端点Min和Max。 UE_5.1/Engine/Source/Runtime/Core/Public/Math/Interval.h TInterval::Min 和 TInterval::Max # 存放区间 ",content:"TInterval # 模板类型，由两个元素组成，通常用来存放区间，端点Min和Max。 UE_5.1/Engine/Source/Runtime/Core/Public/Math/Interval.h TInterval::Min 和 TInterval::Max # 存放区间 "}),e.add({id:8,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E5%85%B3%E5%8D%A1%E8%AE%BE%E7%BD%AE/hud%E7%B1%BB/",title:"HUD类",description:"AHUD # Head Up Display 在世界设置中，可设置关卡使用HUD类 负责渲染接口，使之始终显示在游戏的最上方, 属于UI范畴 其功能很多都可被widget代替 UE_5.1/Engine/Source/Runtime/Engine/Classes/GameFramework/HUD.h AHUD::DrawHUD # HUD类主要循环函数，负责渲染，每帧调用 我们在其中绘制所需元素，线，长方形，显示纹理和文本，等等 AHUD::DrawLine # 在屏幕上绘制线条 参数 # - StartScreenX, StartScreenY 起点在屏幕的X和Y坐标 EndScreenX，EndScreenY 终点在屏幕的X和Y坐标 LineColor 线条颜色 LineThickness 线条粗细 AHUD::Canvas # 指针，可绘制HUD的画布（当前屏幕） 获取屏幕相关信息，或直接通过Canvas绘制图元 ",content:"AHUD # Head Up Display 在世界设置中，可设置关卡使用HUD类 负责渲染接口，使之始终显示在游戏的最上方, 属于UI范畴 其功能很多都可被widget代替 UE_5.1/Engine/Source/Runtime/Engine/Classes/GameFramework/HUD.h AHUD::DrawHUD # HUD类主要循环函数，负责渲染，每帧调用 我们在其中绘制所需元素，线，长方形，显示纹理和文本，等等 AHUD::DrawLine # 在屏幕上绘制线条 参数 # - StartScreenX, StartScreenY 起点在屏幕的X和Y坐标 EndScreenX，EndScreenY 终点在屏幕的X和Y坐标 LineColor 线条颜色 LineThickness 线条粗细 AHUD::Canvas # 指针，可绘制HUD的画布（当前屏幕） 获取屏幕相关信息，或直接通过Canvas绘制图元 "}),e.add({id:9,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E5%85%B3%E5%8D%A1%E8%AE%BE%E7%BD%AE/gamemodebase%E7%B1%BB/",title:"GameModeBase类",description:"AGameModeBase # 关卡类 AGameModeBase::HUDClass # 设置关卡使用HUD类 ",content:"AGameModeBase # 关卡类 AGameModeBase::HUDClass # 设置关卡使用HUD类 "}),e.add({id:10,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/engine/canvas%E7%B1%BB/",title:"Canvas类",description:"UCanvas # 画布 UE_5.1/Engine/Source/Runtime/Engine/Classes/Engine/Canvas.h 头文件 #include \u0026quot;Engine/Canvas.h\u0026quot; UCanvas::SizeX 和 UCanvas::SizeY # 画布长宽 ",content:"UCanvas # 画布 UE_5.1/Engine/Source/Runtime/Engine/Classes/Engine/Canvas.h 头文件 #include \u0026quot;Engine/Canvas.h\u0026quot; UCanvas::SizeX 和 UCanvas::SizeY # 画布长宽 "}),e.add({id:11,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E8%BF%90%E8%A1%8Cshootergame%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE/",title:"运行ShooterGame示例项目",description:"下载ShooterGame # Epic Games Launcher \u0026gt; Samples \u0026gt; Shooter Game 支持引擎版本 4.0 - 4.27 ，当前使用引擎版本 5.1.1 修改源码 # 退化类 # UMatineeCameraShake 已被 ULegacyCameraShake 替代 不再支持的宏 # PLATFORM_PS4 改法一: 定义该宏 # 在引擎代码中，紧接着 SWITCH 定义该宏 改法二: 屏蔽该宏的出现 # 条件运算符第二个和第三个操作数类型不一致, 且可以互相转换 # 参考 AController * 和 AActor * 可以相互转换，此处有歧义 Source/ShooterGame/Private/Player/ShooterCharacter.cpp:322 运行效果 # ",content:"下载ShooterGame # Epic Games Launcher \u0026gt; Samples \u0026gt; Shooter Game 支持引擎版本 4.0 - 4.27 ，当前使用引擎版本 5.1.1 修改源码 # 退化类 # UMatineeCameraShake 已被 ULegacyCameraShake 替代 不再支持的宏 # PLATFORM_PS4 改法一: 定义该宏 # 在引擎代码中，紧接着 SWITCH 定义该宏 改法二: 屏蔽该宏的出现 # 条件运算符第二个和第三个操作数类型不一致, 且可以互相转换 # 参考 AController * 和 AActor * 可以相互转换，此处有歧义 Source/ShooterGame/Private/Player/ShooterCharacter.cpp:322 运行效果 # "}),e.add({id:12,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%94%9F%E5%91%BD%E5%80%BC/",title:"实时显示游戏角色生命值",description:"概览 # - 健康组件 ActorComponent 自定义，纯逻辑 文本组件 TextRenderComponent 显示生命值 创建健康组件 # 创建Component/STUHealthComponent # 虚幻编辑器 ActorComponent 公有类 调整健康组件框架 # C++ ShootThemUp: Components/STUHealthComponent.h ShootThemUp: Components/STUHealthComponent.cpp - 默认构造函数 将每帧调用TickComponent函数标志置为false BeginPlay TickComponent 屏蔽，使用基类实现 实现 # 添加生命值上限 # protected ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1000.0\u0026quot;)) float MaxHealth = 100.0f;	添加生命值 # private ShootThemUp: Components/STUHealthComponent.h float Health = 0.0f; 初始化生命值 # ShootThemUp: Components/STUHealthComponent.cpp // BeginPlay Health = MaxHealth; 添加接口，返回生命值 # public ShootThemUp: Components/STUHealthComponent.",content:"概览 # - 健康组件 ActorComponent 自定义，纯逻辑 文本组件 TextRenderComponent 显示生命值 创建健康组件 # 创建Component/STUHealthComponent # 虚幻编辑器 ActorComponent 公有类 调整健康组件框架 # C++ ShootThemUp: Components/STUHealthComponent.h ShootThemUp: Components/STUHealthComponent.cpp - 默认构造函数 将每帧调用TickComponent函数标志置为false BeginPlay TickComponent 屏蔽，使用基类实现 实现 # 添加生命值上限 # protected ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1000.0\u0026quot;)) float MaxHealth = 100.0f;	添加生命值 # private ShootThemUp: Components/STUHealthComponent.h float Health = 0.0f; 初始化生命值 # ShootThemUp: Components/STUHealthComponent.cpp // BeginPlay Health = MaxHealth; 添加接口，返回生命值 # public ShootThemUp: Components/STUHealthComponent.h UFUNCTION(BlueprintCallable) float GetHealth() const { return Health; } 为游戏角色添加健康组件 # C++ 添加STUHealthComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h class USTUHealthComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USTUHealthComponent *HealthComponent; 初始化组件: STUHealthComponent无表示，不用设置上级组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/STUHealthComponent.h\u0026quot; // 构造函数 HealthComponent = CreateDefaultSubobject\u0026lt;USTUHealthComponent\u0026gt;(\u0026quot;HealthComponent\u0026quot;); 为游戏角色添加文本组件 # C++ 添加UTextRenderComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h class UTextRenderComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UTextRenderComponent *HealthTextComponent;	初始化组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/TextRenderComponent.h\u0026quot; // 构造函数 HealthTextComponent = CreateDefaultSubobject\u0026lt;UTextRenderComponent\u0026gt;(\u0026quot;HealthTextComponent\u0026quot;); HealthTextComponent-\u0026gt;SetupAttachment(GetRootComponent()); 每帧更新HealthTextComponent文本 ShootThemUp: Player/STUBaseCharacter.cpp // Tick HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); 检查组件是否成功初始化 # 使用IDE编译时，若运行游戏崩溃，可在IDE中查看断点 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay check(HealthComponent); check(HealthTextComponent); 调整文本组件 # 虚幻编辑器 BP_STUBaseCharacter 查看组件 # HealthComponent和CharacterMovement无层级：二者均无表示，纯逻辑；创建后无需挂在其他组件下面 查看HealthComponent # 调整TextRender组件 # - Tranform Z: 100 Yaw: 180 第三视角：运行时摄像机对着 Character 背面 Text 0 默认值 Horizontal Alignment Center 水平对齐 Text Render Color 深蓝色 文本颜色 效果图 # "}),e.add({id:13,href:"/docs/%E5%88%86%E4%BA%AB/macos%E5%BA%94%E7%94%A8/%E7%BB%88%E7%AB%AF/",title:"终端",description:"iTerm2 # 官网下载 窗口管理 # 快捷键 操作 Command-W 关闭窗口 分屏 # 快捷键 操作 Command-D 左右分屏 Command-Shift-D 上下分屏 Command-[ 切换 Command-] Option-Command-UP 根据方向键切换 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 # 快捷键 操作 Command-T 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right 状态栏 # Status Bar 使能 # Preferences \u0026gt; Profiles \u0026gt; Session 勾选 Status bar enabled 点击 Configure Status Bar , 选择显示组件 设置状态栏位置 # Preferences \u0026gt; Appearence \u0026gt; General \u0026gt; Status bar location 选择 Bottom 配色 # 下载配色 # - 官方提供的配色 : lovelace Afterglow Dracula 导入配色 # Preferences \u0026gt; Profiles \u0026gt; Color \u0026gt; Color Presets \u0026gt; Import 设置窗口大小 # Preferences \u0026gt; Profiles \u0026gt; Window 设置 Columns 和 Rows 透明度 # Preferences \u0026gt; Profiles \u0026gt; Window \u0026gt; Transparency 选择 3 字体 # 下载字体 # - Consolas Victor Mono 配置 # Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Font 选择 Victor Mono 字号选择 14 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 安装Homebrew # /bin/bash -c \u0026quot;$(curl -fsSL https://mirrors.",content:"iTerm2 # 官网下载 窗口管理 # 快捷键 操作 Command-W 关闭窗口 分屏 # 快捷键 操作 Command-D 左右分屏 Command-Shift-D 上下分屏 Command-[ 切换 Command-] Option-Command-UP 根据方向键切换 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 # 快捷键 操作 Command-T 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right 状态栏 # Status Bar 使能 # Preferences \u0026gt; Profiles \u0026gt; Session 勾选 Status bar enabled 点击 Configure Status Bar , 选择显示组件 设置状态栏位置 # Preferences \u0026gt; Appearence \u0026gt; General \u0026gt; Status bar location 选择 Bottom 配色 # 下载配色 # - 官方提供的配色 : lovelace Afterglow Dracula 导入配色 # Preferences \u0026gt; Profiles \u0026gt; Color \u0026gt; Color Presets \u0026gt; Import 设置窗口大小 # Preferences \u0026gt; Profiles \u0026gt; Window 设置 Columns 和 Rows 透明度 # Preferences \u0026gt; Profiles \u0026gt; Window \u0026gt; Transparency 选择 3 字体 # 下载字体 # - Consolas Victor Mono 配置 # Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Font 选择 Victor Mono 字号选择 14 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 安装Homebrew # /bin/bash -c \u0026quot;$(curl -fsSL https://mirrors.ustc.edu.cn/misc/brew-install.sh)\u0026quot; 设置源 # 源代码仓库 export HOMEBREW_BREW_GIT_REMOTE=\u0026quot;https://mirrors.ustc.edu.cn/brew.git\u0026quot; 预编译二进制软件包与软件包元数据文件 export HOMEBREW_BOTTLE_DOMAIN=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-bottles\u0026quot; export HOMEBREW_API_DOMAIN=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-bottles/api\u0026quot; 核心软件仓库 export HOMEBREW_CORE_GIT_REMOTE=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026quot; 写入配置文件, 重新导入 vi ～/.zshrc source ～/.zshrc 管理软件 # 默认下载源码在本地编译安装，通常是不带界面的命令行工具和第三方库; 使用cask选项则安装编译好的软件包，通常是一些带界面的软件 安装/卸载 # brew install --cask emacs # 安装 brew uninstall --cask emacs # 卸载 brew install \u0026lt;package\u0026gt; brew uninstall \u0026lt;package\u0026gt; brew autoremove # 卸载未使用依赖 查看 # brew list # 当前管理的程序 brew search \u0026lt;package\u0026gt; # 查找 brew info \u0026lt;package\u0026gt; # 查看包 代理 # Privoxy 安装Privoxy # 依赖pcre brew install privoxy 配置Privoxy # Privoxy使用端口号8118 vi /usr/local/etc/privoxy/config # 在文件末尾添加以下代码 listen-address 0.0.0.0:8118 forward-socks5 / localhost:1080 . 手动启动Privoxy sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config 查看端口是否被监听 netstat -na | grep 8118 为终端配置代理 # 查询本地代理使用端口 系统偏好设置 \u0026gt; 网络 \u0026gt; Wi-Fi \u0026gt; 高级 \u0026gt; 代理 \u0026gt; 网页代理 / 安全网页代理 配置环境变量 vi ~/.zshrc # 添加以下内容 # 使用本地代理使用端口替换1949 export http_proxy='http://localhost:1949' export https_proxy=$http_proxy # 重载配置文件 source ~/.zshrc oh-my-zsh # 官网 安装oh-my-zsh # sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; 设置主题 # 第三方主题 # 下载Dracula主题 ln -s Dracula/zsh/dracula.zsh-theme ~/.oh-my-zsh/themes/ 设置主题 vi ~/.zshrc # 屏蔽默认主题, 添加以下内容 # ZSH_THEME=\u0026quot;robbyrussell\u0026quot; ZSH_THEME=\u0026quot;dracula\u0026quot; # 载入配置 source ~/.zshrc 官方主题 # 下载时已存放在本地 官方主题展示 使用随机主题 ZSH_THEME=\u0026quot;random\u0026quot; # 随机 "}),e.add({id:14,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/bash/",title:"Shell脚本",description:"花括号的使用 # 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这样使用，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 tr命令 # runoob 去除引号 # tr -d '\u0026quot;' 使用sed sed 's/\\\u0026quot;//g' sed命令 # macOS runoob 安装gsed # brew install gsed 匹配行打印 # p gsed -n \u0026quot;/abc/p\u0026quot; file 修改源文件 # -i gsed -i \u0026quot;/abc/d\u0026quot; file # 匹配行删除 匹配行删除 # d gsed \u0026quot;/abc/d\u0026quot; file 匹配行文本替换 # s 首个匹配项 gsed \u0026quot;s/abc/edf/\u0026quot; file 所有匹配项 g gsed \u0026quot;s/abc/edf/g\u0026quot; file awk命令 # 指定分隔符，打印第3个参数 # awk -F ',' '{print $3}' file命令 # 查看文件编码 # file FILE echo命令 # 输出单行 # var=\u0026quot;hello world!",content:"花括号的使用 # 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这样使用，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 tr命令 # runoob 去除引号 # tr -d '\u0026quot;' 使用sed sed 's/\\\u0026quot;//g' sed命令 # macOS runoob 安装gsed # brew install gsed 匹配行打印 # p gsed -n \u0026quot;/abc/p\u0026quot; file 修改源文件 # -i gsed -i \u0026quot;/abc/d\u0026quot; file # 匹配行删除 匹配行删除 # d gsed \u0026quot;/abc/d\u0026quot; file 匹配行文本替换 # s 首个匹配项 gsed \u0026quot;s/abc/edf/\u0026quot; file 所有匹配项 g gsed \u0026quot;s/abc/edf/g\u0026quot; file awk命令 # 指定分隔符，打印第3个参数 # awk -F ',' '{print $3}' file命令 # 查看文件编码 # file FILE echo命令 # 输出单行 # var=\u0026quot;hello world!\u0026quot; echo $var 输出多行 # echo -e \u0026quot;\\nhello world!\\n\u0026quot; head命令 # 安装coreutils # brew install coreutils 输出文件去掉末尾4行的文本 # ghead -n -4 xx.txt "}),e.add({id:15,href:"/docs/brick/%E7%BB%88%E7%AB%AF/",title:"终端",description:"便签 # 介绍CLI，Terminal，Shell和Prompt视频 shell概念 # 接口 shell，和core相区分，是操作系统的外层。通过Shell程序，可以使用系统服务或其他程序提供的功能。 根据操作系统类别和操作类型，shell可以分为图形shell（图形用户界面）和命令行shell（命令行界面）。 CLI Command-Line Interface 命令行界面 通过文本命令和计算机交互 GUI Graphical User Interface 图形用户界面 通过鼠标操作 早期的操作系统并没有图形用户接口，我们通常说的shell，指的是命令行shel。 终端程序 # Terminal Wrapper Program 在终端输入文本命令 终端程序 说明 iTerm MacOS Windows Terminal Windows Gnome Terminal 使用Gnome作为桌面的Linux自带的终端程序 Hyper Warp 目前MacOS；自动补全，鼠标交互，内置工作流，AI功能 Alacrity 命令解释器 # Shell 程序 终端中运行的程序。接受命令，然后解释并执行。 Shell启动时自动读取配置文件。 Shell 说明 sh Bourne Shell UNIX上的标准shell bash Bourne-Again Shell GNU开发；Linux默认 不完全兼容sh shell，对一些命令和参数进行了扩展 配置文件 ~/.bash_profile zsh 19年之前MacOS默认Bash；之后使用zsh 配置文件 ~/zshrc 第三方框架oh-my-zsh提供其他功能 phish 脚本语言 # 需要解释器，每次运行时都需要解释。 - JavaScript PHP Lua Python C# Shell脚本 # 开发语言 Shell Script 由一连串Shell命令组成，可以指定解释脚本的Shell程序。 命令提示符 # Prompt 命令解释器提供并在终端显示，如当前路径和git信息。 类别 第三方提示 Powerline Starship Power Level 10K Spaceship 第三方框架 oh-my-zsh 提供各种promots，configuration options，aliases，plugins。支持自定义prompt，调整Shell行为 查看Shell信息 # 命令解释器 当前使用的Shell echo $SHELL echo $0 已安装Shell cat /etc/shells Shell操作 # 切换Shell程序 重新打开终端生效 chsh -s /bin/bash 不修改SHELL环境变量 zsh 手动读取配置文件 zsh source ~/.",content:"便签 # 介绍CLI，Terminal，Shell和Prompt视频 shell概念 # 接口 shell，和core相区分，是操作系统的外层。通过Shell程序，可以使用系统服务或其他程序提供的功能。 根据操作系统类别和操作类型，shell可以分为图形shell（图形用户界面）和命令行shell（命令行界面）。 CLI Command-Line Interface 命令行界面 通过文本命令和计算机交互 GUI Graphical User Interface 图形用户界面 通过鼠标操作 早期的操作系统并没有图形用户接口，我们通常说的shell，指的是命令行shel。 终端程序 # Terminal Wrapper Program 在终端输入文本命令 终端程序 说明 iTerm MacOS Windows Terminal Windows Gnome Terminal 使用Gnome作为桌面的Linux自带的终端程序 Hyper Warp 目前MacOS；自动补全，鼠标交互，内置工作流，AI功能 Alacrity 命令解释器 # Shell 程序 终端中运行的程序。接受命令，然后解释并执行。 Shell启动时自动读取配置文件。 Shell 说明 sh Bourne Shell UNIX上的标准shell bash Bourne-Again Shell GNU开发；Linux默认 不完全兼容sh shell，对一些命令和参数进行了扩展 配置文件 ~/.bash_profile zsh 19年之前MacOS默认Bash；之后使用zsh 配置文件 ~/zshrc 第三方框架oh-my-zsh提供其他功能 phish 脚本语言 # 需要解释器，每次运行时都需要解释。 - JavaScript PHP Lua Python C# Shell脚本 # 开发语言 Shell Script 由一连串Shell命令组成，可以指定解释脚本的Shell程序。 命令提示符 # Prompt 命令解释器提供并在终端显示，如当前路径和git信息。 类别 第三方提示 Powerline Starship Power Level 10K Spaceship 第三方框架 oh-my-zsh 提供各种promots，configuration options，aliases，plugins。支持自定义prompt，调整Shell行为 查看Shell信息 # 命令解释器 当前使用的Shell echo $SHELL echo $0 已安装Shell cat /etc/shells Shell操作 # 切换Shell程序 重新打开终端生效 chsh -s /bin/bash 不修改SHELL环境变量 zsh 手动读取配置文件 zsh source ~/.zshrc 指定Shell脚本的命令解释器 #!/bin/bash "}),e.add({id:16,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/",title:"Git",description:"代码管理, 版本控制 安装 # macOS 方法一: Xcode自带 # 方法二: 使用homebrew安装较新版本 # brew install git 方法三: 下载源码, 编译安装 # 官网下载git-2.41.0.tar.gz make install 验证 # git -v 配置 # 查看Git配置 # git config --list 配置Git账户 # git config --global user.name \u0026quot;enjoy61\u0026quot; git config --global user.email \u0026quot;enjoy61@protonmail.com\u0026quot; 配置SSH # 生成密钥 ssh-keygen cat ~/.ssh/id_rsa.pub 拷贝公钥到Github 代理 # 设置 # 使用代理端口替换1949 git config --global https.proxy https://localhost:1949 git config --global http.proxy http://localhost:1949 取消 git config --global --unset http.",content:"代码管理, 版本控制 安装 # macOS 方法一: Xcode自带 # 方法二: 使用homebrew安装较新版本 # brew install git 方法三: 下载源码, 编译安装 # 官网下载git-2.41.0.tar.gz make install 验证 # git -v 配置 # 查看Git配置 # git config --list 配置Git账户 # git config --global user.name \u0026quot;enjoy61\u0026quot; git config --global user.email \u0026quot;enjoy61@protonmail.com\u0026quot; 配置SSH # 生成密钥 ssh-keygen cat ~/.ssh/id_rsa.pub 拷贝公钥到Github 代理 # 设置 # 使用代理端口替换1949 git config --global https.proxy https://localhost:1949 git config --global http.proxy http://localhost:1949 取消 git config --global --unset http.proxy git config --global --unset https.proxy 中文乱码 # git config --global core.quotepath false 初始化项目 # 已在Github创建项目 场景一: 从Github克隆项目，上游信息自动配置 # git clone git@github.com:enjoy61/even.git 查看远端信息 # git remote -v 场景二: 手动配置上游信息 # git init git remote add cute git@github.com:enjoy61/even.git # cute为上游别名 git fetch cute # 拉取上游内容，和Github项目同步 场景三: 首次提交本地项目到远端 # git init git add README.md # 添加管理文件 git commit -m \u0026quot;first commit\u0026quot; git branch -M main git remote add origin git@github.com:enjoy61/even.git git push -u origin main 子模块管理 # 添加子模块 # git submodule add git@github.com:enjoy61/hugo-theme-even.git themes/even 从远端拉取项目时亦拉取子模块项目 # git clone --recursive git@github.com:enjoy61/even.git 设置项目同步链接 # SSH git remote set-url cute git@github.com:enjoy61/even.git HTTPS push时需要验证，Github不再支持用户名和密码 git remote set-url cute https://github.com/enjoy61/even.git 文件托管 # 添加 # git add file # 指定文件 git add -A # 所有文件 删除 # git rm file 查看托管文件状态 # git diff 查看项目内文件状态 # git status 提交 # 提交当前改动 # git commit -m \u0026quot;first commit\u0026quot; 推送到远端 # git push 查看提交记录 # git log 删除历史提交 # # 查看提交记录 git log # 最新提交 F E D C B，要删除F和E，记录D # 设置回溯目标 git rebase -i D # 将F E的pick改为drop # 检查设置是否生效 git log # 查看当前提交 D C B # 同步到远端 git push cute master --force # 上游cute 分支master 存在多个文件添加/删除/修改，在上次提交的基础上再次提交 # 不建议如此操作，提交前建议检阅改动 项目文件夹一式两份，A和A.BAK, 项目新版本B 删除文件夹A内所有代码 不会删除.git，提交和同步记录均保留 rm -rf A/* 将B内的所有文件拷贝到A 不会拷贝.git cp -r B A 打开文件夹A, 再次提交 git add -A git commit -m \u0026quot;Comments\u0026quot; git push 提交规范 # \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; \u0026lt;body\u0026gt; \u0026lt;footer\u0026gt; 标题行 # 必填 类型 # type 标识 feat feature 新功能 fix 修复bug docs 文档 style 格式，如.clang-format refactor 重构 test 测试用例 build 项目构建和依赖项 revert 回退 ci 持续集成 perf 性能优化 merge 代码合并 sync 同步主线或分支的bug chore 其他类型 release 新版本发布 workflow 工作流 受到提交影响的范围 # scope 概述 # subject 动词开头 如果用英文，使用第一人称现在时，首字母小写 结尾不加句号 正文 # body 具体修改内容, 可多行 页脚注释 # footer 备注 分支 # 当前分支和分支列表 # git branch -a 切换分支 # git checkout main 创建分支 # git branch master 本地创建新分支后, 同步到远端 # git push --set-upstream origin master 创建并切换 # git checkout -b iss53 删除分支 # 本地 git branch -d iss51 上游 git push origin -d iss51 重命名分支 # 未推送到远端, 重命名即可 # git branch -m oldName newName 已推送过远端 # 重命名本地分支 git branch -m oldName newName 删除远端分支 git push --delete origin oldName 将本地分支推送到远端 git push origin newName 将本地分支和远端分支关联 git branch --set-upstream-to origin/newName 分支合并 # 合并过程中可能会产生冲突 git-scm 在iss53分支上开发新功能 git checkout master # 主分支 git checkout -b iss53 vim index.html git commit -a -m 'added a new footer [issue 53]' 在hotfix分支上解决问题 git checkout master # 主分支 git checkout -b hotfix vim index.html git commit -a -m 'fixed the broken email address' 在主分支上合并解决方案，删除hotfix分支 git checkout master git merge hotfix git branch -d hotfix 继续在分支iss53上开发新功能 git checkout iss53 vim index.html git commit -a -m 'finished the new footer [issue 53]' 合并新功能到主分支，删除iss53分支 git checkout master git merge iss53 git branch -d iss53 "}),e.add({id:17,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E4%BD%BF%E7%94%A8hugo+github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/",title:"使用Hugo+GitHub搭建静态博客",description:"说明 # - Github Pages 使用Github提供的免费服务部署静态博客 Hugo 本地构建静态网页 anubis 主题 安装Hugo # Github 官网 方法一: 使用go安装 # Windows 安装go 官网下载 环境变量 # go export PATH=/usr/local/go/bin:$PATH export GOROOT=/usr/local/go export GOPATH=/Users/USERNAME/go export GOBIN=/Users/USERNAME/go/bin # go安装的软件 export PATH=$GOBIN:$PATH 安装hugo 如若遇上网络不佳, 配置代理 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off 安装并验证 go install github.com/gohugoio/hugo@latest hugo env -v 部分主题需用hugo_extended提供的支持 方法二: 使用homebrew安装 # macOS brew install hugo 创建站点项目 # 新建站点 hugo new site /site/path 站点项目结构 文件 说明 config.",content:"说明 # - Github Pages 使用Github提供的免费服务部署静态博客 Hugo 本地构建静态网页 anubis 主题 安装Hugo # Github 官网 方法一: 使用go安装 # Windows 安装go 官网下载 环境变量 # go export PATH=/usr/local/go/bin:$PATH export GOROOT=/usr/local/go export GOPATH=/Users/USERNAME/go export GOBIN=/Users/USERNAME/go/bin # go安装的软件 export PATH=$GOBIN:$PATH 安装hugo 如若遇上网络不佳, 配置代理 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off 安装并验证 go install github.com/gohugoio/hugo@latest hugo env -v 部分主题需用hugo_extended提供的支持 方法二: 使用homebrew安装 # macOS brew install hugo 创建站点项目 # 新建站点 hugo new site /site/path 站点项目结构 文件 说明 config.toml 配置文件；yaml格式也可以 content 存放blog；支持md和org theme 存放主题 public 生成的静态页面；同步到Github项目 archetypes 文章模版 新建博客 所在目录为 ./content/post hugo new post/first-blog.org 使用主题anubis # anubis on hugo anubis on github 将主题作为项目子模块 git init git submodule add https://github.com/mitrichius/hugo-theme-anubis.git themes/anubis 使用anubis提供的模板 ./themes/anubis/exampleSite/ cp themes/anubis/exampleSite/config.toml . cp themes/anubis/exampleSite/content/. content 主题说明 提供标签(tags)和分类(categories)功能, 提供文章列表(archives) 文章存放到content/post目录下 文章模板 yaml \u0026mdash; author: \u0026ldquo;author\u0026rdquo; title: \u0026ldquo;article title\u0026rdquo; date: \u0026ldquo;2023-03-17\u0026rdquo; description: \u0026ldquo;article description\u0026rdquo; tags: [ \u0026ldquo;tag-1\u0026rdquo;, \u0026ldquo;tag-2\u0026rdquo;, ] categories: [ \u0026ldquo;category\u0026rdquo;, ] \u0026mdash; 简单介绍 \u0026lt;!\u0026ndash;more\u0026ndash;\u0026gt; 正文 构建静态网页 # 选项 说明 构建或测试 \u0026ndash;theme=anubis 设置主题 -t anubis both \u0026ndash;watch 修改文件后自动刷新浏览器 -w server \u0026ndash;buildDrafts 包括标记为draft的笔记 -D both \u0026ndash;buildFuture 包括新发布笔记；检查date选项 -F both \u0026ndash;baseUrl=\u0026quot;http://enjoy61.github.io/\u0026quot; 未配置编译，GithubPage部署会丢失样式 both \u0026ndash;cleanDestinationDir 将public文件夹中不再使用的文件删除 hugo 本地测试 # 查询server选项 参考 hugo help server 访问 http://localhost:1313/ hugo server --theme=anubis --watch # hugo server 构建静态页面 # 生成文件路径 ./public/ hugo --theme=anubis --baseUrl=\u0026quot;https://enjoy61.github.io/\u0026quot; # hugo 在Github创建项目 # 创建仓库 仓库名为enjoy61.github.io 使用Github Pages提供的免费服务需公开项目 测试服务: 为github设置主题 添加_config.yaml文件 remote_theme: pages-themes/midnight@v0.2.0 将public文件夹提交到仓库 "}),e.add({id:18,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E5%9B%BE%E7%89%87%E6%B0%B4%E5%B9%B3%E5%BE%AA%E7%8E%AF%E6%BB%9A%E5%8A%A8/",title:"图片水平循环滚动",description:"便签 # - 环状滚动 1. html格式 2. css样式 3. transform: translateX 多个li显示在一行 display: inline-block 基础html格式+css样式 通过js设置css参数 1. element.style.setProperty(\u0026rsquo;transform\u0026rsquo;, \u0026rsquo;translateX(1px)') 2. element.style.getPropertyValue(\u0026rsquo;transform') 3. element.style.cssText = \u0026rsquo;left: 10px' 4. 猜测：通过js获取的css参数, 不来自css文件, 而是html代码的设置 css Position 1. li标签不自动换行: absolute, fixed 2. 计算绝对位置 样式 # css - imageList height 滚动框高度, 滚动框之间的边界 overflow 向右滚动时, 溢出不触发滚动条 perspective 1. 滚动框左右的边界 2. 垂直滚动时, 滚动框跟随滚动 li width 图片宽度 padding 第一个参数: top边界, 滚动框之间的间隔 第二个参数: 嵌套时长宽边界 position 1. 多个li不自动换行 2. 采用绝对位置 3. fixed或absolute都可 display li显示在一行 .",content:`便签 # - 环状滚动 1. html格式 2. css样式 3. transform: translateX 多个li显示在一行 display: inline-block 基础html格式+css样式 通过js设置css参数 1. element.style.setProperty(\u0026rsquo;transform\u0026rsquo;, \u0026rsquo;translateX(1px)') 2. element.style.getPropertyValue(\u0026rsquo;transform') 3. element.style.cssText = \u0026rsquo;left: 10px' 4. 猜测：通过js获取的css参数, 不来自css文件, 而是html代码的设置 css Position 1. li标签不自动换行: absolute, fixed 2. 计算绝对位置 样式 # css - imageList height 滚动框高度, 滚动框之间的边界 overflow 向右滚动时, 溢出不触发滚动条 perspective 1. 滚动框左右的边界 2. 垂直滚动时, 滚动框跟随滚动 li width 图片宽度 padding 第一个参数: top边界, 滚动框之间的间隔 第二个参数: 嵌套时长宽边界 position 1. 多个li不自动换行 2. 采用绝对位置 3. fixed或absolute都可 display li显示在一行 .imageList { height: 158px; overflow: hidden; perspective: 2000px; ul li { width: 200px; padding: 2px 2px; position: fixed; display: inline-block; // 去除小黑点 // overflow: hidden; // 四个角圆润 // border-radius: 5px; } } 图片存放在无序列表, 使用id标识 # html scrollpic1向右滚动, scrollpic2向左滚动 \u0026lt;div class=\u0026quot;imageList\u0026quot; id=\u0026quot;scrollpic1\u0026quot;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;1.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;2.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;3.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;4.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;5.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;6.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;1.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;2.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;3.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;4.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;5.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;6.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;imageList\u0026quot; id=\u0026quot;scrollpic2\u0026quot;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;7.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;8.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;9.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;10.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;11.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;12.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;7.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;8.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;9.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;10.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;11.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;12.jpg\u0026quot; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 图片水平循环滚动 # 进入判断 # document.addEventListener('DOMContentLoaded', () =\u0026gt; { const pics1 = document.querySelectorAll('#scrollpic1 li'); const pics2 = document.querySelectorAll('#scrollpic2 li'); if (!pics1.length || !pics2.length) return; // 后续处理 }); 图片组规格 # 单张图片宽度200px(ul li width) 考虑到图片间隔: const PicWidth = 205; 一组12张图, 实际滚动框宽度: 205px * 12 = 2460px 考虑到左右溢出和窗口宽度, 图片水平位移范围: const FrontEnd = 2000; // \u0026gt; window.innerWidth const BackEnd = -460; 步长 # const Step = 0.2; 游标 # 范围 向右滚动 0 ~ (FrontEnd - BackEnd) 向左滚动 (BackEnd - FrontEnd) ~ 0 定义游标 # 全局变量 let Cur1 = 0; let Cur2 = 0; 开启循环定时器, 更新游标 # const ScrollTimerInterval = 5; const scrollTimer = window.setInterval(function () { Cur1 = (Cur1 + Step) % (FrontEnd - BackEnd); // 向右滚动 Cur2 = (Cur2 - Step) % (FrontEnd - BackEnd); // 向左滚动 }, ScrollTimerInterval); 实现函数: 根据游标实时位置, 平移图片组成员 # translatePic 参数 # - pics 图片组 cur 游标 遍历图片组 # function translatePic(pics, cur) { for (let i = 0; i \u0026lt; pics.length; ++i) { // 处理成员 } } 根据成员的相对位置计算平移 # - 向右滚动 cur 0 ~ (FrontEnd - BackEnd) 成员偏移 0 ~ (FrontEnd - BackEnd) thisCur 0 ~ 2 * (FrontEnd - BackEnd) 向左滚动 cur (BackEnd - FrontEnd) ~ 0 成员偏移 0 ~ (FrontEnd - BackEnd) thisCur (BackEnd - FrontEnd) ~ (FrontEnd - BackEnd) 控制成员平移范围
thisCur范围应该为BackEnd ~ FrontEnd let thisCur = cur + i * PicWidth; if (thisCur \u0026gt; FrontEnd) thisCur -= FrontEnd - BackEnd; else if (thisCur \u0026lt; BackEnd) thisCur += FrontEnd - BackEnd; 平移成员
const value = 'translateX(' + thisCur + 'px)'; pics[i].style.setProperty('transform', value); 完整代码 # const PicWidth = 205; const FrontEnd = 2000; const BackEnd = -460; const Step = 0.2; const ScrollTimerInterval = 5; function translatePic(pics, cur) { for (let i = 0; i \u0026lt; pics.length; ++i) { let thisCur = cur + i * PicWidth; if (thisCur \u0026gt; FrontEnd) thisCur -= FrontEnd - BackEnd; else if (thisCur \u0026lt; BackEnd) thisCur += FrontEnd - BackEnd; const value = 'translateX(' + thisCur + 'px)'; pics[i].style.setProperty('transform', value); } } let Cur1 = 0; let Cur2 = 0; document.addEventListener('DOMContentLoaded', () =\u0026gt; { const pics1 = document.querySelectorAll('#scrollpic1 li'); const pics2 = document.querySelectorAll('#scrollpic2 li'); if (!pics1.length || !pics2.length) return; const scrollTimer = window.setInterval(function () { Cur1 = (Cur1 + Step) % (FrontEnd - BackEnd); // 0 ~ (FrontEnd - BackEnd) Cur2 = (Cur2 - Step) % (FrontEnd - BackEnd); // (BackEnd - FrontEnd) ~ 0 translatePic(pics1, Cur1); translatePic(pics2, Cur2); }, ScrollTimerInterval); }); `}),e.add({id:19,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BB%E7%BC%96%E8%BE%91%E5%99%A8/%E7%A2%B0%E6%92%9E%E9%80%89%E9%A1%B9/",title:"碰撞选项",description:"说明 # Details \u0026gt; Collision 碰撞预设 # Collision Presets 默认面板 # Default 自定义面板 # Custom 可以自定义各种碰撞属性 碰撞使能 # Collision Enabled - No Collision 不产生碰撞 Query Only (No Physics Collision) 身体没有使能Physical Simulation, 或者我们只关注给定物体的Logical Trace Physics Only (No Query Collision) 身体使能Physical Simulation Collision Enabled (Query and Physics) Physical Simulation + Logical Trace 物体类型 # Object Type 设置自己的物体类型 碰撞反馈 # Collision Responses 产生碰撞时, 如何给出反馈; 通过Interaction Matrix实现 反馈类型 Ignore 不产生碰撞 Overlap 重叠: 产生交叉事件 Block 阻拦 按轨迹类型分类",content:`说明 # Details \u0026gt; Collision 碰撞预设 # Collision Presets 默认面板 # Default 自定义面板 # Custom 可以自定义各种碰撞属性 碰撞使能 # Collision Enabled - No Collision 不产生碰撞 Query Only (No Physics Collision) 身体没有使能Physical Simulation, 或者我们只关注给定物体的Logical Trace Physics Only (No Query Collision) 身体使能Physical Simulation Collision Enabled (Query and Physics) Physical Simulation + Logical Trace 物体类型 # Object Type 设置自己的物体类型 碰撞反馈 # Collision Responses 产生碰撞时, 如何给出反馈; 通过Interaction Matrix实现 反馈类型 Ignore 不产生碰撞 Overlap 重叠: 产生交叉事件 Block 阻拦 按轨迹类型分类
Trace Responses 获取何种Logical Trace信息 - Visibility Camera 按物体类型分类
Object Responses - WorldStatic WorldDynamic Pawn \u0026hellip; 产生碰撞事件 # Simulation Generates Hit Events 勾选则触发碰撞事件, 可以获取碰撞信息 产生重叠事件 # Generate Overlap Events 勾选则触发重叠事件, 可以在蓝图中对该类型事件进行处理 `}),e.add({id:20,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%BB%99%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A3%85%E8%BD%BD%E6%AD%A6%E5%99%A8/",title:"给游戏角色装载武器",description:"概览 # 骨骼网格体组件 USkeletalComponent 武器Actor对象 动态创建，并附加到Character 说明 Launcher 发射导弹 Rifle 发射子弹(shoot regular cartridges) 给骨骼网格体添加挂载点 在可变换组件上挂载Actor 导入资产 # 虚幻编辑器 之前将资产导入到Content/ExternalContent/Animation，有两点需注意 资产之前存在相互引用，这个在Migrate过程中，不一定会全无问题 我们选择Migrate ShooterGame/Content/Animations/TTP_Animations ，而实际导出有多个文件夹，里面的内容都和 TTP_Animations 有关 本节需要Migrate的武器资产，其相关内容甚至和之前的内容有重叠，和之前一样, 在ExternalContent下单独创建一个文件夹，作为章节资产汇总 迁移资产 # ShooterGame 选中Content/Weapons \u0026gt; Migrate 相关文件分别存放在Characters，Environment和Weapons中 保存到ShootThemUp/Content 导入到ShootThemUp # 创建ExternalContent/Weapon，并设置文件夹颜色 将资产移动到ExternalContent/Weapon 效果图 初始化Weapon/STUBaseWeapon # 创建Weapon/STUBaseWeapon # 虚幻编辑器 Actor 公有类 设置头文件路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot; }); 调整框架 # C++ 基础函数 操作 构造函数 每帧调用置为false Tick 屏蔽 BeginPlay - ShootThemUp: Weapon/STUBaseWeapon.",content:"概览 # 骨骼网格体组件 USkeletalComponent 武器Actor对象 动态创建，并附加到Character 说明 Launcher 发射导弹 Rifle 发射子弹(shoot regular cartridges) 给骨骼网格体添加挂载点 在可变换组件上挂载Actor 导入资产 # 虚幻编辑器 之前将资产导入到Content/ExternalContent/Animation，有两点需注意 资产之前存在相互引用，这个在Migrate过程中，不一定会全无问题 我们选择Migrate ShooterGame/Content/Animations/TTP_Animations ，而实际导出有多个文件夹，里面的内容都和 TTP_Animations 有关 本节需要Migrate的武器资产，其相关内容甚至和之前的内容有重叠，和之前一样, 在ExternalContent下单独创建一个文件夹，作为章节资产汇总 迁移资产 # ShooterGame 选中Content/Weapons \u0026gt; Migrate 相关文件分别存放在Characters，Environment和Weapons中 保存到ShootThemUp/Content 导入到ShootThemUp # 创建ExternalContent/Weapon，并设置文件夹颜色 将资产移动到ExternalContent/Weapon 效果图 初始化Weapon/STUBaseWeapon # 创建Weapon/STUBaseWeapon # 虚幻编辑器 Actor 公有类 设置头文件路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot; }); 调整框架 # C++ 基础函数 操作 构造函数 每帧调用置为false Tick 屏蔽 BeginPlay - ShootThemUp: Weapon/STUBaseWeapon.h ShootThemUp: Weapon/STUBaseWeapon.cpp 添加骨骼网格体组件 # C++ 添加数据成员 protected ShootThemUp: Weapon/STUBaseWeapon.h class USkeletalMeshComponent; UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USkeletalMeshComponent *WeaponMeshComponent; 初始化组件 ShootThemUp: Weapon/STUBaseWeapon.cpp // 构造函数 WeaponMeshComponent = CreateDefaultSubobject\u0026lt;USkeletalMeshComponent\u0026gt;(\u0026quot;WeaponMeshComponent\u0026quot;); SetRootComponent(WeaponMeshComponent); 创建BP_STUBaseWeapon # 虚幻编辑器 创建Content/Weapon 创建BP_STUBaseWeapon，保存到Content/Weapon 为WeaponMeshComponent绑定Rifle 因为武器很小，设置Camera Speed为1 在游戏角色骨骼网格体上设置武器挂载点 # 虚幻编辑器 给骨骼网格体添加挂载点 在代码中动态创建武器，并挂载到游戏角色 # C++ 添加武器类型属性 # protected ShootThemUp: Player/STUBaseCharacter.h class ASTUBaseWeapon; UPROPERTY(EditDefaultsOnly) TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponClass; ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Weapon/STUBaseWeapon.h\u0026quot; 动态创建武器 # 在可变换组件上挂载Actor - Engine/World.h 使用了UWorld::SpawnActor，所以我认为应该包含；但没包含编译通过了 Components/SkeletalMeshComponent.h AttachToComponent的第一个参数是USenceComponent类型，而我们传参其派生类USkeletalComponent类型 函数实现 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;Components/SkeletalMeshComponent.h\u0026quot; // 在BeginPlay中调用 void ASTUBaseCharacter::SpawnWeapon() { if (!GetWorld()) return; const auto Weapon = GetWorld()-\u0026gt;SpawnActor\u0026lt;ASTUBaseWeapon\u0026gt;(WeaponClass); if (Weapon) { FAttachmentTransformRules AttachmentRules(EAttachmentRule::SnapToTarget, false); Weapon-\u0026gt;AttachToComponent(GetMesh(), AttachmentRules, \u0026quot;WeaponSocket\u0026quot;); } } 函数声明 private ShootThemUp: Player/STUBaseCharacter.h 查看 # 虚幻编辑器 配置BP_STUBaseCharacter的WeaponClass属性，BP_STUBaseWeapon 效果图 "}),e.add({id:21,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%88%9D%E5%A7%8B%E5%8C%96shootthemup%E9%A1%B9%E7%9B%AE/",title:"初始化ShootThemUp项目",description:"说明 # 虚幻编辑器 将 ShooterGame 作为内容包，基于此开发 ShootThemUp 。好比室内设计师提供游戏资料，我们在此之上开发游戏。 创建ShootThemUp项目 # Blank Blueprint 配置ShootThemUp # 添加版权信息 # 项目设置 \u0026gt; Project \u0026gt; Description \u0026gt; Legal \u0026gt; Copyright Notice Shoot Them Up Game, All Rights Reserved. 关卡设置 # 添加关卡文件夹 Content/Levels 创建关卡 新建关卡 选择 Basic 保存到Content/Levels/，命名为DefaultMap 设置 EditorStartupMap 和 GameDefaultMap 使用 DefaultMap 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 从ShooterGame导入资产 # ShooterGame导出 # 打开ShooterGame项目 \u0026gt; 在内容浏览器选中Content/Animations/TTP_Animations，右键 \u0026gt; Migrate 取消Sounds勾选 默认勾选的文件夹里的内容都与 TTP_Animations 相关 保存到 ShootThemUp/Content 目录下 不能直接迁移到 5.",content:"说明 # 虚幻编辑器 将 ShooterGame 作为内容包，基于此开发 ShootThemUp 。好比室内设计师提供游戏资料，我们在此之上开发游戏。 创建ShootThemUp项目 # Blank Blueprint 配置ShootThemUp # 添加版权信息 # 项目设置 \u0026gt; Project \u0026gt; Description \u0026gt; Legal \u0026gt; Copyright Notice Shoot Them Up Game, All Rights Reserved. 关卡设置 # 添加关卡文件夹 Content/Levels 创建关卡 新建关卡 选择 Basic 保存到Content/Levels/，命名为DefaultMap 设置 EditorStartupMap 和 GameDefaultMap 使用 DefaultMap 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 从ShooterGame导入资产 # ShooterGame导出 # 打开ShooterGame项目 \u0026gt; 在内容浏览器选中Content/Animations/TTP_Animations，右键 \u0026gt; Migrate 取消Sounds勾选 默认勾选的文件夹里的内容都与 TTP_Animations 相关 保存到 ShootThemUp/Content 目录下 不能直接迁移到 5.1.1/ShootThemUp/Content/ExternalContent ，虚幻引擎会检查目录，要求这些资产的上级目录是 Content ，即使根目录是 Content 也无法通过检查 ShootThemUp导入 # 添加外部资产文件夹和本章资产文件夹 Content/ExternalContent Content/ExternalContent/Animation 通过虚幻编辑器，将 Content 目录下的 Animations Characters Environment 移动到 ExternalContent/Animation 目录下 不能在外部直接将三个文件夹移动到目的文件夹中，会导致资产之间的相互引用路径出错 为 ExternalContent 设置文件夹颜色 选中Content/ExternalContent，右键 \u0026gt; Set Color 为 ExternalContent/Animation 设置文件夹颜色 效果图 基于蓝图创建C++项目 # 添加C++类即可 创建蓝图项目的时间开销明显小于创建C++项目的时间开销 创建GameModeBase类 # Tools \u0026gt; New C++ Class.. STUGameModeBase 不设置类类型 Content同级目录出现C++ Classes文件夹 设置关卡使用STUGameModeBase # 查看项目源码中的版权信息 # 不使用预编译头文件 # ShootThemUp: ShootThemUp.Build.cs // PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PCHUsage = PCHUsageMode.NoPCHs; 脚本 # 编译项目 # Build.sh #!/bin/bash Project=\u0026quot;Projects/5.1.1/ShootThemUp/ShootThemUp.uproject\u0026quot; BuildScript=\u0026quot;EpicGames/UE_5.1/Engine/Build/BatchFiles/Mac/Build.sh\u0026quot; Target=\u0026quot;ShootThemUpEditor\u0026quot; $BuildScript $Target Mac Development $Project -waitmutex -NoHotReload 打开虚幻编辑器 # Editor.sh #!/bin/bash Project=\u0026quot;Projects/5.1.1/ShootThemUp/ShootThemUp.uproject\u0026quot; UnrealEditor=\u0026quot;EpicGames/UE_5.1/Engine/Binaries/Mac/UnrealEditor.app\u0026quot; open -a $UnrealEditor $Project 生成项目文件 # ProjectFiles.sh #!/bin/bash Project=\u0026quot;Projects/5.1.1/ShootThemUp/ShootThemUp.uproject\u0026quot; GenerateProjectFilesScript=\u0026quot;EpicGames/UE_5.1/Engine/Build/BatchFiles/Mac/GenerateProjectFiles.sh\u0026quot; EngineCCDst=\u0026quot;EpicGames/UE_5.1/compile_commands.json\u0026quot; EngineCCSrc=\u0026quot;EpicGames/UE_5.1/.vscode/compileCommands_Default.json\u0026quot; ProjectCCDst=\u0026quot;Projects/5.1.1/ShootThemUp/compile_commands.json\u0026quot; ProjectCCSrc=\u0026quot;Projects/5.1.1/ShootThemUp/.vscode/compileCommands_ShootThemUp.json\u0026quot; GenerateXCode() { $GenerateProjectFilesScript -projectfiles -project=$Project -game -rocket -progress -XCodeProjectFiles } GenerateVSCode() { $GenerateProjectFilesScript -projectfiles -project=$Project -game -rocket -progress -VSCode cp $EngineCCSrc $EngineCCDst cp $ProjectCCSrc $ProjectCCDst } # GenerateXCode GenerateVSCode "}),e.add({id:22,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AF%B9%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E9%80%A0%E6%88%90%E4%BC%A4%E5%AE%B3/",title:"对游戏角色造成伤害",description:"概览 # C++ 对游戏角色造成伤害 # 虚幻引擎提供一组函数，用来对Actor造成伤害 若有注册伤害处理服务, Actor受到伤害时触发处理函数 本节在Tick函数中持续对游戏角色造成伤害 伤害处理服务 # 我们在Actor提供的数据成员处注册伤害处理函数, 在处理函数中减少游戏角色生命值 持续对游戏角色造成伤害 # C++ 伤害来源是自己 ShootThemUp: Player/STUBaseCharacter.cpp // Tick TakeDamage(0.1f, FDamageEvent{}, GetController(), this); 伤害处理服务 # AActor定义了委托类型FTakeAnyDamageSignature，并有该类型数据成员AActor::OnTakeAnyDamage 我们通过数据成员注册伤害处理服务 处理函数签名 void handler(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 该委托类型支持蓝图 触发伤害处理函数时，会传入UDamageType 注册伤害机制的委托服务 # C++ 搭建框架 # 添加空函数 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) {} 注册伤害处理函数 ShootThemUp: Components/STUHealthComponent.",content:"概览 # C++ 对游戏角色造成伤害 # 虚幻引擎提供一组函数，用来对Actor造成伤害 若有注册伤害处理服务, Actor受到伤害时触发处理函数 本节在Tick函数中持续对游戏角色造成伤害 伤害处理服务 # 我们在Actor提供的数据成员处注册伤害处理函数, 在处理函数中减少游戏角色生命值 持续对游戏角色造成伤害 # C++ 伤害来源是自己 ShootThemUp: Player/STUBaseCharacter.cpp // Tick TakeDamage(0.1f, FDamageEvent{}, GetController(), this); 伤害处理服务 # AActor定义了委托类型FTakeAnyDamageSignature，并有该类型数据成员AActor::OnTakeAnyDamage 我们通过数据成员注册伤害处理服务 处理函数签名 void handler(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 该委托类型支持蓝图 触发伤害处理函数时，会传入UDamageType 注册伤害机制的委托服务 # C++ 搭建框架 # 添加空函数 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) {} 注册伤害处理函数 ShootThemUp: Components/STUHealthComponent.cpp #include \u0026quot;GameFramework/Actor.h\u0026quot; // BeginPlay AActor *TheOwner = GetOwner(); if (TheOwner) { TheOwner-\u0026gt;OnTakeAnyDamage.AddDynamic(this, \u0026amp;USTUHealthComponent::OnTakeAnyDamage); } 添加函数声明 private ShootThemUp: Components/STUHealthComponent.h UFUNCTION() void OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 实现处理函数 # ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage Health -= Damage; 差不多一秒10帧，即1s调用十次处理函数；Health减为0之后，继续减少 "}),e.add({id:23,href:"/docs/%E5%88%86%E4%BA%AB/emacs/org-mode/",title:"org-mode",description:"便签 # The Org Manual 样式 # 删除线 # Content +Content+ 下划线 # Content _Content_ 文本块 # Content =test= ~test~ 斜体 # Content /Content/ 加粗 # Content *Content* 分隔线 # ----- 标题 # 标题间移动 # - 上一个 C-c C-p 下一个 C-c C-n 去到上级标题 # C-c C-u 同级标题间移动 # - 上一个 C-c C-b 下一个 C-c C-f 创建标题 # - 同级标题 C-RET 同级标题 / 列表项 M-RET 同级TODO标题 M-S-RET 标题、列表项转换 # - 标题转换为列表项 C-c - 文本、列表项转换为标题 C-c * 标题和列表项升降级 # - 降级 M-LEFT 升级 M-RIGHT TODO标题状态切换 # \u0026gt; 普通标题 \u0026gt; TODO \u0026gt; DONE 所属标题状态切换 # C-c C-t 处于标题行 # - S-LEFT 逆向 S-RIGHT 逆向 文本显示 # 进入预览模式，显示一级标题 # C-c C-j 标题展开 # \u0026gt; 只展开第一个一级标题 \u0026gt; 展开所有标题 \u0026gt; 展开全部内容 S-TAB 子树 # - 删除子树 C-c C-x C-w 拷贝子树 C-c C-x M-w 降级 M-S-LEFT 升级 M-S-RIGHT 模板 # Structure Templates 插入模板 # - 快捷键 C-c C-, 函数 org-insert-structure-template 不再支持 \u0026lt;s TAB 模板样式 # 代码块 # #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;Hello World!",content:"便签 # The Org Manual 样式 # 删除线 # Content +Content+ 下划线 # Content _Content_ 文本块 # Content =test= ~test~ 斜体 # Content /Content/ 加粗 # Content *Content* 分隔线 # ----- 标题 # 标题间移动 # - 上一个 C-c C-p 下一个 C-c C-n 去到上级标题 # C-c C-u 同级标题间移动 # - 上一个 C-c C-b 下一个 C-c C-f 创建标题 # - 同级标题 C-RET 同级标题 / 列表项 M-RET 同级TODO标题 M-S-RET 标题、列表项转换 # - 标题转换为列表项 C-c - 文本、列表项转换为标题 C-c * 标题和列表项升降级 # - 降级 M-LEFT 升级 M-RIGHT TODO标题状态切换 # \u0026gt; 普通标题 \u0026gt; TODO \u0026gt; DONE 所属标题状态切换 # C-c C-t 处于标题行 # - S-LEFT 逆向 S-RIGHT 逆向 文本显示 # 进入预览模式，显示一级标题 # C-c C-j 标题展开 # \u0026gt; 只展开第一个一级标题 \u0026gt; 展开所有标题 \u0026gt; 展开全部内容 S-TAB 子树 # - 删除子树 C-c C-x C-w 拷贝子树 C-c C-x M-w 降级 M-S-LEFT 升级 M-S-RIGHT 模板 # Structure Templates 插入模板 # - 快捷键 C-c C-, 函数 org-insert-structure-template 不再支持 \u0026lt;s TAB 模板样式 # 代码块 # #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;Hello World!\u0026quot; \u0026lt;\u0026lt; endl; return 0; } 需填写编程语言 #+begin_src \u0026lt;language\u0026gt; #+end_src 文本块 # Hello World! #+begin_example #+end_example 引用 # Hello World! #+begin_quote #+end_quote 代码块编辑 # 要求能识别编程语言 - 插入代码框 C-c C-, s 在新窗口编辑代码 C-c ' 保存修改 C-x C-s 关闭编辑窗口(未保存丢失) C-c C-k 执行 C-c C-c 对选中内容注释/去注释 M-； 计时 # 精确到分钟 - 开始 C-c C-x C-i 停止 C-c C-x C-o 链接 # - 插入 C-c C-l 打开 C-c C-o 显示/ 隐藏图片 C-c C-x C-v 网页 # [[http://www.baidu.com][百度]] 文件 # [[file:xxx.txt][描述]] 图片 # #+ATTR_ORG: :width 400 #+ATTR_HTML: :width 500 [[file:pic/xxxx.png]] org文件导出 # html # - 生成文件并打开 C-c C-e h o markdown # - 生成文件并打开 C-c C-e m o 菜单项添加markdown选项 customize-option \u0026gt; org-export-backends \u0026gt; 勾选org-markdown 安装markdown-mode 日程管理 # agenda 添加日程 # - 开始 C-c C-s 结束 C-c C-d 搜索路径保存在列表org-agenda-files中，不支持递归搜索 # 进入日程菜单 # - 函数 org-agenda 快捷键(自定义) C-c a 切换到当日安排/本周安排 d / w 表格 # 快捷键 # - M-LEFT / M-RIGHT 移动当前列 M-UP / M-DOWN 移动当前行 C-c - 在当前行下方加分割线 C-c RET 在当前行下方加分割线和换行 M-a 移动到cell开始 M-e 移动到cell末尾 TAB 下一个cell S-TAB 上一个cell C-c C-c 格式化表格 M-S-LEFT 删除当前列 M-S-RIGHT 左侧新建列 计算 # 快捷键 查询单元所在行列 C-c ? 显示表格相对行列 C-c } 行累加 # 在公式所在行C-c C-c |------+------------| | | 待累加数值 | |------+------------| | | 3 | | | 2 | | | 10 | | | 22 | |------+------------| | 累加 | 37 | |------+------------| #+TBLFM: @6$2=vsum(@2..@5) 使用插件按类别统计表格数据 # orgtbl-aggregate 在公式所在行C-c C-c #+NAME: 2023-08-01开销 |------+------+--------| | 类别 | 金额 | 项目 | |------+------+--------| | 水果 | 10 | 苹果 | | 水果 | 8 | 香蕉 | | 日化 | 12 | 洗手液 | |------+------+--------| #+BEGIN: aggregate :table \u0026quot;2023-08-01开销\u0026quot; :cols \u0026quot;类别 sum(金额)\u0026quot; | 类别 | sum(金额) | |------+-----------| | 水果 | 18 | | 日化 | 12 | #+END 缩进 # 第一种: 文本不含空格，在org-mode下显示缩进 # indent mode 使能mode # (org-indent-mode t) 全局设置 # (setq org-startup-indented t) 文件选项 # #+STARTUP：indent 第二种: 换行时自动缩进 # hard indentation 全局设置 (setq org-adapt-indentation t) 隐藏前缀星号 # 全局设置 (setq org-hide-leading-stars t) 文件选项 #+STARTUP: hidestars 选项设置 # 文章目录 # Table of Contents 导出时文章目录选项 不添加文章目录 # #+OPTIONS: toc:nil 生成的文章目录层级 # 包含1-2级标题 #+TOC: headlines 2 标题标号 # 导出时标题标号选项 不添加标题标号 # #+OPTIONS num:nil 上下标 # 格式 # 下标 a_b 上标 a^b 关闭上下标转换 # #+OPTIONS: ^:nil 要求使用{}转义 # #+OPTIONS ^:{} 上标 a^{b} 下标 a_{b} OPTIONS合并 # #+OPTIONS: toc:nil ^:{} 文本显示选项 # 只显示一级标题 # #+STARTUP: overview 显示所有内容 # #+STARTUP: showall STARTUP合并 # #+STARTUP: showall hidestars 函数 # 去到所属标题 # (outline-up-heading 0) 去到上级标题, 不超过1级标题 # ;; 所属标题的上级标题 (outline-up-heading 1) ;; 所属标题的上上级母标题 (outline-up-heading 2) 输出标题级别 # (outline-level) 比较 # (message \u0026quot;%s\u0026quot; (\u0026gt; (funcall outline-level) 1)) 去到下一个标题 # (outline-next-heading) 当前是否在标题行 # (outline-on-heading-p) 开启/关闭自动换行 # (toggle-truncate-lines) 行首 # (org-beginning-of-line) 删除行 # (kill-line) 调整所在行的缩进 # (indent-according-to-mode) "}),e.add({id:24,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/markdown/",title:"Markdown",description:"便签 # - 表格 runoob 代码框 # ```elisp ``` 插入图片 # #+begin_example !img #+end_src 插入连接 # #+begin_example 参考 #+end_src 下划线 # \u0026lt;u\u0026gt;Content\u0026lt;/u\u0026gt; 文本块 # `text` 换行 # \u0026lt;br\u0026gt; 分隔线 # --- 注释 # \u0026lt;!--哈哈我是注释，不会在浏览器中显示。--\u0026gt; Todo List # - [ ] - [x] 表格 # | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | ",content:"便签 # - 表格 runoob 代码框 # ```elisp ``` 插入图片 # #+begin_example !img #+end_src 插入连接 # #+begin_example 参考 #+end_src 下划线 # \u0026lt;u\u0026gt;Content\u0026lt;/u\u0026gt; 文本块 # `text` 换行 # \u0026lt;br\u0026gt; 分隔线 # --- 注释 # \u0026lt;!--哈哈我是注释，不会在浏览器中显示。--\u0026gt; Todo List # - [ ] - [x] 表格 # | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | "}),e.add({id:25,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/html/",title:"HTML",description:"注释 # 单行 # \u0026lt;!--这是单行注释--\u0026gt; 多行 # \u0026lt;!-- 这是多行注释 这是多行注释 这是多行注释 --\u0026gt; 无序列表 # \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;无\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;序\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;表\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ",content:"注释 # 单行 # \u0026lt;!--这是单行注释--\u0026gt; 多行 # \u0026lt;!-- 这是多行注释 这是多行注释 这是多行注释 --\u0026gt; 无序列表 # \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;无\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;序\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;表\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; "}),e.add({id:26,href:"/docs/%E5%88%86%E4%BA%AB/emacs/elisp/",title:"elisp",description:"便签 # Manual 文件 # 打开文件 # (find-file \u0026quot;path/to/file\u0026quot;) 使用打开链接的方式，打开指定文件 # (org-open-file \u0026quot;path/to/file\u0026quot;) 打开链接 # C-c C-o (org-open-at-point) 文本 # 在光标处插入 # (insert \u0026quot;Hello\u0026quot;) 读取输入 # (read-string \u0026quot;Promots: \u0026quot;) 搜索并替换 # 字符串replace-string # replace-string会跳过链接匹配 全文搜索并替换 # (while (search-forward \u0026quot;file:tt.txt\u0026quot; nil t) (replace-match \u0026quot;file:pp.txt\u0026quot; nil t)) 字符串查找 # search-backward # (search-backward \u0026quot;=\u0026quot;) ;; 查找成功返回t (search-backward \u0026quot;[[ue:\u0026quot; nil t) 正则查找 # re-search-forward # 目的字符串 [[ue:UE_5.1/Engine/Source/Runtime/Core/Public/Math/Interval.h= 正则匹配 (re-search-forward (rx \u0026quot;[[ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; )) ;; 匹配返回t (re-search-forward (rx \u0026quot;[[ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) 复制 # (copy-region-as-kill (point-min) (point-max)) 光标 # 光标所在位置 # (point) 去到指定位置 # (goto-char (point)) 光标信息 # (what-cursor-position) 记忆光标位置, 处理结束恢复 # (save-excursion (insert \u0026quot;hello\u0026quot;)) 获取光标间字符串 # (buffer-substring-no-properties (point-min) (point-max)) 缓冲区 # 获取buffer内容 # (buffer-string) 在临时buffer中做处理 # (with-temp-buffer (insert \u0026quot;hello\u0026quot;)) 保存buffer # (save-buffer) 关闭buffer # (kill-buffer) 获取buffer对应的文件名 # (buffer-name) 获取给定文件的buffer # (get-buffer (buffer-name)) 控制语句 # 条件控制语句 # if # 缩进作为true和false的分支 各一条语句 (if (= 3 5) (message \u0026quot;equal\u0026quot;) (message \u0026quot;not equal\u0026quot;)) when：cond为true时继续 # (when (\u0026lt; 3 5) (setq ooout '(\u0026quot;less\u0026quot;)) (message \u0026quot;%s\u0026quot; (cons \u0026quot;multi\u0026quot; ooout))) unless：cond为false时继续 # (unless (\u0026gt; 3 4) (setq ooout '(\u0026quot;false\u0026quot; \u0026quot;3 \u0026lt; 4\u0026quot; \u0026quot;is\u0026quot; \u0026quot;true\u0026quot; \u0026quot;!",content:`便签 # Manual 文件 # 打开文件 # (find-file \u0026quot;path/to/file\u0026quot;) 使用打开链接的方式，打开指定文件 # (org-open-file \u0026quot;path/to/file\u0026quot;) 打开链接 # C-c C-o (org-open-at-point) 文本 # 在光标处插入 # (insert \u0026quot;Hello\u0026quot;) 读取输入 # (read-string \u0026quot;Promots: \u0026quot;) 搜索并替换 # 字符串replace-string # replace-string会跳过链接匹配 全文搜索并替换 # (while (search-forward \u0026quot;file:tt.txt\u0026quot; nil t) (replace-match \u0026quot;file:pp.txt\u0026quot; nil t)) 字符串查找 # search-backward # (search-backward \u0026quot;=\u0026quot;) ;; 查找成功返回t (search-backward \u0026quot;[[ue:\u0026quot; nil t) 正则查找 # re-search-forward # 目的字符串 [[ue:UE_5.1/Engine/Source/Runtime/Core/Public/Math/Interval.h= 正则匹配 (re-search-forward (rx \u0026quot;[[ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; )) ;; 匹配返回t (re-search-forward (rx \u0026quot;[[ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) 复制 # (copy-region-as-kill (point-min) (point-max)) 光标 # 光标所在位置 # (point) 去到指定位置 # (goto-char (point)) 光标信息 # (what-cursor-position) 记忆光标位置, 处理结束恢复 # (save-excursion (insert \u0026quot;hello\u0026quot;)) 获取光标间字符串 # (buffer-substring-no-properties (point-min) (point-max)) 缓冲区 # 获取buffer内容 # (buffer-string) 在临时buffer中做处理 # (with-temp-buffer (insert \u0026quot;hello\u0026quot;)) 保存buffer # (save-buffer) 关闭buffer # (kill-buffer) 获取buffer对应的文件名 # (buffer-name) 获取给定文件的buffer # (get-buffer (buffer-name)) 控制语句 # 条件控制语句 # if # 缩进作为true和false的分支 各一条语句 (if (= 3 5) (message \u0026quot;equal\u0026quot;) (message \u0026quot;not equal\u0026quot;)) when：cond为true时继续 # (when (\u0026lt; 3 5) (setq ooout '(\u0026quot;less\u0026quot;)) (message \u0026quot;%s\u0026quot; (cons \u0026quot;multi\u0026quot; ooout))) unless：cond为false时继续 # (unless (\u0026gt; 3 4) (setq ooout '(\u0026quot;false\u0026quot; \u0026quot;3 \u0026lt; 4\u0026quot; \u0026quot;is\u0026quot; \u0026quot;true\u0026quot; \u0026quot;!\u0026quot;)) (pop ooout) (message \u0026quot;%s\u0026quot; ooout)) 循环while # break # Catch-and-Throw (let ((cnt 0)) (catch 'break (while t (setq cnt (+ cnt 1)) (sleep-for 1) (if (= cnt 5) (throw 'break t) ) ) ) ) 功能函数 # 等待 # (sleep-for 2) hook # 添加hook # (add-hook 'emms-player-started-hook (lambda () (emms-seek-to \u0026quot;05:05\u0026quot;) (emms-pause))) 移除hook # (remove-hook 'emms-player-started-hook (lambda () (emms-seek-to \u0026quot;05:05\u0026quot;) (emms-pause))) 函数调用 # funcall # 第一个参数是函数，之后的组成参数列表，传入第一个参数对应的函数 (funcall (emms-player-get player 'start) track) ;; (emms-player-get player 'start) 查dictionary得到emms-player-mpv-start ;; (emms-player-mpv-start track) apply-partially # 类似C++的bind，预设函数调用的参数 使用时，根据需求传入剩余参数 返回函数
将args作为func的前n个参数传入，调用函数时，和实际传参拼接，传给func (defun apply-partially (func \u0026amp;rest args) ;;... ) 定义函数
(defun emms-player-mpv-cmd (cmd \u0026amp;optional handler) ;;... ) (setq func (apply-partially 'emms-player-mpv-cmd play-cmd (lambda (_mpv-data mpv-error) (when (eq mpv-error 'connection-error) (emms-player-mpv-cmd play-cmd))))) (funcall func) 定义变量 # 使用let定义局部变量 # (let ((x 10) (y 20) (z 30)) (message (format \u0026quot;%d %d %d\u0026quot; x y z))) 变量之间存在引用 # (let* ((x 10) (y (+ x 10))) (message (format \u0026quot;%d %d\u0026quot; x y))) 使用setq对局部变量值进行修改 # 使用setq定义全局变量 # 可以使用 C-h v 查看变量值 buffer-local变量 # buffer内设置变量使用setq, 所有buffer生效使用setq-default 函数 # 返回值 # 函数最后一条语句的执行结果作为返回值 定义 # 可选参数：传参时，arg1必须匹配，arg2可选 # (defun test-func (arg1 \u0026amp;option arg2) ;;... ) 可变参数：传参时，arg1必须匹配，之后传入参数个数可变 # 必须放在参数列表最后 (defun test-func (arg1 \u0026amp;rest args) ;;... ) 数据结构 # string # 删除空格 # (string-trim \u0026quot; Hello \u0026quot;) 切分字符串成列表 # (split-string opath \u0026quot;/\u0026quot;) ;; 不包含为空的元素 (split-string opath \u0026quot;/\u0026quot; t) 判等 # (string= \u0026quot;hello\u0026quot; \u0026quot;Hello\u0026quot;) 不改变字符串, 返回去除前缀结果 # (string-remove-prefix \u0026quot;/\u0026quot; slot) list # 构造list # (setq slotlist '()) 元素操作 # 将元素添加到列表(头插)
(add-to-list 'slotlist export-name) 删除首元素
(pop list) 获取指定元素
(nth N list) list操作 # 长度
(length list) 打印
(print list) 返回头插的新list
(cons x list) 返回拼接后的新list
(append list1 list2) 将list转换为字符串
(format \u0026quot;%s\u0026quot; list) 遍历列表
(dolist (item the-list) ;; 操作item ) 将末尾元素组成列表
(last list) 获取首元素
(car list) 返回反转列表拷贝
(reverse slotlist) alist # Associate List (setq list '((\u0026quot;mary\u0026quot; . 23) (\u0026quot;john\u0026quot; . 24) (\u0026quot;smith\u0026quot; . 33))) 通过key获取键值对 # (assoc \u0026quot;john\u0026quot; list) 通过value获取键值对 # (rassoc 24 list) 获取键值对的key # (car (assoc \u0026quot;john\u0026quot; x)) 获取键值对的value # (cdr (assoc \u0026quot;john\u0026quot; x)) 运算符 # 不等 # /= `}),e.add({id:27,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%BB%98%E5%88%B6%E7%9E%84%E5%87%86%E5%8D%81%E5%AD%97/",title:"绘制瞄准十字",description:"概览 # 瞄准十字：垂直的两条线，处于屏幕正中间 虚幻C++ AGameModeBase::HUDClass 设置关卡使用的HUD类 AHUD 始终显示在游戏 AHUD::DrawHUD 循环体，每帧调用 AHUD::Canvas 数据成员，获取屏幕信息 AHUD::DrawLine 绘制线条 UCanvas UCanvas::SizeX 和 UCanvas::SizeY，画布长宽 TInterval 模板类，保存区间；TInterval::Min 和 TInterval::Max，区间端点 USpringArmComponent::SocketOffset 设置Camera偏移 UPrimitiveComponent::SetOwnerNoSee 设置渲染标志bOwnerNoSee 虚幻编辑器 BP_STUBaseCharacter SpringArm组件 设置Camera偏移 TextRender组件 设置渲染标志OwnerNoSee 创建AHUD派生类 # 虚幻编辑器 创建AHUD派生类，绘制我们需要的元素 Actor \u0026gt; AHUD public 绘制瞄准十字 # 虚幻C++ 更新头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot; }); 设置关卡使用STUGameHUD # ShootThemUp: STUGameModeBase.cpp #include \u0026quot;UI/STUGameHUD.h\u0026quot; // ASTUGameModeBase HUDClass = ASTUGameHUD::StaticClass(); 绘制瞄准十字 # 暂时的解决方案，之后会使用widget来绘制 功能函数DrawCrossHair # 声明 private ShootThemUp: UI/STUGameHUD.",content:"概览 # 瞄准十字：垂直的两条线，处于屏幕正中间 虚幻C++ AGameModeBase::HUDClass 设置关卡使用的HUD类 AHUD 始终显示在游戏 AHUD::DrawHUD 循环体，每帧调用 AHUD::Canvas 数据成员，获取屏幕信息 AHUD::DrawLine 绘制线条 UCanvas UCanvas::SizeX 和 UCanvas::SizeY，画布长宽 TInterval 模板类，保存区间；TInterval::Min 和 TInterval::Max，区间端点 USpringArmComponent::SocketOffset 设置Camera偏移 UPrimitiveComponent::SetOwnerNoSee 设置渲染标志bOwnerNoSee 虚幻编辑器 BP_STUBaseCharacter SpringArm组件 设置Camera偏移 TextRender组件 设置渲染标志OwnerNoSee 创建AHUD派生类 # 虚幻编辑器 创建AHUD派生类，绘制我们需要的元素 Actor \u0026gt; AHUD public 绘制瞄准十字 # 虚幻C++ 更新头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot;, \u0026quot;ShootThemUp/Public/Weapon\u0026quot;, \u0026quot;ShootThemUp/Public/UI\u0026quot; }); 设置关卡使用STUGameHUD # ShootThemUp: STUGameModeBase.cpp #include \u0026quot;UI/STUGameHUD.h\u0026quot; // ASTUGameModeBase HUDClass = ASTUGameHUD::StaticClass(); 绘制瞄准十字 # 暂时的解决方案，之后会使用widget来绘制 功能函数DrawCrossHair # 声明 private ShootThemUp: UI/STUGameHUD.h void DrawCrossHair(); 定义 ShootThemUp: UI/STUGameHUD.cpp void ASTUGameHUD::DrawCrossHair() {} 获取屏幕中心位置 # 通过Canvas成员获取屏幕长和宽，中心点保存在TInterval类型变量里 ShootThemUp: UI/STUGameHUD.cpp #include \u0026quot;Engine/Canvas.h\u0026quot; // DrawCrossHair const TInterval\u0026lt;float\u0026gt; Center(Canvas-\u0026gt;SizeX * 0.5f, Canvas-\u0026gt;SizeY * 0.5f); 绘制瞄准十字 # 线条参数 - 颜色 LineColor 粗细 LineThickness 长度 HalfLineSize x 2 使用AHUD::DrawLine绘制十字 ShootThemUp: UI/STUGameHUD.cpp // DrawCorssHair const float HalfLineSize = 10.0f; const float LineThickness = 2.0f; const FLinearColor LineColor = FLinearColor::Green; DrawLine(Center.Min, Center.Max - HalfLineSize, Center.Min, Center.Max + HalfLineSize, LineColor, LineThickness); DrawLine(Center.Min - HalfLineSize, Center.Max, Center.Min + HalfLineSize, Center.Max, LineColor, LineThickness); 覆写基类DrawHUD，调用其基类函数和DrawCorssHair # 声明 public ShootThemUp: UI/STUGameHUD.h virtual void DrawHUD() override; 定义 ShootThemUp: UI/STUGameHUD.cpp void ASTUGameHUD::DrawHUD() { Super::DrawHUD(); DrawCrossHair(); } 查看 # 虚幻编辑器 关卡使用STUGameHUD # 操控Character移动，或调整屏幕大小，绿色十字总在屏幕中心位置 # 看上去是2D效果 调整Camera组件位置 # BP_STUBaseCharacter，选中SpringArmComponent \u0026gt; Details \u0026gt; Camera \u0026gt; Socket Offset，设置Y偏移100 Camera在Character的右·上·后方，Camera对到瞄准十字 调整HealthText组件 # 之后会把生命值显示的逻辑在别处实现 隐藏生命值 # BP_STUBaseCharacter，选中HealthTextComponent \u0026gt; Details 搜索Owner，勾选 Owner No See - Owner No See 玩家可以看见他人游戏角色的生命值，看不见自己的 渲染别人家的TextComponent，不渲染自家的 Only Owner See 每个玩家只能看见自己游戏角色的生命值 渲染自家Character的TextComponent 重置文本旋转 看他人生命值时，文本方向ok 在关卡中临时添加BP_STUBaseCharacter对象，查看效果 在代码中设置 # 虚幻C++ ShootThemUp: Player/STUBaseCharacter.cpp 设置SpringArm组件socket offset的方法 // 构造函数 SpringArmComponent-\u0026gt;SocketOffset = FVector(0.0f, 100.0f, 80.0f); 设置HealthText组件OwnerNoSee标志位的方法 // 构造函数 HealthTextComponent-\u0026gt;SetOwnerNoSee(true); "}),e.add({id:28,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E6%A0%87%E9%A2%98%E9%AB%98%E4%BA%AE/",title:"文章目录标题高亮",description:"说明 # 设置高亮样式 css 使用Intersection Observer实现 JavaScript 文章目录设置 config/_default/markup.toml - startLevel 2 endLevel 3 另一个实现思路为Scrollspy 移植到Doks主题 便签 # - 文章目录滚动高亮 1. 为文章目录设置类 2. 高亮样式 3. 提供一种实现 高亮样式 当前标题底部加横线 滚动高亮 设置元素的父元素 滚动高亮 option和intersectionObserver的callback IntersectionObserver API 1. 添加观察元素: observe 2. intersectionRatio 3. target querySelectorAll用法 1. 获取有指定属性的元素: \u0026ldquo;a[target]\u0026rdquo; 2. 获取指定父元素的元素: \u0026ldquo;div \u0026gt; p\u0026rdquo; 3. 获取多个分类元素: \u0026ldquo;h2[id], h3[id]\u0026rdquo; 获取元素的方式 1. id: getElementById, 上下文要求是documnet 2. name: getElementsByName, 一组 将NodeList转换为数组 apply 从数组中移除元素 filter 设置数组初始值 fill 文章目录 # Doks主题通过设置startLevel和endLevel限制ToC显示的标题。endLevel上限为4，startLevel一般从2开始 高亮的是ToC中的链接 高亮样式 # 设置颜色 加粗 过渡 暗色主题 assets/scss/common/_global.",content:"说明 # 设置高亮样式 css 使用Intersection Observer实现 JavaScript 文章目录设置 config/_default/markup.toml - startLevel 2 endLevel 3 另一个实现思路为Scrollspy 移植到Doks主题 便签 # - 文章目录滚动高亮 1. 为文章目录设置类 2. 高亮样式 3. 提供一种实现 高亮样式 当前标题底部加横线 滚动高亮 设置元素的父元素 滚动高亮 option和intersectionObserver的callback IntersectionObserver API 1. 添加观察元素: observe 2. intersectionRatio 3. target querySelectorAll用法 1. 获取有指定属性的元素: \u0026ldquo;a[target]\u0026rdquo; 2. 获取指定父元素的元素: \u0026ldquo;div \u0026gt; p\u0026rdquo; 3. 获取多个分类元素: \u0026ldquo;h2[id], h3[id]\u0026rdquo; 获取元素的方式 1. id: getElementById, 上下文要求是documnet 2. name: getElementsByName, 一组 将NodeList转换为数组 apply 从数组中移除元素 filter 设置数组初始值 fill 文章目录 # Doks主题通过设置startLevel和endLevel限制ToC显示的标题。endLevel上限为4，startLevel一般从2开始 高亮的是ToC中的链接 高亮样式 # 设置颜色 加粗 过渡 暗色主题 assets/scss/common/_global.scss .my-toc a.active { color: $primary; font-weight: 800; transition: all .25s ease-in-out } assets/scss/common/_dark.scss [data-dark-mode] .my-toc a.active { // color: $link-color-dark; color: $zdoc-highlight-dark; } 为ToC设置类 # layouts/partials/sidebar/docs-toc.html:23 \u0026lt;nav class=\u0026quot;my-toc\u0026quot;\u0026gt; {{ .TableOfContents }} \u0026lt;/nav\u0026gt; 进入判断 # document.addEventListener('DOMContentLoaded', () =\u0026gt; { const toc = document.querySelector('.my-toc'); if (!toc) return; // 后续处理 }); 文章目录标题 # 获取有类my-toc的元素的链接 const tocHeadings = toc.querySelectorAll('a'); 正文标题 # 只关注显示在文章目录的标题, 筛选时, 要求标题的下级链接有类anchor const headings = Array.apply(null, document.querySelectorAll('h2[id], h3[id]')).filter(function (value, index, arr) { return arr[index].querySelector('.anchor'); }); 将文章目录标题和正文标题关联 # 当二者标题数一致时, 认为一一对应, 设置标号; 否则就此结束 function addHeadingIdx(list) { let i = 0; list.forEach((item) =\u0026gt; { item.setAttribute('headingIdx', i++); }); } if (tocHeadings.length !== headings.length) return; addHeadingIdx(tocHeadings); addHeadingIdx(headings); 搭建交叉观察框架 # 触发条件：当标题的intersectionRatio变为threshold，或者不再为threshold时，对标题进行处理 const intersectionOptions = { threshold: 1.0 } 创建观察器 const headingObserver = new IntersectionObserver(headings =\u0026gt; { headings.forEach(heading =\u0026gt; { // 处理标题 }) }, intersectionOptions); 将正文标题添加到观察列表 headings.forEach((heading) =\u0026gt; { headingObserver.observe(heading); }); 为标题添加/移除高亮 # 标题的intersectionRatio满足阈值，isIntersecting为true，intersectionRatio不满足阈值，为false 根据isIntersecting更新标题高亮状态 新增高亮标题, 或者有多个标题高亮时移除高亮: 根据高亮状态刷新, 更新高亮标题个数 添加全局数组，保存标题高亮状态，初始值为false # let HeadingFlag; HeadingFlag = new Array(headings.length).fill(false); 添加变量，保存高亮标题个数, 初始值为0 # let HeadingCnt; HeadingCnt = 0; 进入观察器回调函数: 更新标题高亮状态; 新增高亮, 或者有多个标题高亮时移除高亮, 根据高亮状态设置标题，更新高亮个数 # function refreshHighlight() { HeadingCnt = 0; for (let i = 0; i \u0026lt; HeadingFlag.length; ++i) { if (HeadingFlag[i]) { ++HeadingCnt; document.querySelector(`.my-toc a[headingIdx=\u0026quot;${i}\u0026quot;]`).classList.add('active'); } else { document.querySelector(`.my-toc a[headingIdx=\u0026quot;${i}\u0026quot;]`).classList.remove('active'); } } } const idx = heading.target.getAttribute('headingIdx'); if ((HeadingFlag[idx] = heading.isIntersecting) || (HeadingCnt !== 1)) { refreshHighlight(); } 完整JavaScript代码 # assets/js/toc.js let HeadingFlag; let HeadingCnt; function addHeadingIdx(list) { let i = 0; list.forEach((item) =\u0026gt; { item.setAttribute('headingIdx', i++); }); } function refreshHighlight() { HeadingCnt = 0; for (let i = 0; i \u0026lt; HeadingFlag.length; ++i) { if (HeadingFlag[i]) { ++HeadingCnt; document.querySelector(`.my-toc a[headingIdx=\u0026quot;${i}\u0026quot;]`).classList.add('active'); } else { document.querySelector(`.my-toc a[headingIdx=\u0026quot;${i}\u0026quot;]`).classList.remove('active'); } } } document.addEventListener('DOMContentLoaded', () =\u0026gt; { const toc = document.querySelector('.my-toc'); if (!toc) return; const tocHeadings = toc.querySelectorAll('a'); const headings = Array.apply(null, document.querySelectorAll('h2[id], h3[id]')).filter(function (value, index, arr) { return arr[index].querySelector('.anchor'); }); if (tocHeadings.length !== headings.length) return; addHeadingIdx(tocHeadings); addHeadingIdx(headings); HeadingFlag = new Array(headings.length).fill(false); HeadingCnt = 0; const intersectionOptions = { threshold: 1.0 }; const headingObserver = new IntersectionObserver(headings =\u0026gt; { headings.forEach(heading =\u0026gt; { // console.log('ratio', heading.target.getAttribute('id'), heading.intersectionRatio, heading.isIntersecting, HeadingCnt); const idx = heading.target.getAttribute('headingIdx'); if ((HeadingFlag[idx] = heading.isIntersecting) || (HeadingCnt !== 1)) { refreshHighlight(); } }); }, intersectionOptions); headings.forEach((heading) =\u0026gt; { headingObserver.observe(heading); }); }); Doks主题执行JavaScript脚本 # 参照assets/highlight.js的执行 layouts/partials/footer/script-footer.html 10 {{ $toc := resources.Get \u0026quot;js/toc.js\u0026quot; -}} {{ $toc := $toc | js.Build -}} 86 \u0026lt;script src=\u0026quot;{{ $toc.RelPermalink }}\u0026quot; defer\u0026gt;\u0026lt;/script\u0026gt; 103 {{ $toc := $toc | minify | fingerprint \u0026quot;sha512\u0026quot; -}} 113 \u0026lt;script src=\u0026quot;{{ $toc.RelPermalink }}\u0026quot; integrity=\u0026quot;{{ $toc.Data.Integrity }}\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot; defer\u0026gt;\u0026lt;/script\u0026gt; "}),e.add({id:29,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/",title:"代码规范",description:"说明 # .clang-format .gitignore 虚幻引擎编码规范 - 大括号 放在新行 缩进 使用空格 缩进、制表符和空格 # 缩进 # indent 编写代码时，按下Tab键，会按制表符宽度留出空位，用以控制格式 使用制表符 Tab 和空格填充缩进 制表符的宽度可设置，不同平台制表符的宽度不一，视觉上，查看代码会有不习惯的感觉；可在本地设置使用空格，即用空格替换制表符 缩进使用空格 # 示例: 缩进使用空格, 制表符宽度 TabWidth 无效；缩进宽度 IndentWidth 生效, 一次缩进对应7个空格 IndentWidth: '7' UseTab: 'Never' TabWidth: '9' 缩进使用制表符和空格 # 若缩进宽度小于制表符宽度, 使用空格填充缩进; 若缩进宽度大于等于制表符宽度, 使用制表符和空格填充缩进 示例: 一次缩进对应7个空格，不会被替换为制表符；两个缩进对应14个空格，会被替换为1个制表符加5个空格 IndentWidth: '7' TabWidth: '9' UseTab: 'Always' 格式化代码规则 # .clang-format 官方文档 YAML标记文件 作为项目的一部分，描述管理代码文件的统一格式 每行遵循格式 key: value 设置受约束的开发语言 # Language: Cpp 如果项目中只一种开发语言，或者所有开发语言使用相同规范，可忽略该配置 通用样式 # Google: 一个制表符对应2个空格，大括号在行尾 BasedOnStyle: Google Microsoft: 一个制表符对应4个空格，大括号在新行 BasedOnStyle: Microsoft 制表符宽度 # 若缩进使用制表符，每6个空格替换一个制表符；当缩进宽度和制表符宽度不一致时，效果很糟糕 TabWidth: '6' 缩进宽度 # IndentWidth: '4' 缩进样式 # 空格 UseTab: Never 制表符: 源文件中既有空格又有制表符 UseTab: Always 设置大括号位置 # 行尾 BreakBeforeBraces: Attach 新行 BreakBeforeBraces: Allman 显示时, 每行最大字符个数 # 为0时，按输入的实际情况显示 ColumnLimit: '140' 向前缩进 # 控制访问说明符的缩进 AccessModifierOffset: '-4' 头文件排序 # SortIncludes: false 括号换行时，参数的对齐方式 # AlignAfterOpenBracket: Align 不对齐 DontAlign someLongFunction(argument1, argument2); 对齐 Align someLongFunction(argument1, argument2); 当语句较短时，是否允许写在单行 # AllowShortBlocksOnASingleLine: false 条件语句的执行部分为空，或只有一行语句时，可认为语句较短；为false则如下输出 while (true) { } while (true) { continue; } 当函数语句较短时，是否允许写在单行 # - Inline 若函数体为空，允许；若函数在类内定义，允许 InlineOnly 只允许一种情况：函数在类内定义 Empty 只允许一种情况：函数体为空 AllowShortFunctionsOnASingleLine: Inline 指针和引用的对齐方式 # PointerAlignment: Right Right int *a; Left int* a; Git仓库同步 # .",content:"说明 # .clang-format .gitignore 虚幻引擎编码规范 - 大括号 放在新行 缩进 使用空格 缩进、制表符和空格 # 缩进 # indent 编写代码时，按下Tab键，会按制表符宽度留出空位，用以控制格式 使用制表符 Tab 和空格填充缩进 制表符的宽度可设置，不同平台制表符的宽度不一，视觉上，查看代码会有不习惯的感觉；可在本地设置使用空格，即用空格替换制表符 缩进使用空格 # 示例: 缩进使用空格, 制表符宽度 TabWidth 无效；缩进宽度 IndentWidth 生效, 一次缩进对应7个空格 IndentWidth: '7' UseTab: 'Never' TabWidth: '9' 缩进使用制表符和空格 # 若缩进宽度小于制表符宽度, 使用空格填充缩进; 若缩进宽度大于等于制表符宽度, 使用制表符和空格填充缩进 示例: 一次缩进对应7个空格，不会被替换为制表符；两个缩进对应14个空格，会被替换为1个制表符加5个空格 IndentWidth: '7' TabWidth: '9' UseTab: 'Always' 格式化代码规则 # .clang-format 官方文档 YAML标记文件 作为项目的一部分，描述管理代码文件的统一格式 每行遵循格式 key: value 设置受约束的开发语言 # Language: Cpp 如果项目中只一种开发语言，或者所有开发语言使用相同规范，可忽略该配置 通用样式 # Google: 一个制表符对应2个空格，大括号在行尾 BasedOnStyle: Google Microsoft: 一个制表符对应4个空格，大括号在新行 BasedOnStyle: Microsoft 制表符宽度 # 若缩进使用制表符，每6个空格替换一个制表符；当缩进宽度和制表符宽度不一致时，效果很糟糕 TabWidth: '6' 缩进宽度 # IndentWidth: '4' 缩进样式 # 空格 UseTab: Never 制表符: 源文件中既有空格又有制表符 UseTab: Always 设置大括号位置 # 行尾 BreakBeforeBraces: Attach 新行 BreakBeforeBraces: Allman 显示时, 每行最大字符个数 # 为0时，按输入的实际情况显示 ColumnLimit: '140' 向前缩进 # 控制访问说明符的缩进 AccessModifierOffset: '-4' 头文件排序 # SortIncludes: false 括号换行时，参数的对齐方式 # AlignAfterOpenBracket: Align 不对齐 DontAlign someLongFunction(argument1, argument2); 对齐 Align someLongFunction(argument1, argument2); 当语句较短时，是否允许写在单行 # AllowShortBlocksOnASingleLine: false 条件语句的执行部分为空，或只有一行语句时，可认为语句较短；为false则如下输出 while (true) { } while (true) { continue; } 当函数语句较短时，是否允许写在单行 # - Inline 若函数体为空，允许；若函数在类内定义，允许 InlineOnly 只允许一种情况：函数在类内定义 Empty 只允许一种情况：函数体为空 AllowShortFunctionsOnASingleLine: Inline 指针和引用的对齐方式 # PointerAlignment: Right Right int *a; Left int* a; Git仓库同步 # .gitignore 虚幻引擎提供模板 告诉Git，同步时忽略的文件和文件夹 命名约定 # 虚幻编辑器 虚幻引擎命名规范参考 虚幻编辑器 材质 Material M_ 材质实例 Material Instance MI_ 基于C++的蓝图类 Blueprint BP_ 动画蓝图 Animation Blueprint ABP_ 混合空间(1D) Blend Space BS_ 动画剪辑 Animation Montage AM_ "}),e.add({id:30,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E6%8B%9F%E6%A6%B4%E5%BC%B9%E7%88%86%E7%82%B8/",title:"模拟榴弹爆炸",description:"建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 创建伤害源 # 创建Dev/STUDevDamageActor # 虚幻编辑器 Actor 公有类 设置头文件搜索路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot; }); 添加可视化组件，使得伤害源可变换 # 添加SceneComponent protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent; 初始化组件 ShootThemUp: Dev/STUDevDamageActor.cpp // 构造函数 SceneComponent = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(\u0026quot;SceneComponent\u0026quot;); SetRootComponent(SceneComponent); 绘制球体，使得爆炸范围可视化 # 添加球体参数 protected ShootThemUp: Dev/STUDevDamageActor.h - 颜色 SphereColor 半径 Radius UPROPERTY(EditAnywhere) float Radius = 300.0f; UPROPERTY(EditAnywhere) FColor SphereColor = FColor::Red; 每帧绘制球体 ShootThemUp: Dev/STUDevDamageActor.cpp #include \u0026quot;DrawDebugHelpers.h\u0026quot; // Tick DrawDebugSphere(GetWorld(), GetActorLocation(), Radius, 24, SphereColor); 使用了GetWorld，其声明和UWorld的定义在一处，而DrawDebugSphere的第一个参数类型为UWorld，不用包含Engine/World.",content:"建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 创建伤害源 # 创建Dev/STUDevDamageActor # 虚幻编辑器 Actor 公有类 设置头文件搜索路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot; }); 添加可视化组件，使得伤害源可变换 # 添加SceneComponent protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent; 初始化组件 ShootThemUp: Dev/STUDevDamageActor.cpp // 构造函数 SceneComponent = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(\u0026quot;SceneComponent\u0026quot;); SetRootComponent(SceneComponent); 绘制球体，使得爆炸范围可视化 # 添加球体参数 protected ShootThemUp: Dev/STUDevDamageActor.h - 颜色 SphereColor 半径 Radius UPROPERTY(EditAnywhere) float Radius = 300.0f; UPROPERTY(EditAnywhere) FColor SphereColor = FColor::Red; 每帧绘制球体 ShootThemUp: Dev/STUDevDamageActor.cpp #include \u0026quot;DrawDebugHelpers.h\u0026quot; // Tick DrawDebugSphere(GetWorld(), GetActorLocation(), Radius, 24, SphereColor); 使用了GetWorld，其声明和UWorld的定义在一处，而DrawDebugSphere的第一个参数类型为UWorld，不用包含Engine/World.h 对伤害范围内Actor造成半径伤害 # 添加半径伤害参数 protected ShootThemUp: Dev/STUDevDamageActor.h - Damage 伤害数值特征 DoFullDamage 半径伤害计算选项：为true，受到的伤害与到球心的距离有关；为false，使用简化模型，受到伤害值恒定 UPROPERTY(EditAnywhere) float Damage = 10.0f; UPROPERTY(EditAnywhere) bool DoFullDamage = false; 对伤害范围内Actor造成半径伤害 ShootThemUp: Dev/STUDevDamageActor.cpp #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;Kismet/GameplayStatics.h\u0026quot; // Tick UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); ApplyRadialDamage 的第一个参数类型为 UObject ，此时传入 UWorld ，需包含 UWorld 头文件 验证半径伤害数值 # C++ 定义日志宏，输出伤害值 ShootThemUp: Components/STUHealthComponent.cpp DEFINE_LOG_CATEGORY_STATIC(LogHealthComponent, All, All); // OnTakeAnyDamage UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;Damage: %.0f\u0026quot;), Damage); 屏蔽STUBaseCharacter\u0026gt;Tick中调用TakeDamage # ShootThemUp: Player/STUBaseCharacter.cpp 在关卡中添加伤害源 # 虚幻编辑器 调整BP_STUBaseCharacter\u0026gt;CameraComponent位置 # 向上，向后 在关卡中添加STDevDamageActor # 第一个伤害源: 使用默认设置，根据游戏角色到球心的距离计算伤害 第二个伤害源: 设置半径和颜色，处在伤害范围内受到伤害数值恒定（开销小） 调整 STDevDamageActor 的位置，效果图 要求伤害源球心无阻隔 验证 DoFullDamage # 处于蓝色球内，伤害值一致 处于红色球内，离球心越近，伤害值越大 球心在空中，跳跃也会缩短到球心的距离 伤害球内的所有Actor都会受到伤害 # "}),e.add({id:31,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E6%AD%A6%E5%99%A8%E7%BB%84%E4%BB%B6/",title:"武器组件",description:"概览 # 前提概要 给游戏角色装载武器时, 先动态生成武器Actor, 之后附加到HeroTPP的WeaponSocket 武器类 添加 fire 接口, 对应扣动扳机逻辑 之后会有 shoot 接口，在 fire 中调用；二者关联是，机关枪扣动一次扳机，可以连发数枪 武器组件 STUWeaponComponent 将 SpawnWeapon 逻辑移到这里 包括开火 Fire 逻辑: 调用 STUBaseWeapon\u0026gt;Fire 接口 还有更换武器, 装弹逻辑 Character 绑定键位: 点击鼠标左键, 调用 STUWeaponComponent\u0026gt;Fire 接口 创建STUWeaponComponent # 创建STUWeaponComponent 虚幻编辑器 - ActorComponent Public Components 调整STUWeaponComponent结构 C++ - 构造函数 每帧调用置false TickComponent 屏蔽 ShootThemUp: Components/STUWeaponComponent.h ShootThemUp: Components/STUWeaponComponent.cpp 重构: 移动SpawnWeapon逻辑 # C++ 在STUWeaponComponent中实现SpawnWeapon # 添加数据成员 # ShootThemUp: Components/STUWeaponComponent.h 相关数据成员 protected class ASTUBaseWeapon; UPROPERTY(EditDefaultsOnly) TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponClass; 保存Socket名 protected UPROPERTY(EditDefaultsOnly) FName WeaponAttachPointName = \u0026quot;WeaponSocket\u0026quot;; 保存武器Actor private 所有的指针需要使用UPROPERTY宏标识, 否则Garbage Collector不会维护该指针管理的内存 UPROPERTY() ASTUBaseWeapon *CurrentWeapon= nullptr; 添加函数成员 # 声明 private ShootThemUp: Components/STUWeaponComponent.",content:"概览 # 前提概要 给游戏角色装载武器时, 先动态生成武器Actor, 之后附加到HeroTPP的WeaponSocket 武器类 添加 fire 接口, 对应扣动扳机逻辑 之后会有 shoot 接口，在 fire 中调用；二者关联是，机关枪扣动一次扳机，可以连发数枪 武器组件 STUWeaponComponent 将 SpawnWeapon 逻辑移到这里 包括开火 Fire 逻辑: 调用 STUBaseWeapon\u0026gt;Fire 接口 还有更换武器, 装弹逻辑 Character 绑定键位: 点击鼠标左键, 调用 STUWeaponComponent\u0026gt;Fire 接口 创建STUWeaponComponent # 创建STUWeaponComponent 虚幻编辑器 - ActorComponent Public Components 调整STUWeaponComponent结构 C++ - 构造函数 每帧调用置false TickComponent 屏蔽 ShootThemUp: Components/STUWeaponComponent.h ShootThemUp: Components/STUWeaponComponent.cpp 重构: 移动SpawnWeapon逻辑 # C++ 在STUWeaponComponent中实现SpawnWeapon # 添加数据成员 # ShootThemUp: Components/STUWeaponComponent.h 相关数据成员 protected class ASTUBaseWeapon; UPROPERTY(EditDefaultsOnly) TSubclassOf\u0026lt;ASTUBaseWeapon\u0026gt; WeaponClass; 保存Socket名 protected UPROPERTY(EditDefaultsOnly) FName WeaponAttachPointName = \u0026quot;WeaponSocket\u0026quot;; 保存武器Actor private 所有的指针需要使用UPROPERTY宏标识, 否则Garbage Collector不会维护该指针管理的内存 UPROPERTY() ASTUBaseWeapon *CurrentWeapon= nullptr; 添加函数成员 # 声明 private ShootThemUp: Components/STUWeaponComponent.h void SpawnWeapon(); 定义 处理不正确则退出: 统一结构, 减少缩进 ShootThemUp: Components/STUWeaponComponent.cpp #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;Components/SkeletalMeshComponent.h\u0026quot; #include \u0026quot;Weapon/STUBaseWeapon.h\u0026quot; #include \u0026quot;GameFramework/Character.h\u0026quot; void USTUWeaponComponent::SpawnWeapon() { if (!GetWorld()) return; ACharacter *Character = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Character) return; CurrentWeapon = GetWorld()-\u0026gt;SpawnActor\u0026lt;ASTUBaseWeapon\u0026gt;(WeaponClass); if (!CurrentWeapon) return; FAttachmentTransformRules AttachmentRules(EAttachmentRule::SnapToTarget, false); CurrentWeapon-\u0026gt;AttachToComponent(Character-\u0026gt;GetMesh(), AttachmentRules, \u0026quot;WeaponSocket\u0026quot;); } 调用SpawnWeapon # //BeginPlay SpawnWeapon(); 移除STUBaseCharacter的SpawnWeapon # ShootThemUp: Player/STUBaseCharacter.h STUBaseWeapon前向声明 WeaponClass成员 SpawnWeapon声明 ShootThemUp: Player/STUBaseCharacter.cpp 头文件: STUBaseWeapon, World, SkeletalMeshComponent BeginPlay中调用SpawnWeapon SpawnWeapon 为Character添加WeaponComponent # C++ 纯逻辑组件, 不用SetupAttachment 添加数据成员 protected ShootThemUp: Player/STUBaseCharacter.h class USTUWeaponComponent; UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USTUWeaponComponent *WeaponComponent; 初始化组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/STUWeaponComponent.h\u0026quot; // 构造函数 WeaponComponent = CreateDefaultSubobject\u0026lt;USTUWeaponComponent\u0026gt;(\u0026quot;WeaponComponent\u0026quot;); 查看武器绑定 # 虚幻编辑器 BP_STUBaseCharacter \u0026gt; Weapon Component \u0026gt; Weapon Class: 设置为BP_STUBaseWeapon 效果图 和之前效果一致 实现扣动扳机 # STUBaseWeapon实现Fire接口 # 虚函数, 会有STUBaseWeapon的派生类, 而派生类的开火方式不同. 之后会实现射击(Shoot)逻辑, 此时打印日志 声明 public ShootThemUp: Weapon/STUBaseWeapon.h virtual void Fire(); 定义 ShootThemUp: Weapon/STUBaseWeapon.cpp DEFINE_LOG_CATEGORY_STATIC(LogBaseWeapon, All, All); void ASTUBaseWeapon::Fire() { UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Fire!\u0026quot;)); } 绑定键位: 扣动扳机 # 项目设置 \u0026gt; Engine \u0026gt; Input \u0026gt; Bindings \u0026gt; Action Mappings - 函数描述 Fire 键位 Left Mouse Button STUWeaponComponent实现回调函数 # 声明 public ShootThemUp: Components/STUWeaponComponent.h 定义 ShootThemUp: Components/STUWeaponComponent.cpp void USTUWeaponComponent::Fire() { if (!CurrentWeapon) return; CurrentWeapon-\u0026gt;Fire(); } 为游戏角色绑定函数描述和回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp 检查组件初始化 // BeginPlay check(WeaponComponent); 绑定 // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Fire\u0026quot;, IE_Pressed, WeaponComponent, \u0026amp;USTUWeaponComponent::Fire); 查看扣动扳机 # 点击鼠标左键, 输出日志 "}),e.add({id:32,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%B8%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%9E%8B/",title:"为游戏角色绑定模型",description:"概览 # - 玩家控制的游戏角色 Character 游戏角色控制器 PlayerController 关卡设置 GameModeBase: DefaultPawnClass, PlayerControllerClass 第三视角 CameraComponent 创建Character类和PlayController类 # 虚幻编辑器 创建 Player/STUBaseCharacter ACharacter 公有类 创建 Player/STUPlayerController APlayerController 公有类 设置头文件搜索路径 # 源文件路径已包含上级文件夹 ShootThemUp: Player/STUBaseCharacter.cpp 设置头文件搜索路径之后，可以不指明上级文件夹 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot; }); 设置STUGameModeBase使用STUBaseCharacter和STUPlayController # C++ - DefaultPawnClass 游戏角色类型 PlayerControllerClass 游戏角色控制器类型 添加默认构造函数声明 ShootThemUp: STUGameModeBase.h 设置默认游戏角色类型和游戏角色控制器类型 ShootThemUp: STUGameModeBase.cpp #include \u0026quot;Player/STUBaseCharacter.h\u0026quot; #include \u0026quot;Player/STUPlayerController.h\u0026quot; // 以下亦正确 // #include \u0026quot;STUBaseCharacter.h\u0026quot; // #include \u0026quot;STUPlayerController.h\u0026quot; ASTUGameModeBase::ASTUGameModeBase() { DefaultPawnClass = ASTUBaseCharacter::StaticClass(); PlayerControllerClass = ASTUPlayerController::StaticClass(); } 为游戏角色添加第三视角 # C++ 为STUBaseCharacter添加UCameraComponent类型成员 添加CameraComponent类型成员 ShootThemUp: Player/STUBaseCharacter.",content:"概览 # - 玩家控制的游戏角色 Character 游戏角色控制器 PlayerController 关卡设置 GameModeBase: DefaultPawnClass, PlayerControllerClass 第三视角 CameraComponent 创建Character类和PlayController类 # 虚幻编辑器 创建 Player/STUBaseCharacter ACharacter 公有类 创建 Player/STUPlayerController APlayerController 公有类 设置头文件搜索路径 # 源文件路径已包含上级文件夹 ShootThemUp: Player/STUBaseCharacter.cpp 设置头文件搜索路径之后，可以不指明上级文件夹 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot; }); 设置STUGameModeBase使用STUBaseCharacter和STUPlayController # C++ - DefaultPawnClass 游戏角色类型 PlayerControllerClass 游戏角色控制器类型 添加默认构造函数声明 ShootThemUp: STUGameModeBase.h 设置默认游戏角色类型和游戏角色控制器类型 ShootThemUp: STUGameModeBase.cpp #include \u0026quot;Player/STUBaseCharacter.h\u0026quot; #include \u0026quot;Player/STUPlayerController.h\u0026quot; // 以下亦正确 // #include \u0026quot;STUBaseCharacter.h\u0026quot; // #include \u0026quot;STUPlayerController.h\u0026quot; ASTUGameModeBase::ASTUGameModeBase() { DefaultPawnClass = ASTUBaseCharacter::StaticClass(); PlayerControllerClass = ASTUPlayerController::StaticClass(); } 为游戏角色添加第三视角 # C++ 为STUBaseCharacter添加UCameraComponent类型成员 添加CameraComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h // 前向声明 class UCameraComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UCameraComponent *CameraComponent; 初始化组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Camera/CameraComponent.h\u0026quot; // 默认构造函数 CameraComponent = CreateDefaultSubobject\u0026lt;UCameraComponent\u0026gt;(\u0026quot;CameraComponent\u0026quot;); CameraComponent-\u0026gt;SetupAttachment(GetRootComponent()); 编译ShootThemUp 设置关卡使用蓝图类 # 虚幻编辑器 查看STUGameModeBase使用的类型 # 创建基于STUGameModeBase的蓝图类 # 选中C++ Classes/ShootThemUp/STUGameModeBase右键, 选择Create blueprint class based on STUGameModeBase 保存到Content/, 命名为BP_STUBaseGameBase 创建基于STUBaseCharacter和STUPlayerController的蓝图类 # 创建 Content/Player 文件夹 创建 BP_STUBaseCharacter 和 BP_STUPlayerController , 保存到 Content/Player/ 设置关卡使用BP_STUGameModeBase, 并设置BP_STUGameModeBase使用BP_STUBaseCharacter和BP_STUPlayerController # 为游戏角色绑定模型 # 虚幻编辑器 BP_STUBaseCharacter 查看组件信息 # 说明 Capsule Component 根组件，实现碰撞检测 Arrow Component 角色的前进方向 Camera Component 第三视角 Mesh 骨骼网格体(Skeletal Mesh) Character Movement 纯逻辑组件，负责游戏角色运动 设置蓝图类编译成功自动保存 # 为Mesh组件绑定骨骼网格体 # Mesh 绑定 HeroTPP 材质自动应用 HeroTPP 移动模型到合适位置，旋转模型与前进方向一致 实现第三视角 分离 Camera Component 和 Mesh 组件 效果图 "}),e.add({id:33,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E4%BC%A4%E5%AE%B3%E7%B1%BB%E5%9E%8B/",title:"使用伤害类型",description:"创建伤害类型 # 虚幻编辑器 创建Dev/STUFireDamageType # UDamageType 公有类 创建Dev/STUIceDamageType # UDamageType 公有类 为伤害来源添加伤害类型属性 # C++ 添加伤害类型参数 protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UDamageType\u0026gt; DamageType; 造成伤害时，传入伤害类型 ShootThemUp: Dev/STUDevDamageActor.cpp // Tick // UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); 在伤害处理函数中输出伤害来源信息 # C++ ShootThemUp: Components/STUHealthComponent.cpp #include \u0026quot;Dev/STUFireDamageType.h\u0026quot; #include \u0026quot;Dev/STUIceDamageType.h\u0026quot; // OnTakeAnyDamage if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTUFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTUIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !",content:"创建伤害类型 # 虚幻编辑器 创建Dev/STUFireDamageType # UDamageType 公有类 创建Dev/STUIceDamageType # UDamageType 公有类 为伤害来源添加伤害类型属性 # C++ 添加伤害类型参数 protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UDamageType\u0026gt; DamageType; 造成伤害时，传入伤害类型 ShootThemUp: Dev/STUDevDamageActor.cpp // Tick // UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); 在伤害处理函数中输出伤害来源信息 # C++ ShootThemUp: Components/STUHealthComponent.cpp #include \u0026quot;Dev/STUFireDamageType.h\u0026quot; #include \u0026quot;Dev/STUIceDamageType.h\u0026quot; // OnTakeAnyDamage if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTUFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTUIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !!!\u0026quot;)); } } 查看 # 虚幻编辑器 为伤害来源设置DamageType属性 # DamageSphere-Red 选择 STUFireDamageType DamageSphere-Blue 选择 STUIceDamageType 查看日志 # 游戏角色进入到 DamageSphere-Red 游戏角色进入到 DamageSphere-Blue "}),e.add({id:34,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E8%B7%9F%E9%9A%8F%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E6%BB%9A%E5%8A%A8/",title:"文章目录跟随文章内容滚动",description:"说明 # 监听滚动事件, 触发定时器, 到时实现文章目录滚动跟随 浏览器支持 - docs-toc scrollTop my-toc scrollTop 文章目录跳转 Safari O X - Firefox O X - Chrome O O docs-toc需要定时器, 延时要求大于文章目录跳转最大耗时 滚动监听 # window添加事件监听 window.addEventListener('scroll', () =\u0026gt; { // 处理 }); window注册滚动处理 window.onscroll = function () { // 处理 }; 进入判断 # document.addEventListener('DOMContentLoaded', () =\u0026gt; { const myToc = document.querySelector('.my-toc'); const fullToc = document.querySelector('.docs-toc'); if (!myToc || !fullToc) return; // 后续处理 }); 滚动计算 # 为标题排序, 厘清高亮标题在文章目录中的位置 # let i = 0; myToc.",content:"说明 # 监听滚动事件, 触发定时器, 到时实现文章目录滚动跟随 浏览器支持 - docs-toc scrollTop my-toc scrollTop 文章目录跳转 Safari O X - Firefox O X - Chrome O O docs-toc需要定时器, 延时要求大于文章目录跳转最大耗时 滚动监听 # window添加事件监听 window.addEventListener('scroll', () =\u0026gt; { // 处理 }); window注册滚动处理 window.onscroll = function () { // 处理 }; 进入判断 # document.addEventListener('DOMContentLoaded', () =\u0026gt; { const myToc = document.querySelector('.my-toc'); const fullToc = document.querySelector('.docs-toc'); if (!myToc || !fullToc) return; // 后续处理 }); 滚动计算 # 为标题排序, 厘清高亮标题在文章目录中的位置 # let i = 0; myToc.querySelectorAll('a').forEach(entry =\u0026gt; { entry.setAttribute('scrollIdx', i++); }); 文章目录结构 # .my-toc嵌套在.docs-toc中, .docs-toc多一个\u0026quot;文章目录\u0026quot;提示 根据.my-toc的滚动高度和其容纳的标题个数计算单个标题的高度 function computeHeadingHeight() { const toc = document.querySelector('.my-toc'); return toc.scrollHeight / toc.querySelectorAll('a').length; } 计算窗口能容纳的标题数，经过测试，取其1/6，可以使高亮标题始终处于文章目录偏上位置 function computeUpIdx() { const fullToc = document.querySelector('.docs-toc'); const myToc = document.querySelector('.my-toc'); const offset = fullToc.scrollHeight - myToc.scrollHeight; const max = parseInt((window.innerHeight - offset) / HeadingHeight); return parseInt(max / 6); } 添加全局变量, 保存单个标题高度和高亮标题理想位置 let HeadingHeight, UpIdx; HeadingHeight = computeHeadingHeight(); UpIdx = computeUpIdx(); 注册监听处理：重启定时器, 延时滚动文章目录 # let FollowTimer = null; // 全局 const FollowTimerInterval = 300; window.onscroll = function () { clearTimeout(FollowTimer); FollowTimer = setTimeout(function () { scrollFollow(); }, FollowTimerInterval); }; 实现文章目录滚动 # 无高亮标题, 不作处理；多个标题高亮时, 基于第一个标题计算滚动偏移 function scrollFollow() { const activeHeadings = document.querySelector('.my-toc').querySelectorAll('a.active'); if (activeHeadings.length \u0026gt; 0) { const heading = activeHeadings.item(0); const idx = heading.getAttribute('scrollIdx'); const scrollTarget = idx - upIdx; document.querySelector('.docs-toc').scrollTop = HeadingHeight * scrollTarget; } } 完整JavaScript代码 # let HeadingHeight, UpIdx; let FollowTimer = null; const FollowTimerInterval = 300; function computeHeadingHeight() { const toc = document.querySelector('.my-toc'); return toc.scrollHeight / toc.querySelectorAll('a').length; } function computeUpIdx() { const fullToc = document.querySelector('.docs-toc'); const myToc = document.querySelector('.my-toc'); const offset = fullToc.scrollHeight - myToc.scrollHeight; const max = parseInt((window.innerHeight - offset) / HeadingHeight); return parseInt(max / 6); } function scrollFollow() { const activeHeadings = document.querySelector('.my-toc').querySelectorAll('a.active'); if (activeHeadings.length \u0026gt; 0) { const heading = activeHeadings.item(0); const idx = heading.getAttribute('scrollIdx'); const scrollTarget = idx - UpIdx; document.querySelector('.docs-toc').scrollTop = HeadingHeight * scrollTarget; } } document.addEventListener('DOMContentLoaded', () =\u0026gt; { const myToc = document.querySelector('.my-toc'); const fullToc = document.querySelector('.docs-toc'); if (!myToc || !fullToc) return; let i = 0; myToc.querySelectorAll('a').forEach(entry =\u0026gt; { entry.setAttribute('scrollIdx', i++); }); HeadingHeight = computeHeadingHeight(); UpIdx = computeUpIdx(); window.onscroll = function () { clearTimeout(FollowTimer); FollowTimer = setTimeout(function () { scrollFollow(); }, FollowTimerInterval); }; }); "}),e.add({id:35,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%88%9D%E8%AF%86%E7%A2%B0%E6%92%9E/",title:"初识碰撞",description:"说明 # 虚幻编辑器 了解碰撞 # 碰撞 碰撞是世界中物体的物理交互 如Character的Capsule组件, 因为它的存在, 我们跳起后会落到地面, 而不是穿过地板; 我们可以上楼梯, 或是和另一个Character碰撞(而不是穿过他) Logical Trace 一条轨迹, 给定端点A和B, 计算与轨迹相交的场景中的物体 射击时通过该判断, 得到击中目标 在虚幻编辑器使用Console # 鼠标已由程序控制, 打开Console 按下 ` (apostrophe sign), 在视口下方会出现命令行, 可以输入debug命令 设置打开Console的快捷键 项目设置 \u0026gt; Engine \u0026gt; Input \u0026gt; Console \u0026gt; Console Keys 输出每秒帧数 # stat fps 在右上方角落显示, 一秒将近40帧, 40 x 25 ms = 1000 ms = 1 s 输出GPU统计数据 # stat GPU 隐藏debug信息 # 输入相同命令, 或 stat none 显示场景中碰撞相关 # show collision 可以看到Character的Capsule组件.",content:"说明 # 虚幻编辑器 了解碰撞 # 碰撞 碰撞是世界中物体的物理交互 如Character的Capsule组件, 因为它的存在, 我们跳起后会落到地面, 而不是穿过地板; 我们可以上楼梯, 或是和另一个Character碰撞(而不是穿过他) Logical Trace 一条轨迹, 给定端点A和B, 计算与轨迹相交的场景中的物体 射击时通过该判断, 得到击中目标 在虚幻编辑器使用Console # 鼠标已由程序控制, 打开Console 按下 ` (apostrophe sign), 在视口下方会出现命令行, 可以输入debug命令 设置打开Console的快捷键 项目设置 \u0026gt; Engine \u0026gt; Input \u0026gt; Console \u0026gt; Console Keys 输出每秒帧数 # stat fps 在右上方角落显示, 一秒将近40帧, 40 x 25 ms = 1000 ms = 1 s 输出GPU统计数据 # stat GPU 隐藏debug信息 # 输入相同命令, 或 stat none 显示场景中碰撞相关 # show collision 可以看到Character的Capsule组件. 这很方便, 因为碰撞组件纯逻辑, 在游戏中默认不可见 再次输入show collision关闭 碰撞选项 # 往场景中添加Cube和Sphere Place Actors \u0026gt; Shapes 碰撞选项 设置Character碰撞选项 # 设置CapsuleComponent的碰撞选项 # BP_STUBaseCharacter \u0026gt; Capsule Component \u0026gt; Details \u0026gt; Collision 碰撞预设默认为Pawn 将碰撞预设置为Custom 设置Sphere的碰撞选项 # 碰撞预设选择Custom 允许游戏角色Overlap Character不可通过Cube, 但可通过Sphere Charater与Sphere重叠时, CameraComponent会有交叉反应-放大镜头, 因为CameraComponent处于Character中间, 这是由SpringArm造成的 查看SpringArm组件 # BP_STUBaseCharacter \u0026gt; 选中SpringArmComponent \u0026gt; Details \u0026gt; Camera Collision \u0026gt; Probe Channel SpringArm组件需要知道如何与世界进行物理交互 Probe Channel Camera 我们可以修改 Sphere \u0026gt; Collision Responses \u0026gt; Trace Responses \u0026gt; Camera , 使得Character穿过Sphere时, CameraComponent忽略该事件 再次设置Sphere # Collision Responses \u0026gt; Trace Responses \u0026gt; Camera, 选择Ignore 之所以需要设置SpringArm的碰撞,因为当我们穿过墙时, 我们不应该可以看到墙的原先那一面 现在我们穿过Sphere, 感官上正常 重叠事件: 输出Actor信息 # 设置事件 # 打开BP_STUBaseCharacter \u0026gt; Event Graph 在 Event ActorBeginOverlap 之后, 执行PrintString(在屏幕打印) OtherActor作为PrintString输入, 实际输出产生碰撞的物体名称 为Sphere设置产生重叠事件 # Sphere \u0026gt; Details \u0026gt; 勾选 Generate Overlap Events 出于优化考虑, 默认false 日志 碰撞事件: 获取碰撞信息 # 设置Cube # 设置Collision Preset为Custom 勾选产生重叠事件 Generate Overlap Events 允许Pawn重叠 获取碰撞信息 # 选择Cube, 勾选 Simulation Generates Hit Events BP_STUBaseCharacter \u0026gt; EventGraph, 添加EventHit 自定义碰撞相关 # 项目设置 \u0026gt; Engine \u0026gt; Collision - Object Channels 物体类型 Trace Channels Preset 预设 自定义物体类型 # Object Channels 创建物体类型Enemy # 点击New Object Channel 命名为Enemy, Default Response为Block 创建物体类型Geometry # 点击New Object Channel, 命名为Geometry 设置Default Response为Ignore 其他类型自动忽略Geometry物体 查看Character对Geometry和Enemy的反馈 # - Enemy Block Geometry Ignore 设置Cube # 物体类型为Geometry 忽略Pawn 设置Sphere # 物体类型为Enemy 阻挡Pawn 预设 # 可以自定义预设规则, 如A类型物体对其他类型物体如何作出反应; 或者修改已有预设 "}),e.add({id:36,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%89%8D%E5%90%8E%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8/",title:"实现游戏角色前后左右移动",description:"概览 # 举例 轴映射 连续 前后左右移动 动作映射 离散 跳跃，装弹，更换武器 绑定移动键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 Scale MoveRight Left/A -1 Right/D 1 MoveForward Up/W 1 Down/S -1 实现前后左右移动逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 方向 输入处理 MoveForward MoveForward GetActorForwardVector AddMovementInput MoveRight MoveRight GetActorRightVector AddMovementInput 实现回调函数 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/InputComponent.h\u0026quot; void ASTUBaseCharacter::MoveForward(float Amount) { AddMovementInput(GetActorForwardVector(), Amount); } void ASTUBaseCharacter::MoveRight(float Amount) { AddMovementInput(GetActorRightVector(), Amount); } 绑定到函数描述 ShootThemUp: Player/STUBaseCharacter.",content:"概览 # 举例 轴映射 连续 前后左右移动 动作映射 离散 跳跃，装弹，更换武器 绑定移动键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 Scale MoveRight Left/A -1 Right/D 1 MoveForward Up/W 1 Down/S -1 实现前后左右移动逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 方向 输入处理 MoveForward MoveForward GetActorForwardVector AddMovementInput MoveRight MoveRight GetActorRightVector AddMovementInput 实现回调函数 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/InputComponent.h\u0026quot; void ASTUBaseCharacter::MoveForward(float Amount) { AddMovementInput(GetActorForwardVector(), Amount); } void ASTUBaseCharacter::MoveRight(float Amount) { AddMovementInput(GetActorRightVector(), Amount); } 绑定到函数描述 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;MoveForward\u0026quot;, this, \u0026amp;ASTUBaseCharacter::MoveForward); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;MoveRight\u0026quot;, this, \u0026amp;ASTUBaseCharacter::MoveRight); 添加函数声明 ShootThemUp: Player/STUBaseCharacter.h private 编译ShootThemUp "}),e.add({id:37,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%AD%BB%E4%BA%A1%E9%80%BB%E8%BE%91/",title:"添加游戏角色死亡逻辑",description:"说明 # 生命值修改时, 同步到HealthTextComponent组件 # 生命值为0，销毁游戏角色 # 死亡时, 播放死亡动画 # 动画剪辑 # Animation Montage 可以将多个动画组合播放。把希望连续播放的动画添加到时间线 timeline ，在代码或蓝图中播放动画剪辑 命名：以AM_打头 Slot # 若此时播放动画剪辑，输出输入动画和动画剪辑的拼接；若无动画剪辑在播放，输出输入动画 添加委托：当生命值更改时，同步到HealthTextComponent文本 # C++ 屏蔽当前HealthTextComponent文本的设置 # ShootThemUp: Player/STUBaseCharacter.cpp 屏蔽Tick函数中的文本更新 初始化HealthTextComponent文本 # ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); HealthComponent提供委托服务: 生命值修改通知 # - 多播 仅C++ 在HealthComponent定义委托类型FChangeHealthSignature # ShootThemUp: Components/STUHealthComponent.h DECLARE_MULTICAST_DELEGATE(FChangeHealthSignature); 添加数据成员OnChangeHealth，提供委托服务 # public ShootThemUp: Components/STUHealthComponent.h FChangeHealthSignature OnChangeHealth; 封装修改Health逻辑，调用时通知客户端 # 只能通过SetHealth接口修改生命值 函数定义 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::SetHealth(float NewHealth) { Health = NewHealth; OnChangeHealth.Broadcast(); } 函数声明 private ShootThemUp: Components/STUHealthComponent.",content:"说明 # 生命值修改时, 同步到HealthTextComponent组件 # 生命值为0，销毁游戏角色 # 死亡时, 播放死亡动画 # 动画剪辑 # Animation Montage 可以将多个动画组合播放。把希望连续播放的动画添加到时间线 timeline ，在代码或蓝图中播放动画剪辑 命名：以AM_打头 Slot # 若此时播放动画剪辑，输出输入动画和动画剪辑的拼接；若无动画剪辑在播放，输出输入动画 添加委托：当生命值更改时，同步到HealthTextComponent文本 # C++ 屏蔽当前HealthTextComponent文本的设置 # ShootThemUp: Player/STUBaseCharacter.cpp 屏蔽Tick函数中的文本更新 初始化HealthTextComponent文本 # ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); HealthComponent提供委托服务: 生命值修改通知 # - 多播 仅C++ 在HealthComponent定义委托类型FChangeHealthSignature # ShootThemUp: Components/STUHealthComponent.h DECLARE_MULTICAST_DELEGATE(FChangeHealthSignature); 添加数据成员OnChangeHealth，提供委托服务 # public ShootThemUp: Components/STUHealthComponent.h FChangeHealthSignature OnChangeHealth; 封装修改Health逻辑，调用时通知客户端 # 只能通过SetHealth接口修改生命值 函数定义 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::SetHealth(float NewHealth) { Health = NewHealth; OnChangeHealth.Broadcast(); } 函数声明 private ShootThemUp: Components/STUHealthComponent.h 修改OnTakeAnyDamage # ShootThemUp: Components/STUHealthComponent.cpp // Health -= Damage; SetHealth(Health - Damage); STUBaseCharacter注册委托服务: OnChangeHealth # - 仅C++ AddUObject 搭建框架: 注册生命值修改通知 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnChangeHealth() {} 注册委托服务 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthComponent-\u0026gt;OnChangeHealth.AddUObject(this, \u0026amp;ASTUBaseCharacter::OnChangeHealth); 函数声明 private ShootThemUp: Player/STUBaseCharacter.h 实现处理函数OnChangeHealth # 设置HealthTextComponent文本 ShootThemUp: Player/STUBaseCharacter.cpp // OnChangeHealth HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); Character和其组件调用BeginPlay的先后顺序 # 先调用Component的BeginPlay，再调用Character的BeginPlay。 先由HealthComponent在BeginPlay初始化Health, 才轮到Character在BeginPlay中注册服务。 若我们没有在Character的BeginPlay中初始化HealthTextComponent文本，当Character在BeginPlay中注册服务完成，HealthTextComponent 文本显示为0。直到Health再次被更改，Character才会收到通知同步。 游戏角色死亡后，生命值不再减少 # C++ 提供接口，判断Character是否死亡 # public ShootThemUp: Components/STUHealthComponent.h UFUNCTION(BlueprintCallable) bool IsDead() const { return Health \u0026lt;= 0.0f; } Character死亡之后，生命值不再减少 # 若伤害的数量特征不大于0，或者当前生命值不大于0，无法继续对Character造成伤害 ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage if (Damage \u0026lt;= 0.0f || IsDead()) return; 限制Health范围 # ShootThemUp: Components/STUHealthComponent.cpp // Health = NewHealth; Health = FMath::Clamp(NewHealth, 0.0f, MaxHealth); 添加委托：游戏角色死亡，销毁Character # C++ 当生命值发生改变时修改HealthText文本，当生命值变为0时销毁Character，一码归一码 HealthComponent提供委托服务: 游戏角色死亡通知 # - 多播 仅C++ 在HealthComponent定义委托类型FDeathSignature # ShootThemUp: Components/STUHealthComponent.h DECLARE_MULTICAST_DELEGATE(FDeathSignature); 添加数据成员OnDeath，提供委托服务 # public ShootThemUp: Components/STUHealthComponent.h FDeathSignature OnDeath; Character死亡，通知客户端 # ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage if (IsDead()) { OnDeath.Broadcast(); } STUBaseCharacter注册委托服务: OnDeath # - 仅C++ AddUObject 搭建框架: 注册死亡通知 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnDeath() {} 注册委托服务 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthComponent-\u0026gt;OnDeath.AddUObject(this, \u0026amp;ASTUBaseCharacter::OnDeath); 函数声明 private ShootThemUp: Player/STUBaseCharacter.h 实现处理函数OnDeath # 添加销毁延时 protected ShootThemUp: Player/STUBaseCharacter.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;10.0\u0026quot;)) float LifeSpanOnDeath = 5.0f; 检查CharacterMovement组件有效性 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay check(GetCharacterMovement()); 剥夺玩家对游戏角色的控制权，开启定时器销毁Character ShootThemUp: Player/STUBaseCharacter.cpp // OnDeath GetCharacterMovement()-\u0026gt;DisableMovement(); SetLifeSpan(LifeSpanOnDeath); 创建死亡动画剪辑 # 虚幻编辑器 之前的跳跃、跑步、转向动画，均对应状态机中的一个状态。如果游戏角色死亡拥有对应状态，每个状态都可能迁移到死亡状态，光是想想都觉得麻烦 使用动画剪辑 AnimMontage 资产，当游戏角色死亡时，播放死亡动画剪辑, 通过slot连接当前动画和死亡动画剪辑 创建AnimMontage资产 # - 死亡动画资产 ExternalContent/Animation/Animations/TTP_Animations/Death 选中死亡动画资产，右键 \u0026gt; Create \u0026gt; Create AnimMontage \u0026gt; 命名为AM_Death 移动到Content/Player/Animations路径下 在动画蓝图中添加Slot # ABP_BaseCharacter \u0026gt; AnimGraph 在Locomotion和OutputPose之间添加Slot # Slot和AM_Death的分组一致 # Slot - SlotName DefaultGroup.DefaultSlot AM_Death - Montage DefaultGroup.DefaultSlot 设置动画剪辑 # AM_Death 死亡动画结束后，不再播放其他动画 Asset Details \u0026gt; BlendOptions \u0026gt; EnableAutoBlendOut，取消勾选 游戏角色死亡时，播放动画剪辑 # C++ C++类型 动画剪辑 AnimMontage UAnimMontage 添加UAnimMontage类型数据成员 # protected ShootThemUp: Player/STUBaseCharacter.h UPROPERTY(EditDefaultsOnly) UAnimMontage *DeathAnimMontage; Character死亡时，播放动画剪辑 # ShootThemUp: Player/STUBaseCharacter.cpp // OnDeath PlayAnimMontage(DeathAnimMontage); 查看 # 虚幻编辑器 设置游戏角色死亡时播放的动画剪辑 BP_STUBaseCharacter 效果图 禁止移动Character之后，销毁Character之前，仍可以移动Camera；即，水平旋转视角时可以旋转Character "}),e.add({id:38,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E8%BD%A8%E8%BF%B9/",title:"轨迹",description:"概览 # Line Trace 本节介绍如何使用武器进行射击 Socket # 之前我们使用socket作为锚来附加武器 现在我们使用它来标记枪口 添加Muzzle Socket # 虚幻编辑器 之后会在代码中访问Socket, 以及从枪口发射子弹 双击打开 Content \u0026gt; ExternalContent \u0026gt; Weapon \u0026gt; Weapons \u0026gt; Rifle 选中 Skeleton Tree \u0026gt; RifleRoot , 右键, 选择Add Socket, 命名为MuzzleSocket 在细节面板设置Relative Location 默认在武器坐标系的0坐标, 调整到枪口位置, 和各个轴对齐 可以更换观察视角, 调整枪口变换 Top视角 沿着武器发射子弹的方向绘制线段 # C++ 添加MakeShot # 包含发射子弹的所有逻辑 把Fire和Shot分开 如温切斯特连发步枪, 扣一下扳机, 连发数枚子弹 timer for shooting 声明 # protected ShootThemUp: Weapon/STUBaseWeapon.h 空函数 # ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::MakeShot() {} 在Fire中调用 # 检查WeaponMeshComponent # 使用时不必检查 ShootThemUp: Weapon/STUBaseWeapon.",content:`概览 # Line Trace 本节介绍如何使用武器进行射击 Socket # 之前我们使用socket作为锚来附加武器 现在我们使用它来标记枪口 添加Muzzle Socket # 虚幻编辑器 之后会在代码中访问Socket, 以及从枪口发射子弹 双击打开 Content \u0026gt; ExternalContent \u0026gt; Weapon \u0026gt; Weapons \u0026gt; Rifle 选中 Skeleton Tree \u0026gt; RifleRoot , 右键, 选择Add Socket, 命名为MuzzleSocket 在细节面板设置Relative Location 默认在武器坐标系的0坐标, 调整到枪口位置, 和各个轴对齐 可以更换观察视角, 调整枪口变换 Top视角 沿着武器发射子弹的方向绘制线段 # C++ 添加MakeShot # 包含发射子弹的所有逻辑 把Fire和Shot分开 如温切斯特连发步枪, 扣一下扳机, 连发数枚子弹 timer for shooting 声明 # protected ShootThemUp: Weapon/STUBaseWeapon.h 空函数 # ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::MakeShot() {} 在Fire中调用 # 检查WeaponMeshComponent # 使用时不必检查 ShootThemUp: Weapon/STUBaseWeapon.cpp // BeginPlay check(WeaponMeshComponent); 实现MakeShot # 获取MuzzleSocket变换 # 添加Socket名
protected ShootThemUp: Weapon/STUBaseWeapon.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) FName MuzzleSocketName = \u0026quot;MuzzleSocket\u0026quot;; 获取Socket变换
参数 Socket名 相对于指定座标系的Socket变换, 默认值是世界座标系 ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot const FTransform SocketTransform = WeaponMeshComponent-\u0026gt;GetSocketTransform(MuzzleSocketName); // 默认世界坐标系 绘制线段 # 添加放大系数
ShootThemUp: Weapon/STUBaseWeapon.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float TraceMaxDistance = 1500.0f; // 1 unreal unit = 1cm \u0026gt; 15m 取出起点, 获取方向向量, 计算终点
- 起点 Socket位置 方向 Socket旋转单位向量 终点 起点 + 放大的方向向量 ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot const FVector TraceStart = SocketTransform.GetLocation(); const FVector ShootDirection = SocketTransform.GetRotation().GetForwardVector(); // 单位向量 // GetRotation返回类型FQuat // 在此处FQuat比FRotator更方便, 因为GetForwardVector的存在, 可以获取X轴分量 const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; 获取World对象
ShootThemUp: Weapon/STUBaseWeapon.cpp #include \u0026quot;Engine/World.h\u0026quot; // MakeShot if(!GetWorld()) return; 绘制线段
参数 bPersistentLines 是否一直存在 false LifeTime 持续时间, 单位s 3 DepthPriority 绘制优先级 0 ShootThemUp: Weapon/STUBaseWeapon.cpp #include \u0026quot;DrawDebugHelpers.h\u0026quot; // MakeShot DrawDebugLine(GetWorld(), TraceStart, TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); 在虚幻编辑器中查看 # 点击鼠标左键, 触发Fire 轨迹与枪口垂直 修改 Rifle 变换 当前 前进方向对应X轴方向, 使X轴绕Y轴逆时针旋转90度 Relative Rotation \u0026gt; Y=90 向上方向对应Z轴方向, 使其绕X轴顺时针旋转90度 Relative Rotation \u0026gt; X=-90 效果图 绘制相交点 # C++ 获取与轨迹相交的物体信息 # 需要获得线段与场景中的物体的交点. Engine提供了很多支持该功能的函数, 我们使用UWorld对象的一个功能 如果存在, LineTraceSingleByChannel通过函数参数返回与线段相交的第一个物体的信息 LineTraceSingleByChannel返回true则有相交, false则无; 而HitResult中亦有bBlockingHit - ECollisionChannel::ECC_Visibility 阻挡了Visibility的物体才参与相交计算 ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot FHitResult HitResult; GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility); HitResult存放相交信息 # 需要交点 - 相交时间 交点 ImpactPoint 法向量 指向相交Actor的指针 相交标志 bBlockingHit \u0026hellip; 绘制相交点 # ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot if (HitResult.bBlockingHit) { DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); } 查看相交点 # 虚幻编辑器 查看 BP_STUBaseCharacter \u0026gt; CapsuleComponent \u0026gt; Collision Collision Presets, 为Custom Trace Responses \u0026gt; Visibility为Block 为Overlap或Ignore时, 不会参与相交计算 射中时, 绘制球 瞄准十字和射击点不在一处 计算机游戏的射击机制 # C++ 子弹从枪口射出, 是对真实世界中的射击进行模拟 射击游戏中, 使子弹从Camera组件所在处设置, 该建模也适用于VR Virtual Reality 需要将玩家的CameraComponent作为计算起点 在Weapon类访问CameraComponent # 创建武器时, 为其指定Owner 我们在Actor中创建组件, 所以组件的Owner自动为Actor 创建Actor时, 需要为其配置Owner SpawnActor时, 通过FActorSpawnParameters; 或者调用SetOwner, 武器的Owner和WeaponComponent的Owner相同 ShootThemUp: Components/STUWeaponComponent.cpp // SpawnWeapon // CurrentWeapon-\u0026gt;SetOwner(GetOwner()); CurrentWeapon-\u0026gt;SetOwner(Character); 包含头文件 需要获取Character和Controller 通过Character获取Controller 通过Controller获取CameraComponent ShootThemUp: Weapon/STUBaseWeapon.cpp #include \u0026quot;GameFramework/Character.h\u0026quot; #include \u0026quot;GameFramework/PlayerController.h\u0026quot; 获取Controller ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot const auto Player = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Player) return; const auto Controller = Player-\u0026gt;GetController\u0026lt;APlayerController\u0026gt;(); if (!Controller) return; 获取CameraComponent的位置和朝向 PlayerCameraManager是全局类, 负责管理Camera, 可以直接获取Character的Camera组件 GetPlayerViewPoint访问PlayerCameraManager类 ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot FVector ViewLocation; FRotator ViewRotation; Controller-\u0026gt;GetPlayerViewPoint(ViewLocation, ViewRotation); 射击路线 # - 起点 Camera位置 朝向 Camera旋转的X轴分量 用以计算是否击中 ShootThemUp: Weapon/STUBaseWeapon.cpp const FVector TraceStart = ViewLocation; const FVector ShootDirection = ViewRotation.Vector(); const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; FHitResult HitResult; GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility); 绘制 # 起点是枪口, 若击中, 终点在击中物体上, 否则, 绘制射程的末尾 ShootThemUp: Weapon/STUBaseWeapon.cpp if (HitResult.bBlockingHit) { DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f); DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); } else { DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); } 查看游戏射击机制绘图 # 击中 未击中 实际是CameraComponent作为起点 终点和瞄准十字近似重合; 射击时游戏角色身体没有旋转 击中Mesh组件 # 虚幻编辑器 验证: 我们射击游戏角色时, 打中的是CapsuleComponent # 打开BP_STUBaseCharacter, 选择CapsuleComponent, 去到Details \u0026gt; Shape 当前 设置 - Capsule Half Height 88 Capsule Radius 88 在Console显示CapsuleComponent show collision 效果图 调整为击中骨骼网格体 # 设置CapsuleComponent BP_STUBaseCharacter \u0026gt; CapsuleComponent \u0026gt; Details \u0026gt; Collision \u0026gt; Collision Presets 当前 TraceResponses \u0026gt; Visibility为Block, 参与交叉计算 恢复为默认 TraceResponses \u0026gt; Visibility为Ignore, 不参与交叉计算 设置MeshComponent BP_STUBaseCharacter \u0026gt; CapsuleComponent \u0026gt; Details \u0026gt; Collision \u0026gt; Collision Presets 默认为CharacterMesh TraceResponses \u0026gt; Visibility为Ignore, 不参与交叉计算 设置为Custom 将TraceResponses \u0026gt; Visibility设置为Block, 参与交叉计算 查看 击中Mesh 可以击中两腿之间而不被CapsuleComponent阻挡 恢复CapsuleComponent的Shape 当前的问题: 射程的起点为Camera, 我们可以打到枪口无法打到的位置 # 从敌人的背后打到他 没调出来 解决思路: 限制轨迹和枪口方向的夹角为锐角 打到自己 没调出来 计算击中时忽略自己 # FCollisionQueryParams参数 将不参与相交计算的Actor添加到变量中 ShootThemUp: Weapon/STUBaseWeapon.cpp FCollisionQueryParams CollisionParams; // CollisionParams.AddIgnoredActor(Player); CollisionParams.AddIgnoredActor(GetOwner()); 修改相交计算的参数 ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility, CollisionParams); 射中时, 输出骨骼信息 # 对不同部位造成伤害时, 减少的生命值不同, 如爆头直接死亡 实现 # C++ ShootThemUp: Weapon/STUBaseWeapon.cpp // MakeShot UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Bone: %s\u0026quot;), *HitResult.BoneName.ToString()); 查看日志 # 虚幻编辑器 `}),e.add({id:39,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A7%86%E8%A7%92%E6%97%8B%E8%BD%AC/",title:"实现游戏角色视角旋转",description:"说明 # 视角旋转 垂直方向 抬头低头 Camera绕Y轴旋转 鼠标垂直方向位移决定旋转角度 水平方向 环顾左右 Camera绕Z轴旋转 鼠标水平方向位移决定旋转角度 绑定旋转键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 LookUp MouseY TurnAround MouseX 实现视角旋转逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 LookUp LookUp AddControllerPitchInput 绕Y轴旋转，增加Y轴旋转角度(Pitch) TurnAround TurnAround AddControllerYawInput 绕Z轴旋转，增加Z轴旋转角度(Yaw) 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::LookUp(float Amount) {} void ASTUBaseCharacter::TurnAround(float Amount) {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTUBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::TurnAround); 添加函数声明 ShootThemUp: Player/STUBaseCharacter.",content:"说明 # 视角旋转 垂直方向 抬头低头 Camera绕Y轴旋转 鼠标垂直方向位移决定旋转角度 水平方向 环顾左右 Camera绕Z轴旋转 鼠标水平方向位移决定旋转角度 绑定旋转键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 LookUp MouseY TurnAround MouseX 实现视角旋转逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 LookUp LookUp AddControllerPitchInput 绕Y轴旋转，增加Y轴旋转角度(Pitch) TurnAround TurnAround AddControllerYawInput 绕Z轴旋转，增加Z轴旋转角度(Yaw) 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::LookUp(float Amount) {} void ASTUBaseCharacter::TurnAround(float Amount) {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTUBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::TurnAround); 添加函数声明 ShootThemUp: Player/STUBaseCharacter.h private 添加静态日志类型 # ShootThemUp: Player/STUBaseCharacter.cpp DEFINE_LOG_CATEGORY_STATIC(LogBaseCharacter, All, All); 实现回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::LookUp(float Amount) { AddControllerPitchInput(Amount); UE_LOG(LogBaseCharacter, Log, TEXT(\u0026quot;LookUp Amount: %f\u0026quot;), Amount); } void ASTUBaseCharacter::TurnAround(float Amount) { AddControllerYawInput(Amount); } 编译ShootThemUp并运行 # 视角可以在水平方向旋转, 身体跟随旋转 无法在垂直方向旋转 查看日志，鼠标向上移动时，Amount为正数 使视角可以在垂直方向旋转 # 虚幻编辑器 CameraComponent的UsePawnControlRotation选项 # 设置CamerComponent是否跟随Pawn旋转 勾选 BP_STUBaseCharacter \u0026gt; CameraComponent \u0026gt; UsePawnControlRotation 选中Camera Component \u0026gt; 细节面板 \u0026gt; CameraOptions \u0026gt; 勾选UsePawnControlRotation 编译并运行 向下移动鼠标，Camera向上旋转; 向上移动鼠标，Camera向下旋转 旋转中心点为CameraComponent PlayerController的InputPitchScale选项 # 游戏角色旋转的逻辑是通过旋转PlayerController完成的 游戏角色视角垂直方向旋转反向InputPitchScale有关，该参数默认为负数, 已退化 参考 InputPitchScale, InputYawScale, InputRollScale的绝对值对应旋转速度 引擎版本 5.1 之前，可以在 PlayerController蓝图类 的细节面板查看 InputPitchScale 打印InputPitchScale # 解决方法一: 将InputPitchScale设为正数 # 解决方法二: 将LookUp的Scale改为-1 # 善后 # 采用解决方法二 去除 BP_STUPlayerController 中的打印和InputPitchScale设置 去除 C++ LookUp 中的日志打印 游戏角色视角绕Z轴旋转时，使中心点为游戏角色 # 为STUBaseCharacter添加USpringArmComponent类型成员 # C++ 添加SpringArmComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h // 前向声明 class USpringArmComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USpringArmComponent *SpringArmComponent; 初始化组件, 设置SpringArmComponent默认跟随Pawn旋转 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;GameFrameWork/SpringArmComponent.h\u0026quot; // 默认构造函数 SpringArmComponent = CreateDefaultSubobject\u0026lt;USpringArmComponent\u0026gt;(\u0026quot;SpringArmComponent\u0026quot;); SpringArmComponent-\u0026gt;SetupAttachment(GetRootComponent()); SpringArmComponent-\u0026gt;bUsePawnControlRotation = true; 修改CameraComponent的上级组件为SpringArmComponent ShootThemUp: Player/STUBaseCharacter.cpp // 默认构造函数 // CameraComponent-\u0026gt;SetupAttachment(GetRootComponent()); CameraComponent-\u0026gt;SetupAttachment(SpringArmComponent); 编译ShootThemUp 配置SpringArmComponent # 虚幻编辑器 BP_STUBaseCharacter 查看SpringArmComponent和CameraComponent # 关于bUsePawnControlRotation设置 # UCameraComponent 和 USpringArmComponent 均有该数据成员 在代码中设置 bUsePawnControlRotation ，设置的是类数据成员初始值。在蓝图编辑器中，对基于C++类的蓝图类数据成员恢复默认值，得到类数据成员初始值 为参数添加默认值，不会改变参数已有值 清除CameraComponent的相对变换，置UsePawnControlRotation为false # 设置SpringArmComponent和CameraComponent的相对变换 # 查看 SpringArmComponent 臂长参数 设置CameraComponent相对SpringArmComponent的偏移 CameraComponent和SpringArmComponent的bUsePawnControlRotation生效问题 # - 二者均为 true SpringArmComponent的生效，Camera以游戏角色为中心绕Y轴旋转 二者均为 false Camera不可绕Y轴旋转 仅 CameraComponent 的为true 以Camera为中心绕Y轴旋转 仅 SpringArmComponent 的为true Camera以游戏角色为中心绕Y轴旋转 为Character绑定动画 # 虚幻编辑器 BP_STUBaseCharacter 绑定动画 选中Mesh组件 \u0026gt; Details \u0026gt; Animation - Animation Mode Use Animation Asset Anim To Play Run_Fwd 可能存在动画下拉框无可选项的情况, 需要重新为动画绑定骨骼网格体 编译并运行 优化视角旋转逻辑 # C++ STUBaseCharacter LookUp, TurnAround, AddControllerPitchInput和AddControllerYawInput的函数签名一致 void LookUp(float Amount); void TurnAround(float Amount); void AddControllerPitchInput(float Val); void AddControllerYawInput(float Val) 屏蔽 LookUp 和 TurnAround ShootThemUp: Player/STUBaseCharacter.cpp ShootThemUp: Player/STUBaseCharacter.h 函数描述直接绑定 AddControllerPitchInput 和 AddControllerYawInput ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent // PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTUBaseCharacter::LookUp); // PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::TurnAround); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;Lookup\u0026quot;, this, \u0026amp;ASTUBaseCharacter::AddControllerPitchInput); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::AddControllerYawInput) 编译并运行 "}),e.add({id:40,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E8%A7%82%E5%AF%9F%E8%A7%86%E8%A7%92/",title:"添加观察视角",description:"说明 # 当游戏角色生命值为0，我们尝试剥夺玩家对游戏角色的控制，此时仍能旋转Camera; 左右旋转视角时, Character身体也会旋转 我们可以在游戏角色死亡时，切换玩家控制的Pawn：一方面，彻底剥夺玩家对游戏角色的控制，另一方面，允许玩家做合理的操作 观察视角 # 对应一个APawn派生类，ASpectatorPawn 关卡的默认类型里，观察者类使用ASpectatorPawn 玩家死亡后，使其操控SpectatorPawn，仍能继续观看游戏 场景中的SpectatorPawn # 漂浮的Camera，除了可以前后左右移动，还可以上下移动，亦支持旋转，由鼠标控制 本小节使用默认的观察者类 # 游戏角色死亡后，切换到观察视角 # C++ 先前我们已设置STUGameModeBase使用STUPlayerController类。 APawn::Controller和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STUPlayerController的。 游戏角色死亡时，切换到观察视角 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;GameFramework/Controller.h\u0026quot; // OnDeath if (Controller) { Controller-\u0026gt;ChangeState(NAME_Spectating); } 查看 # 虚幻编辑器 查看SpectatorPawn # WorldSetting中，GameMode默认选择SpectatorPawn作为Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 # Character死亡后，世界大纲新增SpectatorPawn1 ",content:"说明 # 当游戏角色生命值为0，我们尝试剥夺玩家对游戏角色的控制，此时仍能旋转Camera; 左右旋转视角时, Character身体也会旋转 我们可以在游戏角色死亡时，切换玩家控制的Pawn：一方面，彻底剥夺玩家对游戏角色的控制，另一方面，允许玩家做合理的操作 观察视角 # 对应一个APawn派生类，ASpectatorPawn 关卡的默认类型里，观察者类使用ASpectatorPawn 玩家死亡后，使其操控SpectatorPawn，仍能继续观看游戏 场景中的SpectatorPawn # 漂浮的Camera，除了可以前后左右移动，还可以上下移动，亦支持旋转，由鼠标控制 本小节使用默认的观察者类 # 游戏角色死亡后，切换到观察视角 # C++ 先前我们已设置STUGameModeBase使用STUPlayerController类。 APawn::Controller和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STUPlayerController的。 游戏角色死亡时，切换到观察视角 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;GameFramework/Controller.h\u0026quot; // OnDeath if (Controller) { Controller-\u0026gt;ChangeState(NAME_Spectating); } 查看 # 虚幻编辑器 查看SpectatorPawn # WorldSetting中，GameMode默认选择SpectatorPawn作为Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 # Character死亡后，世界大纲新增SpectatorPawn1 "}),e.add({id:41,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E9%87%8D%E6%9E%84makeshot/",title:"重构MakeShot",description:"说明 # 本节使用的重构被称作提取 The Extract Method , 将函数切分, 使得代码可读性更高 对武器类的MakeShot重构 纯理论逻辑放在protected, 供派生类调用 调整逻辑 # void ASTUBaseWeapon::MakeShot() { if(!GetWorld()) return; // 获取PlayerController const auto Player = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Player) return; const auto Controller = Player-\u0026gt;GetController\u0026lt;APlayerController\u0026gt;(); if (!Controller) return; // 通过Controller获取CameraComponent的位置和方向 FVector ViewLocation; FRotator ViewRotation; Controller-\u0026gt;GetPlayerViewPoint(ViewLocation, ViewRotation); // 通过CameraComponent的位置和方向计算轨迹信息 const FVector TraceStart = ViewLocation; const FVector ShootDirection = ViewRotation.Vector(); const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; // 提供轨迹获取碰撞信息 FHitResult HitResult; FCollisionQueryParams CollisionParams; CollisionParams.",content:"说明 # 本节使用的重构被称作提取 The Extract Method , 将函数切分, 使得代码可读性更高 对武器类的MakeShot重构 纯理论逻辑放在protected, 供派生类调用 调整逻辑 # void ASTUBaseWeapon::MakeShot() { if(!GetWorld()) return; // 获取PlayerController const auto Player = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Player) return; const auto Controller = Player-\u0026gt;GetController\u0026lt;APlayerController\u0026gt;(); if (!Controller) return; // 通过Controller获取CameraComponent的位置和方向 FVector ViewLocation; FRotator ViewRotation; Controller-\u0026gt;GetPlayerViewPoint(ViewLocation, ViewRotation); // 通过CameraComponent的位置和方向计算轨迹信息 const FVector TraceStart = ViewLocation; const FVector ShootDirection = ViewRotation.Vector(); const FVector TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; // 提供轨迹获取碰撞信息 FHitResult HitResult; FCollisionQueryParams CollisionParams; CollisionParams.AddIgnoredActor(GetOwner()); GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility, CollisionParams); // 获取枪口信息: 只用到了位置分量 const FTransform SocketTransform = WeaponMeshComponent-\u0026gt;GetSocketTransform(MuzzleSocketName); // 使用相交信息和枪口信息绘制轨迹和交点 if (HitResult.bBlockingHit) { DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f); DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Bone: %s\u0026quot;), *HitResult.BoneName.ToString()); } else { DrawDebugLine(GetWorld(), SocketTransform.GetLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); } } 拆分 # ShootThemUp: Weapon/STUBaseWeapon.cpp GetPlayerController # APlayerController *ASTUBaseWeapon::GetPlayerController() const { const auto Player = Cast\u0026lt;ACharacter\u0026gt;(GetOwner()); if (!Player) return nullptr; return Player-\u0026gt;GetController\u0026lt;APlayerController\u0026gt;(); } GetPlayerViewPoint # bool ASTUBaseWeapon::GetPlayerViewPoint(FVector \u0026amp;ViewLocation, FRotator \u0026amp;ViewRotation) const { const auto Controller = GetPlayerController(); if (!Controller) return false; Controller-\u0026gt;GetPlayerViewPoint(ViewLocation, ViewRotation); return true; } GetTraceData # bool ASTUBaseWeapon::GetTraceData(FVector\u0026amp; TraceStart, FVector\u0026amp; TraceEnd) const { FVector ViewLocation; FRotator ViewRotation; if (!GetPlayerViewPoint(ViewLocation, ViewRotation)) return false; TraceStart = ViewLocation; const FVector ShootDirection = ViewRotation.Vector(); TraceEnd = TraceStart + ShootDirection * TraceMaxDistance; return true; } MakeHit # void ASTUBaseWeapon::MakeHit(FHitResult \u0026amp;HitResult, const FVector \u0026amp;TraceStart, const FVector \u0026amp;TraceEnd) { if (!GetWorld()) return; FCollisionQueryParams CollisionParams; CollisionParams.AddIgnoredActor(GetOwner()); GetWorld()-\u0026gt;LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility, CollisionParams); } GetMuzzleWorldLocation # FVector ASTUBaseWeapon::GetMuzzleWorldLocation() const { return WeaponMeshComponent-\u0026gt;GetSocketLocation(MuzzleSocketName); } MakeShot # void ASTUBaseWeapon::MakeShot() { if (!GetWorld()) return; FVector TraceStart, TraceEnd; if (!GetTraceData(TraceStart, TraceEnd)) return; FHitResult HitResult; MakeHit(HitResult, TraceStart, TraceEnd); if (HitResult.bBlockingHit) { DrawDebugLine(GetWorld(), GetMuzzleWorldLocation(), HitResult.ImpactPoint, FColor::Red, false, 3.0f, 0, 3.0f); DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, 10.0f, 24, FColor::Red, false, 5.0f); // UE_LOG(LogBaseWeapon, Display, TEXT(\u0026quot;Bone: %s\u0026quot;), *HitResult.BoneName.ToString()); } else { DrawDebugLine(GetWorld(), GetMuzzleWorldLocation(), TraceEnd, FColor::Red, false, 3.0f, 0, 3.0f); } } 添加声明 # protected ShootThemUp: Weapon/STUBaseWeapon.h APlayerController *GetPlayerController() const; bool GetPlayerViewPoint(FVector \u0026amp;ViewLocation, FRotator \u0026amp;ViewRotation) const; bool GetTraceData(FVector\u0026amp; TraceStart, FVector\u0026amp; TraceEnd) const; void MakeHit(FHitResult \u0026amp;HitResult, const FVector \u0026amp;TraceStart, const FVector \u0026amp;TraceEnd); FVector GetMuzzleWorldLocation() const; "}),e.add({id:42,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%B8%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%B7%BB%E5%8A%A0%E5%90%91%E5%89%8D%E8%B5%B0%E8%B7%AF%E5%8A%A8%E7%94%BB/",title:"为游戏角色添加向前走路动画",description:"概览 # 虚幻编辑器 动画随着游戏角色的运动速度而变化 brush # 最简单的可编辑几何体，我们可以修改其顶点位置，调整其他参数，然后将其转换成静态网格体 CharacterMovementComponent # 负责 Character 运动，其各种属性均和 Character 运动有关 动画蓝图 # Animation Blueprint 动画蓝图需绑定 Skeleton Mesh 命名：ABP_ 打头 动画混合 # Animation Blend 流畅地从一个动画切入到另一个动画 混合空间 # Blend Space 能在两个骨骼动画之间创建过渡动画 使用插值来得到动画姿势的中间值 需绑定 Skeleton Mesh 命名： 混合空间 和 混合空间1D 均以 BS_ 打头 一维混合空间 # Blend Space 1D 横轴 混合空间 # Blend Space 横轴和纵轴 重新设置平台 # 从场景中移除Floor 添加 Geometry/Box 恢复 Box Brush 默认位置，设置长宽高 Character运动速度上限 # BP_STUBaseCharacter CharacterMovementComponent 选择CharacterMovementComponent \u0026gt; 细节面板 \u0026gt; Character Movement: Walking \u0026gt; MaxWalkSpeed MaxWalkSpeed 即 Character 的最大运动速度，单位 cm/s 虚幻引擎里的步长使用 cm 修改 MaxWalkSpeed ，当速度改为 1600 时，可以看到单位时间内移动的距离增加，而跑步动画缺少对应的加速过程 获取实时速度并打印 # BP_STUBaseCharacter 在 EventGraph 实现 - GetVelocity函数 获取Character速度 获得Actor各个方向上的速度，保存在FVector中 FVector::VectorLength 获得速度标量 PrintString 在屏幕上输出实时速度 PrintString 使用 AddOnScreenDebugMessage 可以看到加速过程 移除打印 创建动画蓝图ABP_BaseCharacter # Animation Blueprint 创建文件夹Content/Players/Animations # 方法一: 基于Skeleton Mesh创建动画蓝图 # 选中ExternalContent/Animation/Characters/HeroTPP/HeroTPP \u0026gt; 右键 \u0026gt; Create \u0026gt; AnimBlueprint 方法二: 在指定位置创建动画蓝图 # 去到 Content/Player/Animations，右键 \u0026gt; Animation \u0026gt; 选择Animation Blueprint 选择 HeroTPP_Skeleton 命名为 ABP_BaseCharacter 在蓝图编辑器中查看动画蓝图 # ABP_BaseCharacter - EventGraph 事件图表 处理各种动画事件；像使用 Tick 一样使用 EventBlueprintUpdateAnimation AnimGraph 动画图表 处理所有动画；可以将动画资产作为 OutputPose 的输入 AssetBrowser 动画资产窗口 可以从 Window \u0026gt; AssetBrowser 打开，罗列了 SkeletonMesh 所有相关动画 为游戏角色设置动画时使用动画蓝图 # 为ABP_BaseCharacter设置输入 # 动画图表 将 Run_Fwd 作为 OutputPose 的输入 设置 Run_Fwd 重复播放 选中Run_Fwd \u0026gt; Details \u0026gt; Settings \u0026gt; 使能 LoopAnimation 让Character使用动画蓝图 # BP_STBaseCharacter - Animation Mode Use Animation Blueprint Anim Class ABP_BaseCharacter 查看动画资产 # 去到Content/ExternalContent/Animation/Animations/TTP_Animations，双击 Run_Fwd 可在 AssetBrowser 中选择其他动画 混合空间资产 # Blend Space 速度从 0 - 600 ，动画从 Idle 过渡到 Run_Fwd 创建BS_Locomotion_Walk_1D # 去到Content/Player/Animations，右键 选择 HeroTPP_Skeleton 命名为 BS_Locomotion_Walk_1D 配置BS_Locomotion_Walk_1D # 双击打开 BS_Locomotion_Walk_1D 配置横轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis 说明 Name 名称 Velocity Minimum Axis Value 轴最小值 0 Maximum Axis Value 轴最大值 600 游戏角色运动速度上限 Grid Divisions 过渡区间 4 使用默认值；和可以添加的动画个数有关 配置动画 动画资产 Velocity 起点 Idle 0 终点 Run_Fwd 600 查看插值 系统 键位 Windows Control MacOS Command 按下键位，水平移动鼠标，绿色X随之在起点和终点间移动，视口展示过渡动画 将BS_Locomotion_Walk_1D作为动画蓝图输入 # ABP_BaseCharacter 添加变量Velocity # 在 MyBlueprint 添加变量 Velocity ，在Details设置名称和类型 设置变量Velocity # EventGraph 将变量Velocity拖动到EventGraph, 选择设置变量值 在 EventBlueprintUpdateAnimation 之后，执行 SetVelocity GetPawnOwner 返回 Pawn 实例的引用, 变量 Velocity 的输入是 Actor 实时速度 设置动画蓝图输入 # AnimGraph 将BS_Locomotion_Walk_1D作为OutputPose的输入 将变量Velocity拖动到AnimGraph, 选择获取变量值 将变量Velocity作为BS_Locomotion_Walk_1D的输入 ",content:"概览 # 虚幻编辑器 动画随着游戏角色的运动速度而变化 brush # 最简单的可编辑几何体，我们可以修改其顶点位置，调整其他参数，然后将其转换成静态网格体 CharacterMovementComponent # 负责 Character 运动，其各种属性均和 Character 运动有关 动画蓝图 # Animation Blueprint 动画蓝图需绑定 Skeleton Mesh 命名：ABP_ 打头 动画混合 # Animation Blend 流畅地从一个动画切入到另一个动画 混合空间 # Blend Space 能在两个骨骼动画之间创建过渡动画 使用插值来得到动画姿势的中间值 需绑定 Skeleton Mesh 命名： 混合空间 和 混合空间1D 均以 BS_ 打头 一维混合空间 # Blend Space 1D 横轴 混合空间 # Blend Space 横轴和纵轴 重新设置平台 # 从场景中移除Floor 添加 Geometry/Box 恢复 Box Brush 默认位置，设置长宽高 Character运动速度上限 # BP_STUBaseCharacter CharacterMovementComponent 选择CharacterMovementComponent \u0026gt; 细节面板 \u0026gt; Character Movement: Walking \u0026gt; MaxWalkSpeed MaxWalkSpeed 即 Character 的最大运动速度，单位 cm/s 虚幻引擎里的步长使用 cm 修改 MaxWalkSpeed ，当速度改为 1600 时，可以看到单位时间内移动的距离增加，而跑步动画缺少对应的加速过程 获取实时速度并打印 # BP_STUBaseCharacter 在 EventGraph 实现 - GetVelocity函数 获取Character速度 获得Actor各个方向上的速度，保存在FVector中 FVector::VectorLength 获得速度标量 PrintString 在屏幕上输出实时速度 PrintString 使用 AddOnScreenDebugMessage 可以看到加速过程 移除打印 创建动画蓝图ABP_BaseCharacter # Animation Blueprint 创建文件夹Content/Players/Animations # 方法一: 基于Skeleton Mesh创建动画蓝图 # 选中ExternalContent/Animation/Characters/HeroTPP/HeroTPP \u0026gt; 右键 \u0026gt; Create \u0026gt; AnimBlueprint 方法二: 在指定位置创建动画蓝图 # 去到 Content/Player/Animations，右键 \u0026gt; Animation \u0026gt; 选择Animation Blueprint 选择 HeroTPP_Skeleton 命名为 ABP_BaseCharacter 在蓝图编辑器中查看动画蓝图 # ABP_BaseCharacter - EventGraph 事件图表 处理各种动画事件；像使用 Tick 一样使用 EventBlueprintUpdateAnimation AnimGraph 动画图表 处理所有动画；可以将动画资产作为 OutputPose 的输入 AssetBrowser 动画资产窗口 可以从 Window \u0026gt; AssetBrowser 打开，罗列了 SkeletonMesh 所有相关动画 为游戏角色设置动画时使用动画蓝图 # 为ABP_BaseCharacter设置输入 # 动画图表 将 Run_Fwd 作为 OutputPose 的输入 设置 Run_Fwd 重复播放 选中Run_Fwd \u0026gt; Details \u0026gt; Settings \u0026gt; 使能 LoopAnimation 让Character使用动画蓝图 # BP_STBaseCharacter - Animation Mode Use Animation Blueprint Anim Class ABP_BaseCharacter 查看动画资产 # 去到Content/ExternalContent/Animation/Animations/TTP_Animations，双击 Run_Fwd 可在 AssetBrowser 中选择其他动画 混合空间资产 # Blend Space 速度从 0 - 600 ，动画从 Idle 过渡到 Run_Fwd 创建BS_Locomotion_Walk_1D # 去到Content/Player/Animations，右键 选择 HeroTPP_Skeleton 命名为 BS_Locomotion_Walk_1D 配置BS_Locomotion_Walk_1D # 双击打开 BS_Locomotion_Walk_1D 配置横轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis 说明 Name 名称 Velocity Minimum Axis Value 轴最小值 0 Maximum Axis Value 轴最大值 600 游戏角色运动速度上限 Grid Divisions 过渡区间 4 使用默认值；和可以添加的动画个数有关 配置动画 动画资产 Velocity 起点 Idle 0 终点 Run_Fwd 600 查看插值 系统 键位 Windows Control MacOS Command 按下键位，水平移动鼠标，绿色X随之在起点和终点间移动，视口展示过渡动画 将BS_Locomotion_Walk_1D作为动画蓝图输入 # ABP_BaseCharacter 添加变量Velocity # 在 MyBlueprint 添加变量 Velocity ，在Details设置名称和类型 设置变量Velocity # EventGraph 将变量Velocity拖动到EventGraph, 选择设置变量值 在 EventBlueprintUpdateAnimation 之后，执行 SetVelocity GetPawnOwner 返回 Pawn 实例的引用, 变量 Velocity 的输入是 Actor 实时速度 设置动画蓝图输入 # AnimGraph 将BS_Locomotion_Walk_1D作为OutputPose的输入 将变量Velocity拖动到AnimGraph, 选择获取变量值 将变量Velocity作为BS_Locomotion_Walk_1D的输入 "}),e.add({id:43,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%8A%A8%E6%B2%BB%E7%96%97/",title:"自动治疗",description:"说明 # C++ 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现 获取定时器管理对象 UActorComponent::GetOwner \u0026gt; AActor::GetWorldTimerManager UActorComponent::GetWorld \u0026gt; UWorld::GetTimerManager 实现自动治疗 # 添加治疗参数 # protected 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealDelay = 3.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealModifier = 5.0f; 添加定时器 # 添加数据成员 # private ShootThemUp: Components/STUHealthComponent.",content:`说明 # C++ 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现 获取定时器管理对象 UActorComponent::GetOwner \u0026gt; AActor::GetWorldTimerManager UActorComponent::GetWorld \u0026gt; UWorld::GetTimerManager 实现自动治疗 # 添加治疗参数 # protected 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealDelay = 3.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealModifier = 5.0f; 添加定时器 # 添加数据成员 # private ShootThemUp: Components/STUHealthComponent.h FTimerHandle HealTimer; 搭建框架 # 添加空的回调函数
ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnHeal() {} 定时器接口
ShootThemUp: Components/STUHealthComponent.cpp 头文件 #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;TimerManager.h\u0026quot; 开启定时器 void USTUHealthComponent::StartHealTimer() { if (AutoHeal \u0026amp;\u0026amp; GetWorld()) { GetWorld()-\u0026gt;GetTimerManager().SetTimer(HealTimer, this, \u0026amp;USTUHealthComponent::OnHeal, HealRate, true, HealDelay); } } 关闭定时器 void USTUHealthComponent::StopHealTimer() { if (AutoHeal \u0026amp;\u0026amp; GetWorld()) { GetWorld()-\u0026gt;GetTimerManager().ClearTimer(HealTimer); } } 接口声明 private ShootThemUp: Components/STUHealthComponent.h 回调函数声明
private ShootThemUp: Components/STUHealthComponent.h 回调函数实现 # ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnHeal() { SetHealth(Health + HealModifier); if (FMath::IsNearlyEqual(Health, MaxHealth)) { StopHealTimer(); } } 游戏角色受到伤害延缓治疗 # ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnTakeAnyDamage(AActor *DamagedActor, float Damage, const UDamageType *DamageType, AController *InstigatedBy, AActor *DamageCauser) { if (Damage \u0026lt;= 0.0f || IsDead()) return; if (!FMath::IsNearlyEqual(Health, MaxHealth)) StopHealTimer(); // Health -= Damage; SetHealth(Health - Damage); UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;Damage: %.0f\u0026quot;), Damage); if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTUFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTUIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !!!\u0026quot;)); } } if (IsDead()) { OnDeath.Broadcast(); } else { StartHealTimer(); } } 重写IsDead # ShootThemUp: Components/STUHealthComponent.h bool IsDead() const { return FMath::IsNearlyZero(Health); } `}),e.add({id:44,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E5%B0%84%E5%87%BB%E4%BC%A4%E5%AE%B3/",title:"射击伤害",description:"说明 # 从交点获取击中的Actor信息 创建MakeDamage, 击中目标时调用, 传入相交信息 # C++ 搭建框架 # 声明 preotected ShootThemUp: Weapon/STUBaseWeapon.h void MakeDamage(const FHitResult\u0026amp; HitResult); 空定义 ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::MakeDamage(const FHitResult\u0026amp; HitResult) {} MakeShot中调用 ShootThemUp: Weapon/STUBaseWeapon.cpp 实现MakeDamage # 获取击中的Actor ShootThemUp: Weapon/STUBaseWeapon.cpp const auto DamagedActor = HitResult.GetActor(); if (!DamagedActor) return; 添加数据成员: 伤害值 protected ShootThemUp: Weapon/STUBaseWeapon.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float DamageAmount = 10.0f; 对Actor造成伤害, 直接对其调用TakeDamage DamagedActor-\u0026gt;TakeDamage(DamageAmount, FDamageEvent(), GetPlayerController(), this); 查看 # 虚幻编辑器 对游戏角色造成射击伤害 游戏角色死亡 角色死亡播放死亡动画倒地, CapsuleComponent成为障碍物 # 虚幻编辑器 运行时显示CapsuleComponent show collision 游戏角色死亡, CapsuleComponent成为障碍物 死亡处理函数中, 禁止CapsuleComponent的碰撞 # C++ ShootThemUp: Player/STUBaseCharacter.",content:"说明 # 从交点获取击中的Actor信息 创建MakeDamage, 击中目标时调用, 传入相交信息 # C++ 搭建框架 # 声明 preotected ShootThemUp: Weapon/STUBaseWeapon.h void MakeDamage(const FHitResult\u0026amp; HitResult); 空定义 ShootThemUp: Weapon/STUBaseWeapon.cpp void ASTUBaseWeapon::MakeDamage(const FHitResult\u0026amp; HitResult) {} MakeShot中调用 ShootThemUp: Weapon/STUBaseWeapon.cpp 实现MakeDamage # 获取击中的Actor ShootThemUp: Weapon/STUBaseWeapon.cpp const auto DamagedActor = HitResult.GetActor(); if (!DamagedActor) return; 添加数据成员: 伤害值 protected ShootThemUp: Weapon/STUBaseWeapon.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) float DamageAmount = 10.0f; 对Actor造成伤害, 直接对其调用TakeDamage DamagedActor-\u0026gt;TakeDamage(DamageAmount, FDamageEvent(), GetPlayerController(), this); 查看 # 虚幻编辑器 对游戏角色造成射击伤害 游戏角色死亡 角色死亡播放死亡动画倒地, CapsuleComponent成为障碍物 # 虚幻编辑器 运行时显示CapsuleComponent show collision 游戏角色死亡, CapsuleComponent成为障碍物 死亡处理函数中, 禁止CapsuleComponent的碰撞 # C++ ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/CapsuleComponent.h\u0026quot; // OnDeath GetCapsuleComponent()-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore); // 对所有channel的碰撞反馈统一进行设置 注意到游戏角色死亡后, 武器还在 # 虚幻编辑器 "}),e.add({id:45,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%B7%B3%E8%B7%83/",title:"实现游戏角色跳跃",description:"概览 # 状态机 # State Machine 定义多个状态，每个状态对应一个动画 在一个动画蓝图中管理多个状态，并定义状态之间的迁移条件 ACharacter::IsFalling # 当Character在空中时返回true，Character落地时返回false 绑定跳跃键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Jump SpaceBar 实现跳跃逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Jump Jump 回调函数由虚幻引擎提供，按下时触发 绑定函数描述和回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Jump\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::Jump); 使用状态机实现跳跃动画 # 虚幻编辑器 实现跳跃动画 # ABP_BaseCharacter 添加状态机, 将其作为OutPose的输入 # AnimGraph 添加 状态机 ，命名为 Locomotion 将 Locomotion 作为 OutputPose 的输入 状态机说明 # 跳跃动画资产 - JumpStart 跳起 JumpLoop 在空中 JumpEnd 落地 状态 - Walk JumpStart JumpLoop JumpEnd 状态迁移 - Walk \u0026gt; JumpStart 游戏角色在空中 JumpStart \u0026gt; JumpLoop JumpStart 动画播放结束 JumpLoop \u0026gt; JumpEnd 游戏角色落地 JumpEnd \u0026gt; Walk JumpEnd 动画播放结束 实现状态机 # 双击Locomotion，进入状态机",content:`概览 # 状态机 # State Machine 定义多个状态，每个状态对应一个动画 在一个动画蓝图中管理多个状态，并定义状态之间的迁移条件 ACharacter::IsFalling # 当Character在空中时返回true，Character落地时返回false 绑定跳跃键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Jump SpaceBar 实现跳跃逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Jump Jump 回调函数由虚幻引擎提供，按下时触发 绑定函数描述和回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Jump\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::Jump); 使用状态机实现跳跃动画 # 虚幻编辑器 实现跳跃动画 # ABP_BaseCharacter 添加状态机, 将其作为OutPose的输入 # AnimGraph 添加 状态机 ，命名为 Locomotion 将 Locomotion 作为 OutputPose 的输入 状态机说明 # 跳跃动画资产 - JumpStart 跳起 JumpLoop 在空中 JumpEnd 落地 状态 - Walk JumpStart JumpLoop JumpEnd 状态迁移 - Walk \u0026gt; JumpStart 游戏角色在空中 JumpStart \u0026gt; JumpLoop JumpStart 动画播放结束 JumpLoop \u0026gt; JumpEnd 游戏角色落地 JumpEnd \u0026gt; Walk JumpEnd 动画播放结束 实现状态机 # 双击Locomotion，进入状态机
仅一个入口 Entry 移植Walk状态
为 Locomotion 添加 State ，命名为 Walk ，使 Entry 指向 双击 Walk 将OutputPose之前的输入， Velocity + BS_Locomotion_Walk_1D 封装到 Walk 状态（剪切）， 作为其 OutputAnimationPose 的输入 至此， Character 的运动动画和上一小节一致 实现跳跃状态
添加布尔型变量IsFalling
上一小节中，变量 Velocity 横跨 ABP_BaseCharacter 的 EventGraph 和 AnimGraph ，这里，布尔类型变量 IsFalling 也一样 在 EventGraph 设置变量值，在 AnimGraph 中使用变量 使用ACharacter::IsFalling设置变量IsFalling
EventGraph 将Pawn转换为Character
接着设置Velocity, 将Pawn转换为Character 不能同时从 EventBlueprintUpdateAnimation 出发， SetVelocity 之后，执行转换 双击 TryGetPawnOwner 和 CastToCharacter 连线上的一点，创建Bezier曲线，排线更易整理 对ACharacter::CharacterMovement调用ACharacter::IsFalling
接着CastToCharacter, 设置IsFalling 从 CaseToCharacter \u0026gt; AsCharacter 到 IsFalling \u0026gt; Target ，自动添加提取数据成员; IsFalling 函数的返回类型是布尔，作为 SetIsFalling 的输入 完整EventGraph
实现状态机
回到 Locomotion 从 AssetBrowser 把 Jump 的三个动画拖入 Locomotion 动画自动被封装为 State ，和之前 AddState ，再将动画作为状态输入达到的效果一样 添加状态迁移路径 添加状态迁移条件 状态迁移 触发条件 Walk \u0026gt; JumpStart 游戏角色在空中 ACharacter::IsFalling 返回true JumpStart \u0026gt; JumpLoop JumpStart 动画播放结束 TimeRemaining \u0026lt; 0.1 JumpLoop \u0026gt; JumpEnd 游戏角色落地 ACharacter::IsFalling 返回true JumpEnd \u0026gt; Walk JumpEnd 动画播放结束 TimeRemaining \u0026lt; 0.1 双击转换图标，即可为状态迁移添加迁移条件 拿 Walk \u0026gt; JumpStart 举例 Walk \u0026gt; JumpStart 迁移条件：变量 IsFalling 为 true JumpStart \u0026gt; JumpLoop 迁移条件： JumpStart 动画将近结束 JumpLoop \u0026gt; JumpEnd 迁移条件：变量 IsFalling 为 false JumpEnd \u0026gt; Walk 迁移条件： JumpEnd 将近结束 设置 State 输入动画是否循环播放 - BS_Locomotion_Walk_1D 循环播放 JumpStart 播放一次 JumpLoop 循环播放 JumpEnd 播放一次 拿 JumpStart 状态举例: 选中JumpStart动画 \u0026gt; Details \u0026gt; Settings \u0026gt; LoopAnimation 为true 如此设置还可修复Character跳跃时的卡顿 添加楼梯，查看Jump三阶段是否正常显示 # 添加楼梯 PlaceActors \u0026gt; Geometry \u0026gt; LinearStair 设置阶数 选中LinearStairBrush \u0026gt; Details \u0026gt; BrushSettings \u0026gt; NumSteps 将楼梯移动到合适位置 游戏角色从楼梯跳到平面时，循环 JumpLoop 跑步时跳跃，落地后会平滑一段距离 跳跃时Z方向速度 # BP_STUBaseCharacter JumpZVelocity不宜过大, 不然 JumpStart 动画播放结束，速度却未减为0，此时Character还在上升，却在播放 JumpLoop - Vz \u0026gt; 0 JumpStart 该过程应 近似 JumpStart 播放时长 Vz \u0026lt;= 0 JumpLoop 从临界点落下 Vz = 0 JumpEnd `}),e.add({id:46,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%9D%A0%E8%90%BD%E4%BC%A4%E5%AE%B3/",title:"坠落伤害",description:"说明 # C++ 落地速度Z方向的分量和坠落高度有关；速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落机制 # Character定义了坠落委托类型FLandedSignature，并有该类型成员ACharacter::LandedDelegate 委托类型的处理函数签名 void handler(const FHitResult\u0026amp; Hit); 该委托类型支持蓝图 Character在ACharacter::Landed通知客户端 思路 # 我们可以注册LandedDelegate的委托服务，也可以覆写ACharacter::Landed，添加相应处理 选择注册委托服务 坠落伤害计算 # 参数 - 坠落伤害范围 LandedDamageRange [c, d] 落地速度范围 LandedDamageVelocityRange [a, b] 落地速度和对应的伤害 速度 伤害 \u0026lt; a 无伤 [a, b] [c, d] c + (Velocity - a) (d - c) / (b - a) \u0026gt; b d 获取Character速度 APawn::GetVelocity ACharacter:: GetCharacterMovement \u0026gt; UCharacterMovementComponent::Velocity 添加坠落伤害参数 # protected ShootThemUp: Player/STUBaseCharacter.",content:"说明 # C++ 落地速度Z方向的分量和坠落高度有关；速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落机制 # Character定义了坠落委托类型FLandedSignature，并有该类型成员ACharacter::LandedDelegate 委托类型的处理函数签名 void handler(const FHitResult\u0026amp; Hit); 该委托类型支持蓝图 Character在ACharacter::Landed通知客户端 思路 # 我们可以注册LandedDelegate的委托服务，也可以覆写ACharacter::Landed，添加相应处理 选择注册委托服务 坠落伤害计算 # 参数 - 坠落伤害范围 LandedDamageRange [c, d] 落地速度范围 LandedDamageVelocityRange [a, b] 落地速度和对应的伤害 速度 伤害 \u0026lt; a 无伤 [a, b] [c, d] c + (Velocity - a) (d - c) / (b - a) \u0026gt; b d 获取Character速度 APawn::GetVelocity ACharacter:: GetCharacterMovement \u0026gt; UCharacterMovementComponent::Velocity 添加坠落伤害参数 # protected ShootThemUp: Player/STUBaseCharacter.h UPROPERTY(EditDefaultsOnly) FVector2D LandedDamageVelocityRange = {900.0f, 1200.0f}; UPROPERTY(EditDefaultsOnly)	FVector2D LandedDamageRange = {10.0f, 100.0f}; 注册坠落伤害的委托服务 # 搭建框架 # 添加空函数 OnLanded函数名已被使用 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnGroundLanded(const FHitResult \u0026amp;Hit) {} 注册服务 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay LandedDelegate.AddDynamic(this, \u0026amp;ASTUBaseCharacter::OnGroundLanded); 函数声明 private ShootThemUp: Player/STUBaseCharacter.h UFUNCTION() void OnGroundLanded(const FHitResult\u0026amp; Hit); 实现处理函数 # 坠落伤害属于环境伤害，无伤害源(Actor)和阵营(Controller) ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnGroundLanded(const FHitResult \u0026amp;Hit) { float Velocity = -GetVelocity().Z; if (Velocity \u0026lt; LandedDamageVelocityRange.X) return; float LandedDamage = FMath::GetMappedRangeValueClamped(LandedDamageVelocityRange, LandedDamageRange, Velocity); TakeDamage(LandedDamage, FDamageEvent{}, nullptr, nullptr); } "}),e.add({id:47,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/%E7%9E%84%E5%87%86%E5%81%8F%E7%A7%BB/",title:"瞄准偏移",description:`概览 # Aim Offset 瞄准偏移资产 # Aim Offset 专门用于瞄准 有常规和1D两种, 和混合空间一样 常规AimOffset有两个轴, 覆盖瞄准在水平和垂直方向的偏移 需要绑定骨骼网格体 命名前缀为AO_ 本节会创建瞄准偏移资产, 支持水平和垂直方向的偏移, 但只使用垂直方向的偏移 # 射击瞄准相较之前自然一些 使用到的动画资产 # - AimOffsetFwd AimOffsetUp AimOffsetDown AimOffsetLeft AimOfsetLeftDown AimOffsetLeftUp AimOffsetRight AimOfsetRightDown AimOffsetRightUp 垂直方向的偏移来自CameraComponent前进向量在垂直方向的分量 # 通过游戏角色控制器旋转CameraComponent实现游戏角色的视角旋转 水平旋转游戏角色时, 身体跟随 绘制CameraComponent的前进向量 # 获取CameraComponent的旋转分量, 通过旋转分量获取前进向量 在动画蓝图EventGraph计算CameraComponent旋转分量 # ABP_BaseCharacter \u0026gt; EventGraph 获取CameraComponent的旋转分量 # - 输入 Pawn 函数 GetBaseAimRotation: 通过Pawn的Controller返回游戏角色CameraComponent的旋转分量 保存旋转分量到变量, AnimGraph中会用到
Promote to Variable 变量列表出现新变量, 命名为AimRotation 完整实现
根据旋转分量获取CameraComponent的前进分量, 使用DrawDebugLine绘制 # - 起点 游戏角色位置 Pawn \u0026gt; GetActorLocation 偏移 放大的CameraComponent前进向量 Pawn \u0026gt; GetBaseAimRotation \u0026gt; GetForwardVector 终点 起点 + 偏移 乘法输入转为float: 右键另一个输入 DrawDebugLine参数 - Duration 0.`,content:`概览 # Aim Offset 瞄准偏移资产 # Aim Offset 专门用于瞄准 有常规和1D两种, 和混合空间一样 常规AimOffset有两个轴, 覆盖瞄准在水平和垂直方向的偏移 需要绑定骨骼网格体 命名前缀为AO_ 本节会创建瞄准偏移资产, 支持水平和垂直方向的偏移, 但只使用垂直方向的偏移 # 射击瞄准相较之前自然一些 使用到的动画资产 # - AimOffsetFwd AimOffsetUp AimOffsetDown AimOffsetLeft AimOfsetLeftDown AimOffsetLeftUp AimOffsetRight AimOfsetRightDown AimOffsetRightUp 垂直方向的偏移来自CameraComponent前进向量在垂直方向的分量 # 通过游戏角色控制器旋转CameraComponent实现游戏角色的视角旋转 水平旋转游戏角色时, 身体跟随 绘制CameraComponent的前进向量 # 获取CameraComponent的旋转分量, 通过旋转分量获取前进向量 在动画蓝图EventGraph计算CameraComponent旋转分量 # ABP_BaseCharacter \u0026gt; EventGraph 获取CameraComponent的旋转分量 # - 输入 Pawn 函数 GetBaseAimRotation: 通过Pawn的Controller返回游戏角色CameraComponent的旋转分量 保存旋转分量到变量, AnimGraph中会用到
Promote to Variable 变量列表出现新变量, 命名为AimRotation 完整实现
根据旋转分量获取CameraComponent的前进分量, 使用DrawDebugLine绘制 # - 起点 游戏角色位置 Pawn \u0026gt; GetActorLocation 偏移 放大的CameraComponent前进向量 Pawn \u0026gt; GetBaseAimRotation \u0026gt; GetForwardVector 终点 起点 + 偏移 乘法输入转为float: 右键另一个输入 DrawDebugLine参数 - Duration 0.0 Thickness 3.0 Line Color 实现 创建瞄准偏移资产 # Aim Offset Content/Player/Animations文件夹空白处右键, 选择AimOffset 选择骨骼网格体 HeroTPP_Skeleton 命名为AO_BaseCharacter 导入AimOffset相关动画 # 之前导入的动画资产打开导致程序挂死, 不用亦不删除, 从ShooterGame单独导入 从ShooterGame迁移 # ShooterGame 选中Content/Animations/TTP_Animations，右键，选择Migrate 仅勾选AimOffset相关动画，共9个 放入指定位置 # ShootThemUp 重命名Content/Animations/TTP_Animations为AimOffsetAnimation，移动到Content/ExternalContent目录下, 删除Content/Animations 挨个双击动画资产, 为其绑定骨骼网格体HeroTPP 为文件夹设置颜色 配置AO_BaseCharacter # 双击打开, 面板和混合空间一样 配置轴 # - Name 范围 水平 Yaw -90 ~ 90 垂直 Pitch -90 ~ 90 要求Asset Browser有以下动画 # - AimOffsetFwd AimOffsetUp AimOffsetDown AimOffsetLeft AimOfsetLeftDown AimOffsetLeftUp AimOffsetRight AimOfsetRightDown AimOffsetRightUp 这些动画倾向于作为姿势, 由少数帧组成 调整动画资产参数以兼容AimOffset资产 # 使得这些动画可以附加到已有姿势上 依次打开9个动画资产, 做如下设置: Asset Details \u0026gt; Additive Settings, 将Additive Anim Type设置Mesh Space AnimOffset只和该类型动画兼容 Base Pose Type默认为Selected animation frame 选择动画Idle 配置瞄准偏移资产AO_BaseCharacter # (Yaw, Pitch) AimOffsetFwd (0, 0) AimOffsetUp (0, 90) AimOffsetDown (0, -90) AimOffsetLeft (-90, 0) AimOfsetLeftDown (-90, -90) AimOffsetLeftUp (-90, 90) AimOffsetRight (90, 0) AimOfsetRightDown (90, -90) AimOffsetRightUp (90, 90) 将9个动画拖入到指定位置, 调整座标 动画座标配置 分布 正常情况下, 给玩家所控制的游戏角色添加在垂直方向旋转已经足够. CameraComponent在水平方向旋转时, 游戏角色骨骼网格体自然跟随. 自定义角色不会有侧面旋转 如果希望AI的旋转更写实, 则需要继续设置水平方向的旋转. 在动画蓝图ABP_BaseCharacter中使用瞄准偏移资产 # AnimGraph 在计算运动姿势之后, 添加AimOffset 将AO_BaseCharacter拖入AnimGraph, Locomotion作为其输入, 输出作为Slot的输入 可以设置AO_BaseCharacter的(Yaw, Pitch), 编译, 在窗口检视Idle姿势在该设置下的AimOffset效果 - (90, 0) 右转 (90, 45) 右下 还可以设置Velocity的默认值, 查看运动时的AimOffset效果 如将Velocity设置为500 在AnimGraph获取AimRotation变量, 使用Pitch分量(垂直); 玩家控制游戏角色时的水平旋转角度不合理, 所以不使用Yaw 查看垂直方向的瞄准偏移 # 武器跟随游戏角色动画偏移，从枪口出来的射线经过瞄准十字 `}),e.add({id:48,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%B7%91%E6%AD%A5/",title:"实现游戏角色跑步",description:"概览 # 跑步条件 # 按下Shift键 运动方向为向前 判断方法1：同时按下 W 或 Up 判断方法2：速度矢量和朝向的夹角为0 速度不为0 前方有障碍物时，游戏角色无法跑步 跑步时，播放跑步动画 # 跑步时，游戏角色运动速度提高 # 绑定跑步键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Run LeftShift 实现跑步逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Run RunEnable 按下时触发 RunDisable 松开时触发 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::RunEnable() {} void ASTUBaseCharacter::RunDisable() {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::RunEnable); PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Released, this, \u0026amp;ASTUBaseCharacter::RunDisable); 添加函数声明 private ShootThemUp: Player/STUBaseCharacter.",content:`概览 # 跑步条件 # 按下Shift键 运动方向为向前 判断方法1：同时按下 W 或 Up 判断方法2：速度矢量和朝向的夹角为0 速度不为0 前方有障碍物时，游戏角色无法跑步 跑步时，播放跑步动画 # 跑步时，游戏角色运动速度提高 # 绑定跑步键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Run LeftShift 实现跑步逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Run RunEnable 按下时触发 RunDisable 松开时触发 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::RunEnable() {} void ASTUBaseCharacter::RunDisable() {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::RunEnable); PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Released, this, \u0026amp;ASTUBaseCharacter::RunDisable); 添加函数声明 private ShootThemUp: Player/STUBaseCharacter.h 实现回调函数 # 键位生效时，设置标识位 # 定义标志位 private ShootThemUp: Player/STUBaseCharacter.h bool AbleRun = false; 键位事件发生时, 更新标志位 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::RunEnable() { AbleRun = true; } void ASTUBaseCharacter::RunDisable() { AbleRun = false; } 运动方向向前时，设置标志位 # 定义标志位 private ShootThemUp: Player/STUBaseCharacter.h bool IsForward = false; MoveForward被调用时, 更新标志位 ShootThemUp: Player/STUBaseCharacter.cpp // MoveForward IsForward = Amount \u0026gt; 0.0f; 添加接口, 返回跑步条件满足情况 # 添加函数声明 public 可在蓝图中调用，也可供其他类使用 ShootThemUp: Player/STUBaseCharacter.h UFUNCTION(BlueprintCallable) bool IsRunning() const; 实现 ShootThemUp: Player/STUBaseCharacter.cpp bool ASTUBaseCharacter::IsRunning() const { return AbleRun \u0026amp;\u0026amp; IsForward \u0026amp;\u0026amp; !GetVelocity().IsZero(); } 添加跑步动画 # 虚幻编辑器 创建混合空间资产作为跑步动画 # Blend Space 1D 创建 Content/Player/Animations/BS_Locomotion_Run，绑定骨骼网格体 HeroTPP_Skeleton 设置轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis - Name Velocity Maximum Axis Value 600 设置动画 - 起点 Idle 终点 RoadieRun_Fwd 在动画蓝图中引入跑步动画 # ABP_BaseCharacter 状态机说明 # 新增状态: Run 状态迁移 - Walk \u0026gt; Run 满足跑步条件 Run \u0026gt; Walk 不再满足跑步条件 Run \u0026gt; JumpStart 游戏角色在空中 使状态机管理跑步状态 # 添加布尔型变量IsRunning 设置变量IsRunning
EventGraph 使用 STUBaseCharacter::IsRunning ，需要 Pawn 到 STUBaseCharacter 的转换 设置IsFalling后, 执行Pawn到STUBaseCharacter的转换 转换完成后, 设置变量 IsRunning 完整 EventGraph 可以合并 Pawn 到 Character 和 STUBaseCharacter 的转换 状态机中添加跑步状态
AnimGraph 将BS_Locomotion_Run拖入到状态机, 命令为 Run 双击 Run ，设置BS_Locomotion_Run输入 添加状态迁移条件
- 触发条件 Walk \u0026gt; Run 满足跑步条件 STUBaseCharacter::IsRunning 返回true Run \u0026gt; Walk 不再满足跑步条件 STUBaseCharacter::IsRunning 返回false Run \u0026gt; JumpStart 游戏角色在空中 复用 Walk \u0026gt; JumpStart 迁移条件 Walk \u0026lt;\u0026gt; Run
状态迁移路径 Walk \u0026gt; Run 迁移条件 Run \u0026gt; Walk 迁移条件 Run \u0026gt; Jump
状态迁移路径
初稿 优解 如果 IsRunning 为 true, 发生 JumpEnd \u0026gt; Walk 时, 会立即从 Walk 切换到 Run 省略 JumpEnd \u0026gt; =Run ，可以降低状态机复杂度 复用迁移条件
Run \u0026gt; JumpStart 复用 Walk \u0026gt; JumpStart 迁移条件 选中 Walk \u0026gt; JumpStart 迁移条件, Details \u0026gt; Transiton \u0026gt; Transition Rule Sharing \u0026gt; Promote To Share 命名为 IsFalling ，共享条件显示为红色 选中 Run \u0026gt; JumpStart 迁移条件, Details \u0026gt; Transition \u0026gt; Transition Rule Sharing \u0026gt; Use Shared \u0026gt; 选择IsFalling 完整状态机 效果 # 运行游戏，走路到跑步动画正常切换 实现跑步加速 # 创建Components/CharacterMovementComponent的派生类 # 虚幻编辑器 CharacterMovementComponent 公有类 设置头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot; }); 满足跑步条件时, 增加游戏角色运动速度上限 # C++ 添加加速系数 # protected ShootThemUp: Components/STUCharacterMovementComponent.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;1.5\u0026quot;, ClampMax = \u0026quot;10.0\u0026quot;)) float SpeedAcceleration = 2.0f; 覆写UCharacterMovementComponent::GetMaxSpeed # 并不直接修改 MaxWalkSpeed 某个地方会调用 GetMaxSpeed 来确定 Character 运动速度的上限，当获取的 MaxWalkSpeed 增加，速度增加的幅度也变大，用以实现加速 添加函数声明
public ShootThemUp: Components/STUCharacterMovementComponent.h virtual float GetMaxSpeed() const override; 实现
ShootThemUp: Components/STUCharacterMovementComponent.cpp #include \u0026quot;Player/STUBaseCharacter.h\u0026quot; float USTUCharacterMovementComponent::GetMaxSpeed() const { const float MaxSpeed = Super::GetMaxSpeed(); ASTUBaseCharacter *Player = Cast\u0026lt;ASTUBaseCharacter\u0026gt;(GetPawnOwner()); return Player \u0026amp;\u0026amp; Player-\u0026gt;IsRunning() ? SpeedAcceleration * MaxSpeed : MaxSpeed; } 游戏角色使用STUCharacterMovementComponent # 屏蔽默认构造函数声明，声明构造函数 ShootThemUp: Player/STUBaseCharacter.h // ASTUBaseCharacter(); ASTUBaseCharacter(const FObjectInitializer \u0026amp;ObjInit); 修改构造函数初始化列表 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/STUCharacterMovementComponent.h\u0026quot; ASTUBaseCharacter::ASTUBaseCharacter(const FObjectInitializer \u0026amp;ObjInit) : Super(ObjInit.SetDefaultSubobjectClass\u0026lt;USTUCharacterMovementComponent\u0026gt;(ACharacter::CharacterMovementComponentName)) { // ... } `}),e.add({id:49,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/",title:"阶段性总结",description:"项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D AM_Death BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent STUHealthComponent Player STUBaseCharacter STUPlayerController Dev STUDevDamageActor STUFireDamageType STUIceDamageType STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D Player/Animations/AM_Death STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 轴映射 左右移动 APawn::AddMovementInput；AActor::GetActorRightVector MoveForward 轴映射 前后移动 APawn::AddMovementInput；AActor::GetActorForwardVector 轴映射 左右旋转 ACharacter::AddControllerYawInput 轴映射 上下旋转 ACharacter::AddControllerPitchInput 动作映射 跳跃 ACharacter::Jump RunEnable，RunDisable 动作映射 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 委托 处理函数 作用 委托成员 操作 OnChangeHealth 修改显示生命值 HealthComponent::OnChangeHealth 修改HealthTextComponent文本 OnDeath 游戏角色死亡处理 HealthComponent::OnDeath 播放死亡动画剪辑；禁止操作Character；定时销毁；切换到观察视角 OnGroundLanded 计算落地伤害 ACharacter::LandedDelegate 计算落地伤害；对Character调用TakeDamage 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 HealthComponent 生命值系统 HealthTextComponent 显示生命值 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 游戏角色死亡逻辑 说明 DeathAnimMontage 死亡动画剪辑 LifeSpanOnDeath 销毁角色定时间隔 落地伤害逻辑 说明 LandedDamageRange 伤害范围 LandedDamageVelocityRange 造成伤害的速度范围 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true HealthComponent # HealthTextComponent # 说明 Horizontal Alignment Center Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机",content:`项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D AM_Death BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent STUHealthComponent Player STUBaseCharacter STUPlayerController Dev STUDevDamageActor STUFireDamageType STUIceDamageType STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D Player/Animations/AM_Death STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 轴映射 左右移动 APawn::AddMovementInput；AActor::GetActorRightVector MoveForward 轴映射 前后移动 APawn::AddMovementInput；AActor::GetActorForwardVector 轴映射 左右旋转 ACharacter::AddControllerYawInput 轴映射 上下旋转 ACharacter::AddControllerPitchInput 动作映射 跳跃 ACharacter::Jump RunEnable，RunDisable 动作映射 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 委托 处理函数 作用 委托成员 操作 OnChangeHealth 修改显示生命值 HealthComponent::OnChangeHealth 修改HealthTextComponent文本 OnDeath 游戏角色死亡处理 HealthComponent::OnDeath 播放死亡动画剪辑；禁止操作Character；定时销毁；切换到观察视角 OnGroundLanded 计算落地伤害 ACharacter::LandedDelegate 计算落地伤害；对Character调用TakeDamage 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 HealthComponent 生命值系统 HealthTextComponent 显示生命值 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 游戏角色死亡逻辑 说明 DeathAnimMontage 死亡动画剪辑 LifeSpanOnDeath 销毁角色定时间隔 落地伤害逻辑 说明 LandedDamageRange 伤害范围 LandedDamageVelocityRange 造成伤害的速度范围 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true HealthComponent # HealthTextComponent # 说明 Horizontal Alignment Center Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机
Locomotion \u0026gt; Slot \u0026gt; OutputPose 状态 状态 说明 走路 Walk BS_Locomotion_Walk；混合空间 跑步 Run BS_Locomotion_Run；混合空间1D 跳跃 JumpStart JumpLoop JumpEnd 死亡 AM_Death；动画剪辑 变量 动画输入 名称 速度 Velocity 速度和前进方向的夹角 Directon 转换条件 说明 IsRunning C++ 满足3个条件：按下Shift；速度和前进方向夹角为0（或按下W/Up）；速度不为0 IsFalling CharacterMovementComponent::IsFalling 返回true，意味着游戏角色跳起；接着返回false，意味着游戏角色回到地面 EventGraph # 设置变量 - Velocity Directon IsRunning IsFalling 组件 # C++ STUCharacterMovementComponent # 满足跑步条件时，提高运动速度上限 参数 说明 SpeedAcceleration 加速系数 STUHealthComponent # 函数成员 # 基本函数 操作 构造函数 每帧调用Tick标志位置为false BeginPlay 初始化生命值；注册AActor::OnTakeAnyDamage TickComponent 屏蔽 接口 接口函数 操作 GetHealth 获取当前生命值；STBaseCharacter调用 IsDead 判断角色是否死亡 内部逻辑 说明 SetHealth 修改生命值；受到伤害或治疗时调用，随之广播 治疗 说明 OnHeal 定时器回调函数；治疗；满生命值停止定时器 StartHealTimer 受到伤害则开启定时器 StopHealTimer 受到伤害会关闭之前开启的定时器；满生命值时停止定时器 受伤处理函数 - OnTakeAnyDamage 进入条件：伤害为正数，当前角色存活；受伤后，停止已开启的治疗定时器；更新生命值；若角色死亡，广播，否则，开启治疗定时器 数据成员 # 说明 Health 生命值 MaxHealth 最大生命值 委托成员 说明 OnChangeHealth 修改生命值(SetHealth)时广播 OnDeath 受到伤害时，若死亡，广播 治疗 说明 HealTimer 定时器 AutoHeal 使能治疗 HealModifier 治疗量 HealRate 治疗频率 HealDelay 治疗延时 伤害 # C++ STUDevDamageActor # 函数成员 # 基本函数 操作 构造函数 初始化组件 BeginPlay Tick 绘制球体模拟爆炸范围；对球体内以及相交Actor造成伤害 数据成员 # 说明 SceneComponent 变换属性 Radius 球体半径 SphereColor 球体颜色 Damage 伤害的数值特征 DoFullDamage 计算伤害机制标志位 STUFireDamageType和STUIceDamageType # `}),e.add({id:50,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E6%B7%BB%E5%8A%A0%E8%B5%B0%E8%B7%AF%E6%97%B6%E8%BD%AC%E5%90%91%E5%8A%A8%E7%94%BB/",title:"添加走路转向动画",description:"概览 # 已实现动作 # Walk: 从静止到跑起来支持加速，使用 BS_Locomotion_Walk_1D Run: BS_Locomotion_Run Jump: JumpStart , JumpEnd , JumpLoop 本节内容 # 重新实现走路动画，根据游戏角色前进方向和速度方向的夹角，增加转向和后退动画 之后还有 装弹 Reloading , 死亡 Death 和瞄准 Aiming 动画 2D混合空间 # Blend Space 拥有两个轴， Vertial Axis 和 Horizontal Axis 建模 # 游戏角色朝向 # - 前进和后退 ForwardVector 左右 RightVector 游戏角色前后左右移动有使用到这两个方向向量 我们水平移动鼠标时， ForwardVector 和 RightVector 随之发生改变 在视觉上， ForwardVector 一直向前， RightVector 一直向右，二者在水平面垂直 数学基础 # 点乘 # 计算向量夹角 其中一个向量为 0向量 时，点乘结果为 0 ，而反余弦计算得到其夹角为 PI/2 叉乘 # 将向量夹角从[0, PI]扩充到[-PI, PI] theta 为 0 PI 和 -PI 时，叉乘结果为 0 ，此时无法通过向量确定平面，也就无法得到平面法向量 向量c的z坐标 c.",content:"概览 # 已实现动作 # Walk: 从静止到跑起来支持加速，使用 BS_Locomotion_Walk_1D Run: BS_Locomotion_Run Jump: JumpStart , JumpEnd , JumpLoop 本节内容 # 重新实现走路动画，根据游戏角色前进方向和速度方向的夹角，增加转向和后退动画 之后还有 装弹 Reloading , 死亡 Death 和瞄准 Aiming 动画 2D混合空间 # Blend Space 拥有两个轴， Vertial Axis 和 Horizontal Axis 建模 # 游戏角色朝向 # - 前进和后退 ForwardVector 左右 RightVector 游戏角色前后左右移动有使用到这两个方向向量 我们水平移动鼠标时， ForwardVector 和 RightVector 随之发生改变 在视觉上， ForwardVector 一直向前， RightVector 一直向右，二者在水平面垂直 数学基础 # 点乘 # 计算向量夹角 其中一个向量为 0向量 时，点乘结果为 0 ，而反余弦计算得到其夹角为 PI/2 叉乘 # 将向量夹角从[0, PI]扩充到[-PI, PI] theta 为 0 PI 和 -PI 时，叉乘结果为 0 ，此时无法通过向量确定平面，也就无法得到平面法向量 向量c的z坐标 c.z 的符号说明向量的方向 速度方向 # VelocityVector Actor 的速度是一个矢量，其表现是单位时间内的位移方向 当速度不为 0 ， VelocityVector 和 ForwardVector 的夹角与此时 Actor 应该展现的动画有关 计算游戏角色前进方向和速度方向的夹角 # VelocityVector 和 ForwardVector 的夹角通过向量点乘反余弦结果和向量叉乘结果z分量符号 sign(c.z) 的乘积得到 夹角 反余弦结果 sign(c.z) 目的动画 使用乘积效果 0 0 0 Fwd o ( 0, PI/2 ) ( 0, PI/2 ) 1 Fwd \u0026gt; Right o PI/2 PI/2 1 Right o ( PI/2, PI ) ( PI/2, PI ) 1 Right \u0026gt; Bwd o PI PI 0 Bwd x -PI PI 0 Bwd x ( -PI, -PI/2 ) ( PI/2, PI ) -1 Left \u0026gt; Bwd o -PI/2 PI/2 -1 Left o ( -PI/2, 0 ) ( 0, PI/2 ) -1 Fwd \u0026gt; Left o 分析特殊情形 # 坐标 ( Velocity , Angle ) 速度为0，夹角应该为0 # Velocity 为 0 ，( 0, 任意 ) 对应 Idle ，可以显示正确动画 速度不为0，夹角为0或PI时 # 叉乘结果为 0 ，即sign(c.z)为 0 ，即计算夹角得到 0 ，对应动画 RunFwd 夹角为 0 使用 RunFwd 正确，夹角为 PI 应该使用 RunBwd 夹角为 PI 时，不使用乘积，使用反余弦结果 可以在蓝图中实现夹角的计算，也可以在C++中实现 # 绘制ForwardVector，RightVector和VelocityVector # 虚幻编辑器 使用 DrawDebugArrow : Duration 为 0 ，每帧都进行绘画 - 起点 Actor 当前位置 终点 起点 + 偏移 绘制 ForwardVector # - 偏移 放大的前进方向向量 绘制 RightVector # - 偏移 放大的向右方向向量 绘制 VelocityVector # - 偏移 放大的速度方向单位向量 效果图 # 一直显示 ForwardVector 和 RightVector ，有速度才会显示 VelocityVector 优化显示 # 项目设置 \u0026gt; Engine \u0026gt; Rendering \u0026gt; Default Settings \u0026gt; Auto Exposure，取消勾选 旨在模拟人眼适应不同亮度 看不出区别, 取消设置 添加走路转向动画 # 虚幻编辑器 创建2D混合空间资产作为走路转向动画 # Blend Space 创建2D混合空间资产, 命名为BS_Locomotion_Walk 设置轴 横轴: 速度 - Name Velocity 范围 [ 0, 600 ] 纵轴: ForwardVector 和 VelocityVector 的夹角 - Name Direction 范围 [ -180, 180 ] 设置动画 ( Velocity , Direction ) 动画资产 说明 ( 0, 0 ) Idle 初始状态 ( 600, 0 ) Run_Fwd 满速前进 ( 600, -180 ) 和 ( 600, 180 ) Run_Bwd 满速后退 ( 600, 90 ) Run_Rt 满速向右 ( 600, -90 ) Run_Lt 满速向左 将BS_Locomotion_Walk用作走路动画 # ABP_BaseCharacter 将BS_Locomotion_Walk设置为Walk状态的输入 变量Velocity作为横轴Velocity的输入 添加变量 Direction - 类型 float 默认值 0 变量Direction作为纵轴Direction的输入 在蓝图中计算夹角 # 虚幻编辑器 在蓝图中计算夹角并设置变量 # 计算点乘时， ForwardVector 和 VelocityVector 都是单位向量 计算夹角 # 当前并未在夹角为PI时做处理，后退动画偶有闪动但看似正常 接着设置IsRunning, 设置Direction # 输出 # 输出点乘的反余弦结果，静止时输出90 输出叉乘结果，静止、前进或后退时，坐标为 0 但是有正负 输出 Sign 结果，静止时为 0 ，前进或后退时，其结果或为 1 或为 -1 ，飘忽不定，但不为 0 ，所以后退动画看似正常 可以做出合理推测：显示为 0 但不意味着为 0 ，数值很小 叉乘时传入未单位化的 Velocity 无改善 同时按下后退和向左，或者后退和向右，正负 3PI/4 的动画较为刻意 ( PI/2, PI ) 和 ( -PI, -PI/2 ) 时可以只显示 Run_Bwd 绘制 ForwardVectr 和 VelocityVector 的叉乘结果 # - 偏移 放大的叉乘结果 运动时才有向量显示 向前和向后运动时，偶有不明显的显示 取消变量的设置 # 接下来在代码计算夹角 在代码中计算夹角 # 添加接口, 返回Direction # C++ 添加函数声明 public 可在蓝图中调用，也可供其他类使用 ShootThemUp: Player/STUBaseCharacter.h UFUNCTION(BlueprintCallable) float GetDirection() const; 实现 速度为0时, 夹角为0 速度不为0, 叉乘结果为0时, 夹角为PI或-PI, 返回反余弦结果 ShootThemUp: Player/STUBaseCharacter.cpp float ASTUBaseCharacter::GetDirection() const { if (GetVelocity().IsZero()) return 0.0f; const FVector ForwardVector = GetActorForwardVector(); const FVector VelocityNormalizedVector = GetVelocity().GetSafeNormal(); const float DotProductResult = FVector::DotProduct(ForwardVector, VelocityNormalizedVector); const float Theta = FMath::RadiansToDegrees(FMath::Acos(DotProductResult)); const FVector CrossProductResult = FVector::CrossProduct(ForwardVector, VelocityNormalizedVector); return (CrossProductResult.IsZero() ? Theta : FMath::Sign(CrossProductResult.Z) * Theta); } 代码优化: 前后左右移动的回调函数MoveForward和MoveRight # C++ 若 Amount 为0，直接返回 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::MoveForward(float Amount) { IsForward = Amount \u0026gt; 0.0f; if (Amount == 0.0f) return; AddMovementInput(GetActorForwardVector(), Amount); } void ASTUBaseCharacter::MoveRight(float Amount) { if (Amount == 0.0f) return; AddMovementInput(GetActorRightVector(), Amount); } 在蓝图中使用C++函数设置变量Direction # 虚幻编辑器 ABP_BaseCharacter \u0026gt; EventGraph 阻断动画蓝图无效状态 # 当我们打开动画蓝图时，其以standalone方式运行。即使未在虚幻编辑器中运行游戏，在蓝图编辑器打开ABP_BaseCharacter，其处于运行状态。可以看到动画蓝图视口的 Actor 是有动画的。 从EventBlueprintUpdateAnimation出发，TryGetPawnOwner得到空指针，停在CastToCharacter # 添加打印名，验证动画蓝图运行 # 未在虚幻编辑器运行游戏，保持动画蓝图在前台，日志窗口一直有输出 未运行游戏时，阻断动画蓝图 # 从 EventBlueprintUpdateAnimation 出发，添加 IsValid 宏，检查 Pawn 有效性 "}),e.add({id:51,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F/",title:"打包游戏",description:"说明 # 打包游戏，从二进制文件运行 定期打包游戏，确保所做改动能正常运行 设置玩家出发点 # 参考 LevelEditor \u0026gt; PlaceActors \u0026gt; Basic \u0026gt; PlayerStart，添加到关卡中 设置编译选项 # 项目设置 \u0026gt; Project \u0026gt; Packaging \u0026gt; Project \u0026gt; Build Configuration，选择 发行(Shipping) 编译游戏 # 参考 创建文件夹 ShootThemUp/Build 设置二进制文件保存路径 工具栏 \u0026gt; Platforms \u0026gt; Mac \u0026gt; Package Project，选择 Build 文件夹 可在日志窗口查看过程 打包成功 生成 ShootThemUp/Build/Mac/ShootThemUp-Shipping.app 尝试 Development 和 DebugGame 选项，均可 纯蓝图项目没有 DebugGame 选项 metal-ar报错 # 当前项目路径不包含空格，但包含汉字 打包项目 菜单栏 \u0026gt; File \u0026gt; Zip Project 移动到不含空格的英文路径 ",content:"说明 # 打包游戏，从二进制文件运行 定期打包游戏，确保所做改动能正常运行 设置玩家出发点 # 参考 LevelEditor \u0026gt; PlaceActors \u0026gt; Basic \u0026gt; PlayerStart，添加到关卡中 设置编译选项 # 项目设置 \u0026gt; Project \u0026gt; Packaging \u0026gt; Project \u0026gt; Build Configuration，选择 发行(Shipping) 编译游戏 # 参考 创建文件夹 ShootThemUp/Build 设置二进制文件保存路径 工具栏 \u0026gt; Platforms \u0026gt; Mac \u0026gt; Package Project，选择 Build 文件夹 可在日志窗口查看过程 打包成功 生成 ShootThemUp/Build/Mac/ShootThemUp-Shipping.app 尝试 Development 和 DebugGame 选项，均可 纯蓝图项目没有 DebugGame 选项 metal-ar报错 # 当前项目路径不包含空格，但包含汉字 打包项目 菜单栏 \u0026gt; File \u0026gt; Zip Project 移动到不含空格的英文路径 "}),e.add({id:52,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/",title:"阶段性总结",description:"项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent Player STUBaseCharacter STUPlayerController STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 左右移动 AddMovementInput；GetActorRightVector MoveForward 前后移动 AddMovementInput；GetActorForwardVector 左右旋转 ACharacter::AddControllerYawInput 上下旋转 ACharacter::AddControllerPitchInput 跳跃 ACharacter::Jump RunEnable，RunDisable 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机",content:`项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent Player STUBaseCharacter STUPlayerController STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 左右移动 AddMovementInput；GetActorRightVector MoveForward 前后移动 AddMovementInput；GetActorForwardVector 左右旋转 ACharacter::AddControllerYawInput 上下旋转 ACharacter::AddControllerPitchInput 跳跃 ACharacter::Jump RunEnable，RunDisable 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机
Locomotion作为OutputPose的输入 状态 状态 说明 走路 Walk BS_Locomotion_Walk；混合空间 跑步 Run BS_Locomotion_Run；混合空间1D 跳跃 JumpStart JumpLoop JumpEnd 变量 动画输入 名称 速度 Velocity 速度和前进方向的夹角 Directon 转换条件 说明 IsRunning C++ 满足3个条件：按下Shift；速度和前进方向夹角为0（按下W或Up）；速度不为0 IsFalling CharacterMovementComponent::IsFalling 返回true，意味着游戏角色跳起；接着返回false，意味着游戏角色回到地面 EventGraph # 设置变量 - Velocity Directon IsRunning IsFalling 组件 # C++ STUCharacterMovementComponent # 满足跑步条件时，提高运动速度上限 参数 说明 SpeedAcceleration 加速系数 `}),e.add({id:53,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%83%B3%E6%B3%95/%E5%B0%9D%E8%AF%95evil/",title:"尝试Evil",description:"安装evil # Manual GitHub 依赖 # - goto-chg github undo-tree elpa undo-fu melpa ;; (use-package goto-chg ;; :ensure t) ;; (use-package undo-tree ;; :ensure t) ;; (use-package undo-fu ;; :ensure t) 安装evil # ;; (use-package evil ;; :ensure t ;; :config (progn (evil-mode t) ;; (setq evil-default-state 'emacs) ;; ;; (evil-set-initial-state evil-mode 'emacs) ;; (setq evil-emacs-state-cursor '(\u0026quot;grey\u0026quot; box)) ;; C-z ;; (setq evil-normal-state-cursor '(\u0026quot;green\u0026quot; box)) ;; esc ;; (setq evil-insert-state-cursor '(\u0026quot;red\u0026quot; box)) ;; i ;; (setq evil-replace-state-cursor '(\u0026quot;red\u0026quot; hollow)) ;; r ;; (setq evil-visual-state-cursor '(\u0026quot;yellow\u0026quot; box)))) 相关插件 # - evil-tabs tabs标签 evil-leader 定义evil-mode下使用的快捷键 evil-tabs # ;;(use-package evil-tabs ;;:ensure t ;;:config (global-evil-tabs-mode t)) evil-leader # GitHub ;; (use-package evil-leader ;; :ensure t ;; :init (progn ;; (global-evil-leader-mode t) ;; (evil-leader/set-leader \u0026quot;\u0026lt;SPC\u0026gt;\u0026quot;) ;; (evil-leader/set-key ;; \u0026quot;e\u0026quot; 'find-file))) ",content:"安装evil # Manual GitHub 依赖 # - goto-chg github undo-tree elpa undo-fu melpa ;; (use-package goto-chg ;; :ensure t) ;; (use-package undo-tree ;; :ensure t) ;; (use-package undo-fu ;; :ensure t) 安装evil # ;; (use-package evil ;; :ensure t ;; :config (progn (evil-mode t) ;; (setq evil-default-state 'emacs) ;; ;; (evil-set-initial-state evil-mode 'emacs) ;; (setq evil-emacs-state-cursor '(\u0026quot;grey\u0026quot; box)) ;; C-z ;; (setq evil-normal-state-cursor '(\u0026quot;green\u0026quot; box)) ;; esc ;; (setq evil-insert-state-cursor '(\u0026quot;red\u0026quot; box)) ;; i ;; (setq evil-replace-state-cursor '(\u0026quot;red\u0026quot; hollow)) ;; r ;; (setq evil-visual-state-cursor '(\u0026quot;yellow\u0026quot; box)))) 相关插件 # - evil-tabs tabs标签 evil-leader 定义evil-mode下使用的快捷键 evil-tabs # ;;(use-package evil-tabs ;;:ensure t ;;:config (global-evil-tabs-mode t)) evil-leader # GitHub ;; (use-package evil-leader ;; :ensure t ;; :init (progn ;; (global-evil-leader-mode t) ;; (evil-leader/set-leader \u0026quot;\u0026lt;SPC\u0026gt;\u0026quot;) ;; (evil-leader/set-key ;; \u0026quot;e\u0026quot; 'find-file))) "}),e.add({id:54,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E5%8F%8C%E9%93%BE%E7%AC%94%E8%AE%B0%E6%9C%AC/",title:"双链笔记本",description:"说明 # 不可能在多个地方维护同一个知识点 知识点之间的关联性有多种，方便的组织可以使笔记保持整洁 需配置roam文件根目录 # ;; (setq my/org-roam-directory \u0026quot;path/to/roam/notes/directory\u0026quot;) org-roam-安装 # (use-package org-roam :ensure t :custom (org-roam-directory my/org-roam-directory) ;; custom (org-roam-completion-everywhere t) :bind ((\u0026quot;C-c n f\u0026quot; . org-roam-node-find) (\u0026quot;C-c n i\u0026quot; . org-roam-node-insert) (\u0026quot;C-c n l\u0026quot; . org-roam-buffer-toggle) ;; (\u0026quot;C-c n g\u0026quot; . org-roam-graph) (\u0026quot;C-c n c\u0026quot; . org-roam-capture) ;; Dailies (\u0026quot;C-c n j\u0026quot; . org-roam-dailies-capture-today) ;; custom ;; 使能 org-roam-completion-everywhere (\u0026quot;C-M-i\u0026quot; . completion-at-point) (\u0026quot;C-c n s\u0026quot; . org-roam-db-sync) (\u0026quot;C-c n r\u0026quot; .",content:"说明 # 不可能在多个地方维护同一个知识点 知识点之间的关联性有多种，方便的组织可以使笔记保持整洁 需配置roam文件根目录 # ;; (setq my/org-roam-directory \u0026quot;path/to/roam/notes/directory\u0026quot;) org-roam-安装 # (use-package org-roam :ensure t :custom (org-roam-directory my/org-roam-directory) ;; custom (org-roam-completion-everywhere t) :bind ((\u0026quot;C-c n f\u0026quot; . org-roam-node-find) (\u0026quot;C-c n i\u0026quot; . org-roam-node-insert) (\u0026quot;C-c n l\u0026quot; . org-roam-buffer-toggle) ;; (\u0026quot;C-c n g\u0026quot; . org-roam-graph) (\u0026quot;C-c n c\u0026quot; . org-roam-capture) ;; Dailies (\u0026quot;C-c n j\u0026quot; . org-roam-dailies-capture-today) ;; custom ;; 使能 org-roam-completion-everywhere (\u0026quot;C-M-i\u0026quot; . completion-at-point) (\u0026quot;C-c n s\u0026quot; . org-roam-db-sync) (\u0026quot;C-c n r\u0026quot; . org-roam-db-clear-all)) :config ;; If you're using a vertical completion framework, you might want a more informative completion interface (setq org-roam-node-display-template (concat \u0026quot;${title:*} \u0026quot; (propertize \u0026quot;${tags:10}\u0026quot; 'face 'org-tag))) (org-roam-db-autosync-mode) (org-roam-db-sync) ;; If using org-roam-protocol (require 'org-roam-protocol) (setq org-roam-capture-templates '( (\u0026quot;d\u0026quot; \u0026quot;default\u0026quot; plain \u0026quot;%?\u0026quot; :target (file+head \u0026quot;%^{目录}/${title}.org\u0026quot; \u0026quot;#+title: ${title}\\n\u0026quot;) :unarrowed t) ))) org-roam-ui-安装 # (use-package org-roam-ui :ensure t :after org-roam ;; normally we'd recommend hooking orui after org-roam, but since org-roam does not have ;; a hookable mode anymore, you're advised to pick something yourself ;; if you don't care about startup time, use ;; :hook (after-init . org-roam-ui-mode) :config (setq org-roam-ui-sync-theme t org-roam-ui-follow t org-roam-ui-update-on-save t org-roam-ui-open-on-start t) :bind ((\u0026quot;C-c n u\u0026quot; . org-roam-ui-open))) "}),e.add({id:55,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E8%B7%B3%E8%BD%AC/",title:"虚幻引擎项目源码跳转",description:"项目源码路径样式 # [[uep:Public/Weapon/STUBaseWeapon.h][ShootThemUp:Weapon/STUBaseWeapon.h]] 需设置项目文件夹 # ;; (setq my/ue-project-path \u0026quot;path/to/ue/project\u0026quot;) 插入项目源码链接 # (defun my/insert-ue-project-source-path () (interactive) (let ((proj (read-string \u0026quot;Project: (Default - ShootThemUp)\u0026quot;)) (type (read-string \u0026quot;Category: \u0026quot;)) (file (read-string \u0026quot;File: \u0026quot;)) (path) (attr)) (if (string= \u0026quot;\u0026quot; proj) (setq proj \u0026quot;ShootThemUp\u0026quot;)) (when (string= \u0026quot;\u0026quot; type) (insert (format \u0026quot;[[uep:%s][%s:%s]]\u0026quot; file proj file))) (unless (string= type \u0026quot;\u0026quot;) (if (string-suffix-p \u0026quot;.h\u0026quot; file) (setq attr \u0026quot;Public\u0026quot;) (setq attr \u0026quot;Private\u0026quot;)) (setq path (format \u0026quot;%s/%s/%s\u0026quot; attr type file)) (insert (format \u0026quot;[[uep:%s][%s:%s/%s]]\u0026quot; path proj type file))))) (global-set-key (kbd \u0026quot;C-c u p\u0026quot;) 'my/insert-ue-project-source-path) 打开源码文件 # (defun my/go-to-ue-project-source () (interactive) (when (search-backward \u0026quot;[[uep:\u0026quot; nil t) (when (re-search-forward (rx \u0026quot;[[uep:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;:\u0026quot;))) \u0026quot;:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1)))) (proj (string-join (mapcar #'string (match-string 2))))) (org-open-file (format \u0026quot;%s/%s/Source/%s/%s\u0026quot; my/ue-project-path proj proj file)))))) (global-set-key (kbd \u0026quot;C-c u l\u0026quot;) 'my/go-to-ue-project-source) ",content:"项目源码路径样式 # [[uep:Public/Weapon/STUBaseWeapon.h][ShootThemUp:Weapon/STUBaseWeapon.h]] 需设置项目文件夹 # ;; (setq my/ue-project-path \u0026quot;path/to/ue/project\u0026quot;) 插入项目源码链接 # (defun my/insert-ue-project-source-path () (interactive) (let ((proj (read-string \u0026quot;Project: (Default - ShootThemUp)\u0026quot;)) (type (read-string \u0026quot;Category: \u0026quot;)) (file (read-string \u0026quot;File: \u0026quot;)) (path) (attr)) (if (string= \u0026quot;\u0026quot; proj) (setq proj \u0026quot;ShootThemUp\u0026quot;)) (when (string= \u0026quot;\u0026quot; type) (insert (format \u0026quot;[[uep:%s][%s:%s]]\u0026quot; file proj file))) (unless (string= type \u0026quot;\u0026quot;) (if (string-suffix-p \u0026quot;.h\u0026quot; file) (setq attr \u0026quot;Public\u0026quot;) (setq attr \u0026quot;Private\u0026quot;)) (setq path (format \u0026quot;%s/%s/%s\u0026quot; attr type file)) (insert (format \u0026quot;[[uep:%s][%s:%s/%s]]\u0026quot; path proj type file))))) (global-set-key (kbd \u0026quot;C-c u p\u0026quot;) 'my/insert-ue-project-source-path) 打开源码文件 # (defun my/go-to-ue-project-source () (interactive) (when (search-backward \u0026quot;[[uep:\u0026quot; nil t) (when (re-search-forward (rx \u0026quot;[[uep:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;:\u0026quot;))) \u0026quot;:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1)))) (proj (string-join (mapcar #'string (match-string 2))))) (org-open-file (format \u0026quot;%s/%s/Source/%s/%s\u0026quot; my/ue-project-path proj proj file)))))) (global-set-key (kbd \u0026quot;C-c u l\u0026quot;) 'my/go-to-ue-project-source) "}),e.add({id:56,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E8%B7%B3%E8%BD%AC/",title:"虚幻引擎源码跳转",description:"说明 # API会标注类源码路径 源码路径样式 # [[file:file.cpp][源码:name]] 需设置引擎源码文件夹 # ;; (setq my/ue-source-path \u0026quot;path/to/ue/source\u0026quot;) 插入源码路径 # (defun my/insert-ue-source-path () (interactive) (let* ((path (read-string \u0026quot;Path: UE_5.1/Engine/Source/\u0026quot;)) (file (car (last (split-string path \u0026quot;/\u0026quot; t))))) (insert (format \u0026quot;[[ue:UE_5.1/Engine/Source/%s][虚幻引擎:%s]]\u0026quot; path file)))) (global-set-key (kbd \u0026quot;C-c u e\u0026quot;) 'my/insert-ue-source-path) 打开源码文件 # (defun my/go-to-ue-source () (interactive) (when (search-backward \u0026quot;[[ue:\u0026quot; nil t) (when (re-search-forward (rx \u0026quot;[[ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1))))) (org-open-file (concat my/ue-source-path \u0026quot;/\u0026quot; file)))))) (global-set-key (kbd \u0026quot;C-c u g\u0026quot;) 'my/go-to-ue-source) ",content:"说明 # API会标注类源码路径 源码路径样式 # [[file:file.cpp][源码:name]] 需设置引擎源码文件夹 # ;; (setq my/ue-source-path \u0026quot;path/to/ue/source\u0026quot;) 插入源码路径 # (defun my/insert-ue-source-path () (interactive) (let* ((path (read-string \u0026quot;Path: UE_5.1/Engine/Source/\u0026quot;)) (file (car (last (split-string path \u0026quot;/\u0026quot; t))))) (insert (format \u0026quot;[[ue:UE_5.1/Engine/Source/%s][虚幻引擎:%s]]\u0026quot; path file)))) (global-set-key (kbd \u0026quot;C-c u e\u0026quot;) 'my/insert-ue-source-path) 打开源码文件 # (defun my/go-to-ue-source () (interactive) (when (search-backward \u0026quot;[[ue:\u0026quot; nil t) (when (re-search-forward (rx \u0026quot;[[ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1))))) (org-open-file (concat my/ue-source-path \u0026quot;/\u0026quot; file)))))) (global-set-key (kbd \u0026quot;C-c u g\u0026quot;) 'my/go-to-ue-source) "}),e.add({id:57,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E4%BD%BF%E7%94%A8emacs%E5%81%9A%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/",title:"使用Emacs做视频笔记",description:"需求 # 有尝试使用Logseq和Obsidian做视频笔记，结果不太满意，不过弄清楚了需求 - 在笔记页面控制视频的暂停，前进，后退 播放器能加载字幕，能设置屏幕大小(全屏) 在笔记页面添加时间戳 从时间戳播放视频 说明 # - 播放器 mpv 插件 emms 播放器和Emacs间的接口：控制播放器，获取相关参数 插件 pretty-hydra 自定义快捷键菜单 自定义函数 打时间戳，跳转 时间戳样式 # [[timestamp:file.mp4#00:29][name]] 需设置emms默认播放路径 # ;; (setq my/movie-path \u0026quot;path/to/movie\u0026quot;) 需设置视频根目录 # ;; (setq my/video-path \u0026quot;path/to/video\u0026quot;) emms-安装 # (use-package emms :ensure t :init (emms-all) :config (setq emms-player-list '(emms-player-mpv) emms-info-function '(emms-info-native) emms-source-file-default-directory my/movie-path emms-seek-seconds 5) :bind ((\u0026quot;C-c e SPC\u0026quot; . emms-pause) (\u0026quot;C-c e f\u0026quot; . emms-seek-forward) (\u0026quot;C-c e b\u0026quot; . emms-seek-backward) (\u0026quot;C-c e p\u0026quot; .",content:"需求 # 有尝试使用Logseq和Obsidian做视频笔记，结果不太满意，不过弄清楚了需求 - 在笔记页面控制视频的暂停，前进，后退 播放器能加载字幕，能设置屏幕大小(全屏) 在笔记页面添加时间戳 从时间戳播放视频 说明 # - 播放器 mpv 插件 emms 播放器和Emacs间的接口：控制播放器，获取相关参数 插件 pretty-hydra 自定义快捷键菜单 自定义函数 打时间戳，跳转 时间戳样式 # [[timestamp:file.mp4#00:29][name]] 需设置emms默认播放路径 # ;; (setq my/movie-path \u0026quot;path/to/movie\u0026quot;) 需设置视频根目录 # ;; (setq my/video-path \u0026quot;path/to/video\u0026quot;) emms-安装 # (use-package emms :ensure t :init (emms-all) :config (setq emms-player-list '(emms-player-mpv) emms-info-function '(emms-info-native) emms-source-file-default-directory my/movie-path emms-seek-seconds 5) :bind ((\u0026quot;C-c e SPC\u0026quot; . emms-pause) (\u0026quot;C-c e f\u0026quot; . emms-seek-forward) (\u0026quot;C-c e b\u0026quot; . emms-seek-backward) (\u0026quot;C-c e p\u0026quot; . emms-previous) (\u0026quot;C-c e n\u0026quot; . emms-next) (\u0026quot;C-c e x\u0026quot; . emms-stop) (\u0026quot;C-c e e\u0026quot; . emms))) pretty-hydra-安装 # (use-package pretty-hydra :ensure t :init (pretty-hydra-define emms-video-hydra (:title \u0026quot;Emms-hydra\u0026quot; :quit-key \u0026quot;q\u0026quot; :color blue) (\u0026quot;Control\u0026quot; ((\u0026quot;SPC\u0026quot; emms-pause \u0026quot;Pause\u0026quot;) (\u0026quot;f\u0026quot; emms-seek-forward \u0026quot;Fast Forward\u0026quot;) (\u0026quot;b\u0026quot; emms-seek-backward \u0026quot;Rewind\u0026quot;) (\u0026quot;p\u0026quot; emms-previous \u0026quot;Previous\u0026quot;) (\u0026quot;n\u0026quot; emms-next \u0026quot;Next\u0026quot;) (\u0026quot;x\u0026quot; emms-stop \u0026quot;Stop\u0026quot;)))) :bind(\u0026quot;C-c e m\u0026quot; . emms-video-hydra/body)) 插入时间戳 # (defun my/insert-timestamp() (interactive) (let ((desc (read-string \u0026quot;Description: \u0026quot;))) (setq my/mpv-current-file nil) (setq my/mpv-timestamp nil) (emms-player-mpv-ipc-req-send '(get_property path) #'(lambda (ret err) (unless err (setq my/mpv-current-file (file-relative-name ret my/video-path)) ) ) ) (emms-player-mpv-ipc-req-send '(get_property time-pos) #'(lambda (ret err) (unless err (setq my/mpv-timestamp ret) ) ) ) (sleep-for 0.1) (when (and my/mpv-timestamp my/mpv-current-file) (insert (format \u0026quot;[[timestamp:%s#%d][时间戳:%s]]\u0026quot; my/mpv-current-file my/mpv-timestamp desc)) (message \u0026quot;Add timestamp %s#%d success!\u0026quot; my/mpv-current-file my/mpv-timestamp) ) (unless (and my/mpv-timestamp my/mpv-current-file) (message \u0026quot;Fail to insert timestamp!\u0026quot;) ) ) ) (global-set-key (kbd \u0026quot;C-c e i\u0026quot;) 'my/insert-timestamp) 时间戳跳转 # (defun my/emms-player-start-hook () ;; (emms-pause) (emms-seek-to my/emms-timestamp) (remove-hook 'emms-player-started-hook 'my/emms-player-start-hook)) (defun my/seek-to-timestamp () (interactive) (when (search-backward \u0026quot;[[timestamp:\u0026quot; nil t) (when (re-search-forward (rx \u0026quot;[[timestamp:\u0026quot; (group (0+ (not \u0026quot;#\u0026quot;))) \u0026quot;#\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1))))) (setq my/emms-timestamp (string-join (mapcar #'string (match-string 2)))) (if emms-player-playing-p (emms-stop)) (add-hook 'emms-player-started-hook 'my/emms-player-start-hook) (emms-player-start (emms-track 'file (concat my/video-path \u0026quot;/\u0026quot; file))) ;; (setq track (emms-track 'file (concat my/video-path \u0026quot;/\u0026quot; file))) ;; (emms-player-start track) ) ) ) ) (global-set-key (kbd \u0026quot;C-c e g\u0026quot;) 'my/seek-to-timestamp) "}),e.add({id:58,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E4%BD%BF%E7%94%A8ox-hugo%E5%AF%BC%E5%87%BA%E5%8D%9A%E5%AE%A2/",title:"使用ox-hugo导出博客",description:`说明 # - 描述 解决方法 ox-hugo 安装 导出子树时, 整个文件的所有链接要求正确 提取options和子树文本 导出子树时, 自动计算weight, 需要保留其他子树 计算子树的weight 导出文件时, 若在临时文件, 需输入导出文件名 导出子树, 计算子树的导出路径 转换后的下划线无效 不用 Doks主题 markdown文件图片链接无法正确解析 替换图片链接 会检查所有文本(包括代码块)的图片链接 分隔\u0026quot;{{\u0026ldquo;和\u0026rdquo;\u0026lt; figure src\u0026hellip;\u0026quot; 图片链接后接文本, 会作为图片描述 图片链接和文本之间空一行 org-roam 希望能跳转到博客对应标题 将roam节点链接替换为博客+标题链接 时间戳链接 不需要 删除 源码链接 不需要跳转, 需提供说明 在文本块中显示相对路径 ox-hugo-安装 # (use-package ox-hugo :ensure t ;Auto-install the package from Melpa :pin melpa ;\`package-archives' should already have (\u0026quot;melpa\u0026quot; . \u0026quot;https://melpa.org/packages/\u0026quot;) :after ox :config ;; 不处理图片 (setq org-hugo-external-file-extensions-allowed-for-copying nil)) 子树路径 # 获取导出文件路径 # 保存到列表 只能有全局SECTION, 子树使用SECTION_FRAG 缺乏子树从属判断 (defun my/compute-subtree-path (export-name) (interactive) (let ((base-dir) (section) (dir) (slotlist '()) (cur-level) (frag) (new-level)) (save-excursion (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;#+HUGO_BASE_DIR: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (setq base-dir (string-join (mapcar #'string (match-string 1)))) (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;#+HUGO_SECTION: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (setq section (string-join (mapcar #'string (match-string 1)))) (setq dir (concat base-dir \u0026quot;/content/\u0026quot; section)) ) ) ) (add-to-list 'slotlist export-name) (save-excursion (setq cur-level (funcall outline-level)) (while (re-search-backward (rx \u0026quot;:EXPORT_HUGO_SECTION_FRAG: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot; ) nil t) (setq frag (string-join (mapcar #'string (match-string 1)))) (setq new-level (funcall outline-level)) (when (\u0026lt; new-level cur-level) ;;(message \u0026quot;%d %d %s\u0026quot; (funcall outline-level) ocur-level ofrag) ;;(sleep-for 5) (add-to-list 'slotlist frag) (setq cur-level new-level) ) ) ) (add-to-list 'slotlist dir) ) ) 获取导出文件路径的字符串 # (defun my/subtree-path-str (export-name) (interactive) (let ((slotlist (my/compute-subtree-path export-name)) (slot)) (dolist (item slotlist) (setq slot (concat slot \u0026quot;/\u0026quot; item)) ) (string-remove-prefix \u0026quot;/\u0026quot; slot) ) ) Doks主题 # 替换markdown文件图片链接格式 # (defun my/replace-pic-link-format (file) (interactive) (with-current-buffer (find-file-noselect file) (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;{{\u0026quot; \u0026quot;\u0026lt; figure src=\\\u0026quot;\u0026quot; (group (0+ (not \u0026quot;\\\u0026quot;\u0026quot;))) \u0026quot;\\\u0026quot; width=\\\u0026quot;\u0026quot; (group (0+ (not \u0026quot;\\\u0026quot;\u0026quot;))) \u0026quot;\\\u0026quot; \u0026gt;}}\u0026quot;) nil t) (let ((src (string-join (mapcar #'string (match-string 1)))) (width (string-join (mapcar #'string (match-string 2))))) (replace-match (format \u0026quot;\u0026lt;img src=\\\u0026quot;/%s\\\u0026quot; width=\\\u0026quot;%s\\\u0026quot; /\u0026gt; \u0026lt;br/\u0026gt;\u0026quot; src width)) ) ) (save-buffer) (kill-buffer) ) ) 替换子树导出文件图片链接格式 # (defun my/amend-pic-link (export-name) (interactive) (my/replace-pic-link-format (concat (my/subtree-path-str export-name) \u0026quot;.`,content:`说明 # - 描述 解决方法 ox-hugo 安装 导出子树时, 整个文件的所有链接要求正确 提取options和子树文本 导出子树时, 自动计算weight, 需要保留其他子树 计算子树的weight 导出文件时, 若在临时文件, 需输入导出文件名 导出子树, 计算子树的导出路径 转换后的下划线无效 不用 Doks主题 markdown文件图片链接无法正确解析 替换图片链接 会检查所有文本(包括代码块)的图片链接 分隔\u0026quot;{{\u0026ldquo;和\u0026rdquo;\u0026lt; figure src\u0026hellip;\u0026quot; 图片链接后接文本, 会作为图片描述 图片链接和文本之间空一行 org-roam 希望能跳转到博客对应标题 将roam节点链接替换为博客+标题链接 时间戳链接 不需要 删除 源码链接 不需要跳转, 需提供说明 在文本块中显示相对路径 ox-hugo-安装 # (use-package ox-hugo :ensure t ;Auto-install the package from Melpa :pin melpa ;\`package-archives' should already have (\u0026quot;melpa\u0026quot; . \u0026quot;https://melpa.org/packages/\u0026quot;) :after ox :config ;; 不处理图片 (setq org-hugo-external-file-extensions-allowed-for-copying nil)) 子树路径 # 获取导出文件路径 # 保存到列表 只能有全局SECTION, 子树使用SECTION_FRAG 缺乏子树从属判断 (defun my/compute-subtree-path (export-name) (interactive) (let ((base-dir) (section) (dir) (slotlist '()) (cur-level) (frag) (new-level)) (save-excursion (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;#+HUGO_BASE_DIR: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (setq base-dir (string-join (mapcar #'string (match-string 1)))) (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;#+HUGO_SECTION: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (setq section (string-join (mapcar #'string (match-string 1)))) (setq dir (concat base-dir \u0026quot;/content/\u0026quot; section)) ) ) ) (add-to-list 'slotlist export-name) (save-excursion (setq cur-level (funcall outline-level)) (while (re-search-backward (rx \u0026quot;:EXPORT_HUGO_SECTION_FRAG: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot; ) nil t) (setq frag (string-join (mapcar #'string (match-string 1)))) (setq new-level (funcall outline-level)) (when (\u0026lt; new-level cur-level) ;;(message \u0026quot;%d %d %s\u0026quot; (funcall outline-level) ocur-level ofrag) ;;(sleep-for 5) (add-to-list 'slotlist frag) (setq cur-level new-level) ) ) ) (add-to-list 'slotlist dir) ) ) 获取导出文件路径的字符串 # (defun my/subtree-path-str (export-name) (interactive) (let ((slotlist (my/compute-subtree-path export-name)) (slot)) (dolist (item slotlist) (setq slot (concat slot \u0026quot;/\u0026quot; item)) ) (string-remove-prefix \u0026quot;/\u0026quot; slot) ) ) Doks主题 # 替换markdown文件图片链接格式 # (defun my/replace-pic-link-format (file) (interactive) (with-current-buffer (find-file-noselect file) (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;{{\u0026quot; \u0026quot;\u0026lt; figure src=\\\u0026quot;\u0026quot; (group (0+ (not \u0026quot;\\\u0026quot;\u0026quot;))) \u0026quot;\\\u0026quot; width=\\\u0026quot;\u0026quot; (group (0+ (not \u0026quot;\\\u0026quot;\u0026quot;))) \u0026quot;\\\u0026quot; \u0026gt;}}\u0026quot;) nil t) (let ((src (string-join (mapcar #'string (match-string 1)))) (width (string-join (mapcar #'string (match-string 2))))) (replace-match (format \u0026quot;\u0026lt;img src=\\\u0026quot;/%s\\\u0026quot; width=\\\u0026quot;%s\\\u0026quot; /\u0026gt; \u0026lt;br/\u0026gt;\u0026quot; src width)) ) ) (save-buffer) (kill-buffer) ) ) 替换子树导出文件图片链接格式 # (defun my/amend-pic-link (export-name) (interactive) (my/replace-pic-link-format (concat (my/subtree-path-str export-name) \u0026quot;.md\u0026quot;)) ) 替换文件内所有子树导出文件图片链接格式 # (defun my/amend-pic-link-for-all () (interactive) (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;:EXPORT_FILE_NAME: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (my/amend-pic-link (string-join (mapcar #'string (match-string 1)))) ) ) org-roam # 需设置相对路径 # ;; (setq my/roam-prefix \u0026quot;hugo/content/\u0026quot;) 将roam节点链接替换为博客+标题链接 # 相对路径计算采用去除前缀 (defun my/replace-roam-link () (interactive) (save-excursion (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;[[id:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot;) nil t) (let* ((id (string-join (mapcar #'string (match-string 1)))) (title (string-join (mapcar #'string (match-string 2)))) (title-downcase (string-replace \u0026quot;::\u0026quot; \u0026quot;-\u0026quot; (downcase title))) (node (org-roam-node-from-id id)) (slot)) (with-current-buffer (find-file-noselect (org-roam-node-file node)) (goto-char (org-roam-node-point node)) (outline-next-heading) (when (re-search-backward (rx \u0026quot;:EXPORT_FILE_NAME: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (setq slot (my/subtree-path-str (string-join (mapcar #'string (match-string 1))))) ) ) (when slot (save-excursion (beginning-of-buffer) (when (search-forward (format \u0026quot;[[id:%s][%s]]\u0026quot; id title) nil t) ;;(message (format \u0026quot;%s %s\u0026quot; slot title)) ;;(sleep-for 1) (replace-match (format \u0026quot;[[file:/%s/#%s][%s]]\u0026quot; (downcase (string-remove-prefix my/roam-prefix slot)) title-downcase title) nil t) ) ) ) ) ) ) ) 时间戳链接 # 删除时间戳链接 # (defun my/delete-timestamp-link () (interactive) (save-excursion (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;[[timestamp:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot;) nil t) (replace-match \u0026quot;\u0026quot; nil t) ) ) ) 源码链接 # 虚幻引擎项目源码 # (defun my/replace-ue-project-file-link () (interactive) (save-excursion (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;[[uep:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][\u0026quot; (group (0+ (not \u0026quot;:\u0026quot;))) \u0026quot;:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((proj (string-join (mapcar #'string (match-string 2)))) (file (string-join (mapcar #'string (match-string 3))))) (replace-match (format \u0026quot;=%s: %s=\u0026quot; proj file) nil t) ) ) ) ) 虚幻引擎源码 # (defun my/replace-ue-engine-file-link () (interactive) (save-excursion (beginning-of-buffer) (while (re-search-forward (rx \u0026quot;[[ue:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;][虚幻引擎:\u0026quot; (group (0+ (not \u0026quot;]\u0026quot;))) \u0026quot;]]\u0026quot; ) nil t) (let ((file (string-join (mapcar #'string (match-string 1))))) (replace-match (format \u0026quot;=%s=\u0026quot; file) nil t) ) ) ) ) 虚幻引擎项目源码链接逆向恢复 # ;; (defun my/recover-ue-project-file-link () ;; (interactive) ;; (beginning-of-buffer) ;; (while (re-search-forward (rx \u0026quot;=ShootThemUp: \u0026quot; (group (0+ (not \u0026quot;=\u0026quot;))) \u0026quot;=\u0026quot;) nil t) ;; (let ((filename (string-join (mapcar #'string (match-string 1)))) ;; (folder)) ;; (if (string-suffix-p \u0026quot;.h\u0026quot; filename) ;; (setq folder \u0026quot;Public/\u0026quot;)) ;; (if (string-suffix-p \u0026quot;.cpp\u0026quot; filename) ;; (setq folder \u0026quot;Private/\u0026quot;)) ;; (if (string-suffix-p \u0026quot;.cs\u0026quot; filename) ;; (setq folder \u0026quot;\u0026quot;)) ;; (if (string-prefix-p \u0026quot;STUGameModeBase\u0026quot; filename) ;; (setq folder \u0026quot;\u0026quot;)) ;; (replace-match (format \u0026quot;[[uep:%s%s][ShootThemUp:%s]]\u0026quot; folder filename filename) nil t) ;; ) ;; ) ;; ) 复制文本内容 # 选项 # (defun my/copy-org-options () (interactive) (save-excursion (beginning-of-buffer) (let ((op-start (point))) (outline-next-heading) (buffer-substring-no-properties op-start (point)) ) ) ) 子树 # (defun my/copy-org-subtree () (interactive) (save-excursion (outline-next-heading) (when (re-search-backward (rx \u0026quot;:EXPORT_FILE_NAME: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (outline-previous-heading) (org-copy-subtree) (current-kill 0) ) ) ) 计算权重 # (defun my/backward-heading-same-level () (interactive) (org-backward-heading-same-level 1) (point) ) (defun my/compute-weight () (interactive) (let ((cur-pos) (weight 1001)) (save-excursion (outline-next-heading) (when (re-search-backward (rx \u0026quot;:EXPORT_FILE_NAME: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (org-previous-visible-heading 1) (setq cur-pos (point)) (while (/= cur-pos (my/backward-heading-same-level)) (setq weight (+ weight 1)) (setq cur-pos (point)) ) (message \u0026quot;%d\u0026quot; weight) ) ) ) ) 导出子树 # 光标所在子树 # (defun my/ox-hugo-export-subtree () (interactive) (save-excursion (outline-next-heading) (when (re-search-backward (rx \u0026quot;:EXPORT_FILE_NAME: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;))) \u0026quot;\\n\u0026quot;) nil t) (let* ((export-name (string-join (mapcar #'string (match-string 1)))) (subtree (my/copy-org-subtree)) (options (my/copy-org-options)) (weight (my/compute-weight)) (slotlist '()) (slotlist (my/compute-subtree-path export-name)) (slot) (section) (cur-level)) (with-temp-buffer (insert options) (insert subtree) (org-mode) (my/delete-timestamp-link) (my/replace-ue-project-file-link) (my/replace-ue-engine-file-link) (my/replace-roam-link) (pop slotlist) (setq slotlist (reverse slotlist)) (pop slotlist) (setq slotlist (reverse slotlist)) (dolist (item slotlist) (setq slot (concat slot \u0026quot;/\u0026quot; item)) ) (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;+HUGO_SECTION: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;)))) nil t) (setq section (string-join (mapcar #'string (match-string 1)))) (replace-match (format \u0026quot;+HUGO_SECTION: %s\u0026quot; (concat section slot))) ) (beginning-of-buffer) (when (re-search-forward (rx \u0026quot;EXPORT_HUGO_WEIGHT: \u0026quot; (group (0+ (not \u0026quot;\\n\u0026quot;)))) nil t) (replace-match (format \u0026quot;EXPORT_HUGO_WEIGHT: %s\u0026quot; weight)) ) (beginning-of-buffer) (outline-next-heading) (setq cur-level (funcall outline-level)) (while (/= 1 cur-level) (org-shiftmetaleft) (setq cur-level (funcall outline-level)) ) (org-hugo-export-wim-to-md) (my/amend-pic-link export-name) ) ) ) ) ) (global-set-key (kbd \u0026quot;C-c h s\u0026quot;) 'my/ox-hugo-export-subtree) 文件内所有子树 # (defun my/ox-hugo-export-all-subtrees () (interactive) (save-excursion (let ((buf-content (buffer-string))) (with-temp-buffer (insert buf-content) (org-mode) (my/delete-timestamp-link) (my/replace-ue-project-file-link) (my/replace-ue-engine-file-link) (my/replace-roam-link) (org-hugo-export-wim-to-md :all-subtrees) (my/amend-pic-link-for-all) ) ) ) ) (global-set-key (kbd \u0026quot;C-c h a\u0026quot;) 'my/ox-hugo-export-all-subtrees) `}),e.add({id:59,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E8%A1%A8%E6%A0%BC%E4%B8%AD%E6%96%87%E5%AF%B9%E9%BD%90/",title:"表格中文对齐",description:"便签 # 参考 方法一: 使用valign # 像素对齐 使用时会导致图片加载卡顿 ;; (use-package valign ;; :ensure t ;; ) ;; (add-hook 'org-mode-hook #'valign-mode) 方法二: 使用cnfonts # GitHub 字体受到cnfonts支持的限制 ;; (use-package cnfonts ;; :ensure t) ;; (cnfonts-mode 1) ;; (define-key cnfonts-mode-map (kbd \u0026quot;C--\u0026quot;) #'cnfonts-decrease-fontsize) ;; (define-key cnfonts-mode-map (kbd \u0026quot;C-=\u0026quot;) #'cnfonts-increase-fontsize) 方法三: 分别对中文字体和英文字体进行设置 # 找到满足英文:中文=1:2的两个字体 下载Iosevka # GitHub # brew tap homebrew/cask-fonts # brew install font-iosevka 设置Emacs中英文字体 # 字号使用14, 16正常 ;; (let ((default-font (font-spec :name \u0026quot;Iosevka\u0026quot; :size 14)) ;; (cn-font (font-spec :name \u0026quot;Sarasa Mono SC\u0026quot;))) ;; (set-face-attribute 'default nil :font default-font) ;; (dolist (charset '(kana han symbol cjk-misc bopomofo)) ;; (set-fontset-font t charset cn-font))) 方法四: 对org-mode表格字体进行设置 # 要求字体英文:中文=1:2 下载更纱字体 # # brew install font-sarasa-gothic 设置表格字体 # 更纱黑体 # ;; (custom-set-faces ;; '(org-table ((t (:family \u0026quot;等距更纱黑体 SC\u0026quot;))))) Iosevka # (custom-set-faces '(org-table ((t (:family \u0026quot;Iosevka\u0026quot;))))) Sarasa Mono SC # ;; (custom-set-faces ;; '(org-table ((t (:family \u0026quot;Sarasa Mono SC\u0026quot;))))) 设置Emacs字体 # ;; (let ((emacs-font-size 14) ;; (emacs-font-name \u0026quot;Victor Mono\u0026quot;)) ;; (set-frame-font (format \u0026quot;%s-%s\u0026quot; (eval emacs-font-name) (eval emacs-font-size))) ;; (set-fontset-font (frame-parameter nil 'font) 'unicode (eval emacs-font-name))) ",content:"便签 # 参考 方法一: 使用valign # 像素对齐 使用时会导致图片加载卡顿 ;; (use-package valign ;; :ensure t ;; ) ;; (add-hook 'org-mode-hook #'valign-mode) 方法二: 使用cnfonts # GitHub 字体受到cnfonts支持的限制 ;; (use-package cnfonts ;; :ensure t) ;; (cnfonts-mode 1) ;; (define-key cnfonts-mode-map (kbd \u0026quot;C--\u0026quot;) #'cnfonts-decrease-fontsize) ;; (define-key cnfonts-mode-map (kbd \u0026quot;C-=\u0026quot;) #'cnfonts-increase-fontsize) 方法三: 分别对中文字体和英文字体进行设置 # 找到满足英文:中文=1:2的两个字体 下载Iosevka # GitHub # brew tap homebrew/cask-fonts # brew install font-iosevka 设置Emacs中英文字体 # 字号使用14, 16正常 ;; (let ((default-font (font-spec :name \u0026quot;Iosevka\u0026quot; :size 14)) ;; (cn-font (font-spec :name \u0026quot;Sarasa Mono SC\u0026quot;))) ;; (set-face-attribute 'default nil :font default-font) ;; (dolist (charset '(kana han symbol cjk-misc bopomofo)) ;; (set-fontset-font t charset cn-font))) 方法四: 对org-mode表格字体进行设置 # 要求字体英文:中文=1:2 下载更纱字体 # # brew install font-sarasa-gothic 设置表格字体 # 更纱黑体 # ;; (custom-set-faces ;; '(org-table ((t (:family \u0026quot;等距更纱黑体 SC\u0026quot;))))) Iosevka # (custom-set-faces '(org-table ((t (:family \u0026quot;Iosevka\u0026quot;))))) Sarasa Mono SC # ;; (custom-set-faces ;; '(org-table ((t (:family \u0026quot;Sarasa Mono SC\u0026quot;))))) 设置Emacs字体 # ;; (let ((emacs-font-size 14) ;; (emacs-font-name \u0026quot;Victor Mono\u0026quot;)) ;; (set-frame-font (format \u0026quot;%s-%s\u0026quot; (eval emacs-font-name) (eval emacs-font-size))) ;; (set-fontset-font (frame-parameter nil 'font) 'unicode (eval emacs-font-name))) "}),e.add({id:60,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8D%E5%BD%B1%E5%93%8D%E5%BF%AB%E6%8D%B7%E9%94%AE/",title:"使用中文输入法不影响快捷键",description:"说明 # GitHub C-c e g不用切换输入法 Vim除Insert模式外锁定英文 逗号和句号使用全角, 其他符号使用半角 注意 # Emacs Rime依赖动态模块 切换到emacs-plus 配置librime # macOS 已安装鼠须管 # 下载编译好的librime # # curl -L -O https://github.com/rime/librime/releases/download/1.7.1/rime-1.7.1-osx.zip # unzip rime-1.7.1-osx.zip -d ~/.emacs.d/librime # rm -rf rime-1.7.1-osx.zip 配置librime路径 # ;; (setq my/rime-librime-root \u0026quot;~/.emacs.d/librime/dist\u0026quot;) 配置用户数据路径 # ;; (setq my/rime-user-data-dir \u0026quot;path/to/rime/user/data\u0026quot;) 路径 Rime-安装 # (use-package rime :ensure t :custom (rime-librime-root my/rime-librime-root) (default-input-method \u0026quot;rime\u0026quot;) (rime-user-data-dir my/rime-user-data-dir) (rime-show-candidate 'posframe) :bind (:map rime-mode-map (\u0026quot;C-`\u0026quot; . 'rime-send-keybinding))) 在当前文档激活Rime输入法 # C-\\ 设置简体 # C-` 选择 朙月拼音·简化字 设置符号半角/全角 # C-` 选择 中/半/汉/.",content:"说明 # GitHub C-c e g不用切换输入法 Vim除Insert模式外锁定英文 逗号和句号使用全角, 其他符号使用半角 注意 # Emacs Rime依赖动态模块 切换到emacs-plus 配置librime # macOS 已安装鼠须管 # 下载编译好的librime # # curl -L -O https://github.com/rime/librime/releases/download/1.7.1/rime-1.7.1-osx.zip # unzip rime-1.7.1-osx.zip -d ~/.emacs.d/librime # rm -rf rime-1.7.1-osx.zip 配置librime路径 # ;; (setq my/rime-librime-root \u0026quot;~/.emacs.d/librime/dist\u0026quot;) 配置用户数据路径 # ;; (setq my/rime-user-data-dir \u0026quot;path/to/rime/user/data\u0026quot;) 路径 Rime-安装 # (use-package rime :ensure t :custom (rime-librime-root my/rime-librime-root) (default-input-method \u0026quot;rime\u0026quot;) (rime-user-data-dir my/rime-user-data-dir) (rime-show-candidate 'posframe) :bind (:map rime-mode-map (\u0026quot;C-`\u0026quot; . 'rime-send-keybinding))) 在当前文档激活Rime输入法 # C-\\ 设置简体 # C-` 选择 朙月拼音·简化字 设置符号半角/全角 # C-` 选择 中/半/汉/. 选择 。，→., "}),e.add({id:61,href:"/docs/",title:"笔记",description:"",content:""}),e.add({id:62,href:"/docs/%E5%88%86%E4%BA%AB/emacs/",title:"Emacs",description:"",content:""}),e.add({id:63,href:"/docs/brick/",title:"🧱",description:"",content:""}),e.add({id:64,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/",title:"开发工具",description:"",content:""}),e.add({id:65,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/",title:"开发语言",description:"",content:""}),e.add({id:66,href:"/docs/%E5%88%86%E4%BA%AB/hugo/",title:"Hugo",description:"",content:""}),e.add({id:67,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/",title:"专题",description:"",content:""}),e.add({id:68,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/",title:"API",description:"",content:""}),e.add({id:69,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/",title:"虚幻引擎",description:"",content:""}),e.add({id:70,href:"/docs/%E5%88%86%E4%BA%AB/",title:"分享",description:"",content:""}),e.add({id:71,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/",title:"进阶课程",description:"",content:""}),e.add({id:72,href:"/docs/%E5%88%86%E4%BA%AB/macos%E5%BA%94%E7%94%A8/",title:"macOS应用",description:"",content:""}),e.add({id:73,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E9%9C%80%E6%B1%82/",title:"需求",description:"",content:""}),e.add({id:74,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/",title:"角色和动画",description:"",content:""}),e.add({id:75,href:"/docs/%E5%88%86%E4%BA%AB/emacs/%E6%83%B3%E6%B3%95/",title:"想法",description:"",content:""}),e.add({id:76,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/",title:"健康系统",description:"",content:""}),e.add({id:77,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E6%AD%A6%E5%99%A8/",title:"武器",description:"",content:""}),e.add({id:78,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BB%E7%BC%96%E8%BE%91%E5%99%A8/",title:"虚幻编辑器",description:"",content:""}),e.add({id:79,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E4%B8%93%E9%A2%98/%E8%99%9A%E5%B9%BBc++/",title:"虚幻C++",description:"",content:""}),e.add({id:80,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/",title:"虚幻C++",description:"",content:""}),e.add({id:81,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/engine/",title:"Engine",description:"",content:""}),e.add({id:82,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E5%85%B3%E5%8D%A1%E8%AE%BE%E7%BD%AE/",title:"关卡设置",description:"",content:""}),e.add({id:83,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",title:"数据结构",description:"",content:""}),e.add({id:84,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2/",title:"游戏角色",description:"",content:""}),e.add({id:85,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/api/%E8%99%9A%E5%B9%BBc++/%E7%BB%84%E4%BB%B6/",title:"组件",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()