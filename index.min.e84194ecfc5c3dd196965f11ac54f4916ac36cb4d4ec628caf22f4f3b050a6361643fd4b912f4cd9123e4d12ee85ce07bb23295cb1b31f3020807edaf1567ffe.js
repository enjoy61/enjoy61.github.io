var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E8%BF%90%E8%A1%8Cshootergame%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE/",title:"运行ShooterGame示例项目",description:"下载ShooterGame # Epic Games Launcher \u0026gt; Samples \u0026gt; Shooter Game 支持引擎版本 4.0 - 4.27 ，当前使用引擎版本 5.1.1 修改源码 # 退化类 # UMatineeCameraShake 已被 ULegacyCameraShake 替代 不再支持的宏 # PLATFORM_PS4 改法一: 定义该宏 # 在引擎代码中，紧接着 SWITCH 定义该宏 改法二: 屏蔽该宏的出现 # 条件运算符第二个和第三个操作数类型不一致, 且可以互相转换 # 参考 AController * 和 AActor * 可以相互转换，此处有歧义 Source/ShooterGame/Private/Player/ShooterCharacter.cpp:322 运行效果 # ",content:"下载ShooterGame # Epic Games Launcher \u0026gt; Samples \u0026gt; Shooter Game 支持引擎版本 4.0 - 4.27 ，当前使用引擎版本 5.1.1 修改源码 # 退化类 # UMatineeCameraShake 已被 ULegacyCameraShake 替代 不再支持的宏 # PLATFORM_PS4 改法一: 定义该宏 # 在引擎代码中，紧接着 SWITCH 定义该宏 改法二: 屏蔽该宏的出现 # 条件运算符第二个和第三个操作数类型不一致, 且可以互相转换 # 参考 AController * 和 AActor * 可以相互转换，此处有歧义 Source/ShooterGame/Private/Player/ShooterCharacter.cpp:322 运行效果 # "}),e.add({id:1,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%94%9F%E5%91%BD%E5%80%BC/",title:"实时显示游戏角色生命值",description:"概览 # - 健康组件 ActorComponent 自定义，纯逻辑 文本组件 TextRenderComponent 显示生命值 创建健康组件 # 创建Component/STUHealthComponent # 虚幻编辑器 ActorComponent 公有类 调整健康组件框架 # C++ ShootThemUp: Components/STUHealthComponent.h ShootThemUp: Components/STUHealthComponent.cpp - 默认构造函数 将每帧调用TickComponent函数标志置为false BeginPlay TickComponent 屏蔽，使用基类实现 实现 # 添加生命值上限 # protected ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1000.0\u0026quot;)) float MaxHealth = 100.0f;	添加生命值 # private ShootThemUp: Components/STUHealthComponent.h float Health = 0.0f; 初始化生命值 # ShootThemUp: Components/STUHealthComponent.cpp // BeginPlay Health = MaxHealth; 添加接口，返回生命值 # public ShootThemUp: Components/STUHealthComponent.",content:"概览 # - 健康组件 ActorComponent 自定义，纯逻辑 文本组件 TextRenderComponent 显示生命值 创建健康组件 # 创建Component/STUHealthComponent # 虚幻编辑器 ActorComponent 公有类 调整健康组件框架 # C++ ShootThemUp: Components/STUHealthComponent.h ShootThemUp: Components/STUHealthComponent.cpp - 默认构造函数 将每帧调用TickComponent函数标志置为false BeginPlay TickComponent 屏蔽，使用基类实现 实现 # 添加生命值上限 # protected ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;1000.0\u0026quot;)) float MaxHealth = 100.0f;	添加生命值 # private ShootThemUp: Components/STUHealthComponent.h float Health = 0.0f; 初始化生命值 # ShootThemUp: Components/STUHealthComponent.cpp // BeginPlay Health = MaxHealth; 添加接口，返回生命值 # public ShootThemUp: Components/STUHealthComponent.h UFUNCTION(BlueprintCallable) float GetHealth() const { return Health; } 为游戏角色添加健康组件 # C++ 添加STUHealthComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h class USTUHealthComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USTUHealthComponent *HealthComponent; 初始化组件: STUHealthComponent无表示，不用设置上级组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/STUHealthComponent.h\u0026quot; // 构造函数 HealthComponent = CreateDefaultSubobject\u0026lt;USTUHealthComponent\u0026gt;(\u0026quot;HealthComponent\u0026quot;); 为游戏角色添加文本组件 # C++ 添加UTextRenderComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h class UTextRenderComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UTextRenderComponent *HealthTextComponent;	初始化组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/TextRenderComponent.h\u0026quot; // 构造函数 HealthTextComponent = CreateDefaultSubobject\u0026lt;UTextRenderComponent\u0026gt;(\u0026quot;HealthTextComponent\u0026quot;); HealthTextComponent-\u0026gt;SetupAttachment(GetRootComponent()); 每帧更新HealthTextComponent文本 ShootThemUp: Player/STUBaseCharacter.cpp // Tick HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); 检查组件是否成功初始化 # 使用IDE编译时，若运行游戏崩溃，可在IDE中查看断点 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay check(HealthComponent); check(HealthTextComponent); 调整文本组件 # 虚幻编辑器 BP_STUBaseCharacter 查看组件 # HealthComponent和CharacterMovement无层级：二者均无表示，纯逻辑；创建后无需挂在其他组件下面 查看HealthComponent # 调整TextRender组件 # - Tranform Z: 100 Yaw: 180 第三视角：运行时摄像机对着 Character 背面 Text 0 默认值 Horizontal Alignment Center 水平对齐 Text Render Color 深蓝色 文本颜色 效果图 # "}),e.add({id:2,href:"/docs/%E5%88%86%E4%BA%AB/emacs/org-mode/",title:"org-mode",description:"便签 # The Org Manual 样式 # 删除线 +Content+ 下划线 ox-hugo转markdown存在问题 _Content_ 文本块 =test= ~test~ 斜体 /test/ 加粗 *test* 分隔线 ----- 标题 # 标题间移动 # - 上一个 C-c C-p 下一个 C-c C-n 去到上级标题 C-c C-u 同级标题间移动 上一个 C-c C-b 同级标题间移动 下一个 C-c C-f 创建标题 # - 同级标题 C-RET 同级标题 / 列表项 M-RET 同级TODO标题 M-S-RET 标题、列表项转换 # - 标题转换为列表项 C-c - 文本、列表项 转换为标题 C-c * 升降级 # - 标题、列表项 升降级 M-LEFT / M-RIGHT 子树 # - 删除子树 C-c C-x C-w 拷贝子树 C-c C-x M-w 升降级 M-S-LEFT / M-S-RIGHT 标题状态切换 # - TODO标题状态切换 C-c C-t S-LEFT / S-RIGHT \u0026gt; 普通标题 \u0026gt; TODO \u0026gt; DONE 显示 # - 进入预览模式，显示一级标题 C-c C-j 标题展开 S-TAB \u0026gt; 只展开一级标题 \u0026gt; 展开所有标题 \u0026gt; 展开全部内容 模板 # Structure Templates - 快捷键 C-c C-, \u0026lt;s TAB 不再支持 函数 org-insert-structure-template 模板样式 # 代码框 填写编程语言 // C++样式 #+begin_src \u0026lt;language\u0026gt; #+end_src 文本框 文本框样式 #+begin_example #+end_example quote quote样式 #+begin_quote #+end_quote 代码块编辑 # - 插入代码框 C-c C-, s 在新窗口编辑代码 C-c ' 保存修改 C-x C-s 关闭编辑窗口(未保存丢失) C-c C-k 执行 C-c C-c 计时 # 精确到分钟 - 开始 C-c C-x C-i 停止 C-c C-x C-o 链接 # - 插入 C-c C-l 打开 C-c C-o 显示/ 隐藏 图片 C-c C-x C-v 链接 # [[http://www.",content:"便签 # The Org Manual 样式 # 删除线 +Content+ 下划线 ox-hugo转markdown存在问题 _Content_ 文本块 =test= ~test~ 斜体 /test/ 加粗 *test* 分隔线 ----- 标题 # 标题间移动 # - 上一个 C-c C-p 下一个 C-c C-n 去到上级标题 C-c C-u 同级标题间移动 上一个 C-c C-b 同级标题间移动 下一个 C-c C-f 创建标题 # - 同级标题 C-RET 同级标题 / 列表项 M-RET 同级TODO标题 M-S-RET 标题、列表项转换 # - 标题转换为列表项 C-c - 文本、列表项 转换为标题 C-c * 升降级 # - 标题、列表项 升降级 M-LEFT / M-RIGHT 子树 # - 删除子树 C-c C-x C-w 拷贝子树 C-c C-x M-w 升降级 M-S-LEFT / M-S-RIGHT 标题状态切换 # - TODO标题状态切换 C-c C-t S-LEFT / S-RIGHT \u0026gt; 普通标题 \u0026gt; TODO \u0026gt; DONE 显示 # - 进入预览模式，显示一级标题 C-c C-j 标题展开 S-TAB \u0026gt; 只展开一级标题 \u0026gt; 展开所有标题 \u0026gt; 展开全部内容 模板 # Structure Templates - 快捷键 C-c C-, \u0026lt;s TAB 不再支持 函数 org-insert-structure-template 模板样式 # 代码框 填写编程语言 // C++样式 #+begin_src \u0026lt;language\u0026gt; #+end_src 文本框 文本框样式 #+begin_example #+end_example quote quote样式 #+begin_quote #+end_quote 代码块编辑 # - 插入代码框 C-c C-, s 在新窗口编辑代码 C-c ' 保存修改 C-x C-s 关闭编辑窗口(未保存丢失) C-c C-k 执行 C-c C-c 计时 # 精确到分钟 - 开始 C-c C-x C-i 停止 C-c C-x C-o 链接 # - 插入 C-c C-l 打开 C-c C-o 显示/ 隐藏 图片 C-c C-x C-v 链接 # [[http://www.baidu.com][百度]] 文件 # [[file:xxx.txt][描述]] 图片 # #+ATTR_ORG: :width 400 #+ATTR_HTML: :width 500 [[file:pic/xxxx.png]] org文件导出 # html # - 生成文件并打开 C-c C-e h o markdown # - 生成文件并打开 C-c C-e m o 菜单项添加markdown选项 customize-option \u0026gt; org-export-backends \u0026gt; 勾选org-markdown 安装markdown-mode 日程管理 # agenda 搜索路径保存在列表org-agenda-files中，不支持递归搜索 # 查看 # - 日程菜单 org-agenda 快捷键(自定义) C-c a 切换当日安排 / 本周安排 d / w 添加任务 # - 开始 C-c C-s 结束 C-c C-d 表格 # 快捷键 # - M-LEFT / M-RIGHT 移动当前列 M-UP / M-DOWN 移动当前行 C-c - 在当前行下方加分割线 C-c RET 在当前行下方加分割线 M-a 移动到cell开始 M-e 移动到cell末尾 TAB 下一个cell S-TAB 上一个cell C-c C-c 格式化表格 M-S-LEFT 删除当前列 M-S-RIGHT 左侧新建列 计算 # 快捷键 查询单元所在行列 C-c ? 显示表格相对行列 C-c } 行累加 # 在公式所在行C-c C-c 待累加数值 3 2 10 22 累加 37 使用插件按类别统计 # orgtbl-aggregate 类别 金额 项目 水果 10 苹果 水果 8 香蕉 日化 12 洗手液 类别 sum(金额) 水果 18 日化 12 缩进 # 第一种: 文本不含空格，但org-mode下显示缩进 # indent mode 使能mode (org-indent-mode t) 全局设置 (setq org-startup-indented t) 文件选项 #+STARTUP：indent 第二种: 换行时自动缩进 # hard indentation 全局设置 (setq org-adapt-indentation t) 隐藏前缀星号 # 全局设置 (setq org-hide-leading-stars t) 文件选项 #+STARTUP: hidestars 选项设置 # 文章目录 # Table of Contents 关闭toc #+OPTIONS: toc:nil 指定toc显示层级 #+TOC: headlines 2 自动为标题添加标号 # 关闭 #+OPTIONS num:nil 上下标 # a_b a^b 关闭 #+OPTIONS: ^:nil 使用{}转义 #+OPTIONS ^:{} 示例 a_{b} a^{b} 选项合并 #+OPTIONS: toc:nil ^:{} 显示 # 一级标题预览 #+STARTUP: overview 显示所有内容 #+STARTUP: showall 选项合并 #+STARTUP: showall hidestars "}),e.add({id:3,href:"/docs/%E5%88%86%E4%BA%AB/macos%E5%BA%94%E7%94%A8/%E7%BB%88%E7%AB%AF/",title:"终端",description:"iTerm2 # 官网下载 窗口管理 # 快捷键 操作 Command-W 关闭窗口 分屏 # 快捷键 操作 Command-D 左右分屏 Command-Shift-D 上下分屏 Command-[ 切换 Command-] Option-Command-UP 根据方向键切换 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 # 快捷键 操作 Command-T 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right 状态栏 # Status Bar 使能 # Preferences \u0026gt; Profiles \u0026gt; Session 勾选 Status bar enabled 点击 Configure Status Bar , 选择显示组件 设置状态栏位置 # Preferences \u0026gt; Appearence \u0026gt; General \u0026gt; Status bar location 选择 Bottom 配色 # 下载配色 # - 官方提供的配色 : lovelace Afterglow Dracula 导入配色 # Preferences \u0026gt; Profiles \u0026gt; Color \u0026gt; Color Presets \u0026gt; Import 设置窗口大小 # Preferences \u0026gt; Profiles \u0026gt; Window 设置 Columns 和 Rows 透明度 # Preferences \u0026gt; Profiles \u0026gt; Window \u0026gt; Transparency 选择 3 字体 # 下载字体 # - Consolas Victor Mono 配置 # Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Font 选择 Victor Mono 字号选择 14 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 安装Homebrew # /bin/bash -c \u0026quot;$(curl -fsSL https://mirrors.",content:"iTerm2 # 官网下载 窗口管理 # 快捷键 操作 Command-W 关闭窗口 分屏 # 快捷键 操作 Command-D 左右分屏 Command-Shift-D 上下分屏 Command-[ 切换 Command-] Option-Command-UP 根据方向键切换 Option-Command-Down Option-Command-Left Option-Command-Right 标签页 # 快捷键 操作 Command-T 新建标签页 Command-NUM 根据标号切换标签页 Command-Shift-[ 切换标签页 Command-Shift-] Command-Left 根据方向键切换标签页窗口 Command-Right 状态栏 # Status Bar 使能 # Preferences \u0026gt; Profiles \u0026gt; Session 勾选 Status bar enabled 点击 Configure Status Bar , 选择显示组件 设置状态栏位置 # Preferences \u0026gt; Appearence \u0026gt; General \u0026gt; Status bar location 选择 Bottom 配色 # 下载配色 # - 官方提供的配色 : lovelace Afterglow Dracula 导入配色 # Preferences \u0026gt; Profiles \u0026gt; Color \u0026gt; Color Presets \u0026gt; Import 设置窗口大小 # Preferences \u0026gt; Profiles \u0026gt; Window 设置 Columns 和 Rows 透明度 # Preferences \u0026gt; Profiles \u0026gt; Window \u0026gt; Transparency 选择 3 字体 # 下载字体 # - Consolas Victor Mono 配置 # Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Font 选择 Victor Mono 字号选择 14 Homebrew # 官网 使用中科大 USTC 提供的安装脚本和软件源 参考 安装Homebrew # /bin/bash -c \u0026quot;$(curl -fsSL https://mirrors.ustc.edu.cn/misc/brew-install.sh)\u0026quot; 设置源 # 源代码仓库 export HOMEBREW_BREW_GIT_REMOTE=\u0026quot;https://mirrors.ustc.edu.cn/brew.git\u0026quot; 预编译二进制软件包与软件包元数据文件 export HOMEBREW_BOTTLE_DOMAIN=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-bottles\u0026quot; export HOMEBREW_API_DOMAIN=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-bottles/api\u0026quot; 核心软件仓库 export HOMEBREW_CORE_GIT_REMOTE=\u0026quot;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026quot; 写入配置文件, 重新导入 vi ～/.zshrc source ～/.zshrc 管理软件 # 默认下载源码在本地编译安装，通常是不带界面的命令行工具和第三方库; 使用cask选项则安装编译好的软件包，通常是一些带界面的软件 安装/卸载 # brew install --cask emacs # 安装 brew uninstall --cask emacs # 卸载 brew install \u0026lt;package\u0026gt; brew uninstall \u0026lt;package\u0026gt; brew autoremove # 卸载未使用依赖 查看 # brew list # 当前管理的程序 brew search \u0026lt;package\u0026gt; # 查找 brew info \u0026lt;package\u0026gt; # 查看包 代理 # Privoxy 安装Privoxy # 依赖pcre brew install privoxy 配置Privoxy # Privoxy使用端口号8118 vi /usr/local/etc/privoxy/config # 在文件末尾添加以下代码 listen-address 0.0.0.0:8118 forward-socks5 / localhost:1080 . 手动启动Privoxy sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config 查看端口是否被监听 netstat -na | grep 8118 为终端配置代理 # 查询本地代理使用端口 系统偏好设置 \u0026gt; 网络 \u0026gt; Wi-Fi \u0026gt; 高级 \u0026gt; 代理 \u0026gt; 网页代理 / 安全网页代理 配置环境变量 vi ~/.zshrc # 添加以下内容 # 使用本地代理使用端口替换1949 export http_proxy='http://localhost:1949' export https_proxy=$http_proxy # 重载配置文件 source ~/.zshrc oh-my-zsh # 官网 安装oh-my-zsh # sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; 设置主题 # 第三方主题 # 下载Dracula主题 ln -s Dracula/zsh/dracula.zsh-theme ~/.oh-my-zsh/themes/ 设置主题 vi ~/.zshrc # 屏蔽默认主题, 添加以下内容 # ZSH_THEME=\u0026quot;robbyrussell\u0026quot; ZSH_THEME=\u0026quot;dracula\u0026quot; # 载入配置 source ~/.zshrc 官方主题 # 下载时已存放在本地 官方主题展示 使用随机主题 ZSH_THEME=\u0026quot;random\u0026quot; # 随机 "}),e.add({id:4,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/bash/",title:"Shell脚本",description:"花括号的使用 # 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这样使用，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 tr命令 # runoob 去除引号 # tr -d '\u0026quot;' 使用sed sed 's/\\\u0026quot;//g' sed命令 # macOS runoob 安装gsed # brew install gsed 匹配行打印 # p gsed -n \u0026quot;/abc/p\u0026quot; file 修改源文件 # -i gsed -i \u0026quot;/abc/d\u0026quot; file # 匹配行删除 匹配行删除 # d gsed \u0026quot;/abc/d\u0026quot; file 匹配行文本替换 # s 首个匹配项 gsed \u0026quot;s/abc/edf/\u0026quot; file 所有匹配项 g gsed \u0026quot;s/abc/edf/g\u0026quot; file awk命令 # 指定分隔符，打印第3个参数 # awk -F ',' '{print $3}' file命令 # 查看文件编码 # file FILE echo命令 # 输出单行 # var=\u0026quot;hello world!",content:"花括号的使用 # 可以使用花括号定义集合集合，集合内有多个可以枚举的项，使用逗号分隔 {项1, 项2, 项3...} 遇到花括号时，会对集合进行展开，将集合内的每一项与外面的字符串进行组合，然后返回全部组合项 xxx.conf{,.bak} 展开为 xxx.conf xxx.conf.bak 和前方的命令配合起来，就可以起到多个入参的效果 cp xxx.conf{,.bak} # cp xxx.conf xxx.conf.bak 接受多个参数的命令都可以这样使用，但前提是这些参数有共同部分，或者有某些规律 echo cp mkdir mv for mkdir app{,.bak} echo {1..5} echo {a..z} echo {001..10} # 前导0 echo {001..10..2} # 前导0 + 步进 echo {a..z}{0..9} # 组合：26 * 10 tr命令 # runoob 去除引号 # tr -d '\u0026quot;' 使用sed sed 's/\\\u0026quot;//g' sed命令 # macOS runoob 安装gsed # brew install gsed 匹配行打印 # p gsed -n \u0026quot;/abc/p\u0026quot; file 修改源文件 # -i gsed -i \u0026quot;/abc/d\u0026quot; file # 匹配行删除 匹配行删除 # d gsed \u0026quot;/abc/d\u0026quot; file 匹配行文本替换 # s 首个匹配项 gsed \u0026quot;s/abc/edf/\u0026quot; file 所有匹配项 g gsed \u0026quot;s/abc/edf/g\u0026quot; file awk命令 # 指定分隔符，打印第3个参数 # awk -F ',' '{print $3}' file命令 # 查看文件编码 # file FILE echo命令 # 输出单行 # var=\u0026quot;hello world!\u0026quot; echo $var 输出多行 # echo -e \u0026quot;\\nhello world!\\n\u0026quot; head命令 # 安装coreutils # brew install coreutils 输出文件去掉末尾4行的文本 # ghead -n -4 xx.txt "}),e.add({id:5,href:"/docs/brick/%E7%BB%88%E7%AB%AF/",title:"终端",description:"便签 # 介绍CLI，Terminal，Shell和Prompt视频 shell概念 # 接口 shell，和core相区分，是操作系统的外层。通过Shell程序，可以使用系统服务或其他程序提供的功能。 根据操作系统类别和操作类型，shell可以分为图形shell（图形用户界面）和命令行shell（命令行界面）。 CLI Command-Line Interface 命令行界面 通过文本命令和计算机交互 GUI Graphical User Interface 图形用户界面 通过鼠标操作 早期的操作系统并没有图形用户接口，我们通常说的shell，指的是命令行shel。 终端程序 # Terminal Wrapper Program 在终端输入文本命令 终端程序 说明 iTerm MacOS Windows Terminal Windows Gnome Terminal 使用Gnome作为桌面的Linux自带的终端程序 Hyper Warp 目前MacOS；自动补全，鼠标交互，内置工作流，AI功能 Alacrity 命令解释器 # Shell 程序 终端中运行的程序。接受命令，然后解释并执行。 Shell启动时自动读取配置文件。 Shell 说明 sh Bourne Shell UNIX上的标准shell bash Bourne-Again Shell GNU开发；Linux默认 不完全兼容sh shell，对一些命令和参数进行了扩展 配置文件 ~/.bash_profile zsh 19年之前MacOS默认Bash；之后使用zsh 配置文件 ~/zshrc 第三方框架oh-my-zsh提供其他功能 phish 脚本语言 # 需要解释器，每次运行时都需要解释。 - JavaScript PHP Lua Python C# Shell脚本 # 开发语言 Shell Script 由一连串Shell命令组成，可以指定解释脚本的Shell程序。 命令提示符 # Prompt 命令解释器提供并在终端显示，如当前路径和git信息。 类别 第三方提示 Powerline Starship Power Level 10K Spaceship 第三方框架 oh-my-zsh 提供各种promots，configuration options，aliases，plugins。支持自定义prompt，调整Shell行为 查看Shell信息 # 命令解释器 当前使用的Shell echo $SHELL echo $0 已安装Shell cat /etc/shells Shell操作 # 切换Shell程序 重新打开终端生效 chsh -s /bin/bash 不修改SHELL环境变量 zsh 手动读取配置文件 zsh source ~/.",content:"便签 # 介绍CLI，Terminal，Shell和Prompt视频 shell概念 # 接口 shell，和core相区分，是操作系统的外层。通过Shell程序，可以使用系统服务或其他程序提供的功能。 根据操作系统类别和操作类型，shell可以分为图形shell（图形用户界面）和命令行shell（命令行界面）。 CLI Command-Line Interface 命令行界面 通过文本命令和计算机交互 GUI Graphical User Interface 图形用户界面 通过鼠标操作 早期的操作系统并没有图形用户接口，我们通常说的shell，指的是命令行shel。 终端程序 # Terminal Wrapper Program 在终端输入文本命令 终端程序 说明 iTerm MacOS Windows Terminal Windows Gnome Terminal 使用Gnome作为桌面的Linux自带的终端程序 Hyper Warp 目前MacOS；自动补全，鼠标交互，内置工作流，AI功能 Alacrity 命令解释器 # Shell 程序 终端中运行的程序。接受命令，然后解释并执行。 Shell启动时自动读取配置文件。 Shell 说明 sh Bourne Shell UNIX上的标准shell bash Bourne-Again Shell GNU开发；Linux默认 不完全兼容sh shell，对一些命令和参数进行了扩展 配置文件 ~/.bash_profile zsh 19年之前MacOS默认Bash；之后使用zsh 配置文件 ~/zshrc 第三方框架oh-my-zsh提供其他功能 phish 脚本语言 # 需要解释器，每次运行时都需要解释。 - JavaScript PHP Lua Python C# Shell脚本 # 开发语言 Shell Script 由一连串Shell命令组成，可以指定解释脚本的Shell程序。 命令提示符 # Prompt 命令解释器提供并在终端显示，如当前路径和git信息。 类别 第三方提示 Powerline Starship Power Level 10K Spaceship 第三方框架 oh-my-zsh 提供各种promots，configuration options，aliases，plugins。支持自定义prompt，调整Shell行为 查看Shell信息 # 命令解释器 当前使用的Shell echo $SHELL echo $0 已安装Shell cat /etc/shells Shell操作 # 切换Shell程序 重新打开终端生效 chsh -s /bin/bash 不修改SHELL环境变量 zsh 手动读取配置文件 zsh source ~/.zshrc 指定Shell脚本的命令解释器 #!/bin/bash "}),e.add({id:6,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/",title:"Git",description:"代码管理, 版本控制 安装 # macOS 方法一: Xcode自带 # 方法二: 使用homebrew安装较新版本 # brew install git 方法三: 下载源码, 编译安装 # 官网下载git-2.41.0.tar.gz make install 验证 # git -v 配置 # 查看Git配置 git config --list 配置Git账户 git config --global user.name \u0026quot;enjoy61\u0026quot; git config --global user.email \u0026quot;enjoy61@protonmail.com\u0026quot; 配置SSH 生成密钥 ssh-keygen cat ~/.ssh/id_rsa.pub 拷贝公钥到Github 代理 设置 # 使用代理端口替换1949 git config --global https.proxy https://localhost:1949 git config --global http.proxy http://localhost:1949 取消 git config --global --unset http.proxy git config --global --unset https.",content:"代码管理, 版本控制 安装 # macOS 方法一: Xcode自带 # 方法二: 使用homebrew安装较新版本 # brew install git 方法三: 下载源码, 编译安装 # 官网下载git-2.41.0.tar.gz make install 验证 # git -v 配置 # 查看Git配置 git config --list 配置Git账户 git config --global user.name \u0026quot;enjoy61\u0026quot; git config --global user.email \u0026quot;enjoy61@protonmail.com\u0026quot; 配置SSH 生成密钥 ssh-keygen cat ~/.ssh/id_rsa.pub 拷贝公钥到Github 代理 设置 # 使用代理端口替换1949 git config --global https.proxy https://localhost:1949 git config --global http.proxy http://localhost:1949 取消 git config --global --unset http.proxy git config --global --unset https.proxy 初始化项目 # 已在Github创建项目 场景一: 从Github克隆项目，上游信息自动配置 # git clone git@github.com:enjoy61/even.git 查看远端信息 # git remote -v 场景二: 手动配置上游信息 # git init git remote add cute git@github.com:enjoy61/even.git # cute为上游别名 git fetch cute # 拉取上游内容，和Github项目同步 场景三: 首次提交本地项目到远端 # git init git add README.md # 添加管理文件 git commit -m \u0026quot;first commit\u0026quot; git branch -M main git remote add origin git@github.com:enjoy61/even.git git push -u origin main 子模块管理 # 添加子模块 # git submodule add git@github.com:enjoy61/hugo-theme-even.git themes/even 从远端拉取项目时亦拉取子模块项目 # git clone --recursive git@github.com:enjoy61/even.git 设置项目同步链接 # SSH git remote set-url cute git@github.com:enjoy61/even.git HTTPS push时需要验证，Github不再支持用户名和密码 git remote set-url cute https://github.com/enjoy61/even.git 文件托管 # 添加 # git add file # 指定文件 git add -A # 所有文件 删除 # git rm file 查看托管文件状态 # git diff 查看项目内文件状态 # git status 提交 # 提交当前改动 # git commit -m \u0026quot;first commit\u0026quot; 推送到远端 # git push 查看提交记录 # git log 删除历史提交 # # 查看提交记录 git log # 最新提交 F E D C B，要删除F和E，记录D # 设置回溯目标 git rebase -i D # 将F E的pick改为drop # 检查设置是否生效 git log # 查看当前提交 D C B # 同步到远端 git push cute master --force # 上游cute 分支master 存在多个文件添加/删除/修改，在上次提交的基础上再次提交 # 不建议如此操作，提交前建议检阅改动 项目文件夹一式两份，A和A.BAK, 项目新版本B 删除文件夹A内所有代码 不会删除.git，提交和同步记录均保留 rm -rf A/* 将B内的所有文件拷贝到A 不会拷贝.git cp -r B A 打开文件夹A, 再次提交 git add -A git commit -m \u0026quot;Comments\u0026quot; git push 提交规范 # \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; \u0026lt;body\u0026gt; \u0026lt;footer\u0026gt; 标题行 # 必填 类型 # type 标识 feat feature 新功能 fix 修复bug docs 文档 style 格式，如.clang-format refactor 重构 test 测试用例 build 项目构建和依赖项 revert 回退 ci 持续集成 perf 性能优化 merge 代码合并 sync 同步主线或分支的bug chore 其他类型 release 新版本发布 workflow 工作流 受到提交影响的范围 # scope 概述 # subject 动词开头 如果用英文，使用第一人称现在时，首字母小写 结尾不加句号 正文 # body 具体修改内容, 可多行 页脚注释 # footer 备注 分支 # 当前分支和分支列表 # git branch -a 切换分支 # git checkout main 创建分支 # git branch master 本地创建新分支后, 同步到远端 # git push --set-upstream origin master 创建并切换 # git checkout -b iss53 删除分支 # 本地 git branch -d iss51 上游 git push origin -d iss51 重命名分支 # 未推送到远端, 重命名即可 # git branch -m oldName newName 已推送过远端 # 重命名本地分支 git branch -m oldName newName 删除远端分支 git push --delete origin oldName 将本地分支推送到远端 git push origin newName 将本地分支和远端分支关联 git branch --set-upstream-to origin/newName 分支合并 # 合并过程中可能会产生冲突 git-scm 在iss53分支上开发新功能 git checkout master # 主分支 git checkout -b iss53 vim index.html git commit -a -m 'added a new footer [issue 53]' 在hotfix分支上解决问题 git checkout master # 主分支 git checkout -b hotfix vim index.html git commit -a -m 'fixed the broken email address' 在主分支上合并解决方案，删除hotfix分支 git checkout master git merge hotfix git branch -d hotfix 继续在分支iss53上开发新功能 git checkout iss53 vim index.html git commit -a -m 'finished the new footer [issue 53]' 合并新功能到主分支，删除iss53分支 git checkout master git merge iss53 git branch -d iss53 "}),e.add({id:7,href:"/docs/%E5%88%86%E4%BA%AB/hugo/%E4%BD%BF%E7%94%A8hugo+github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/",title:"使用Hugo+Github搭建静态博客",description:"说明 # - Github Pages 使用Github提供的免费服务部署静态博客 Hugo 本地构建静态网页 anubis 主题 安装Hugo # Github 官网 方法一: 使用go安装 # Windows 安装go 官网下载 环境变量 # go export PATH=/usr/local/go/bin:$PATH export GOROOT=/usr/local/go export GOPATH=/Users/USERNAME/go export GOBIN=/Users/USERNAME/go/bin # go安装的软件 export PATH=$GOBIN:$PATH 安装hugo 如若遇上网络不佳, 配置代理 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off 安装并验证 go install github.com/gohugoio/hugo@latest hugo env -v 部分主题需用hugo_extended提供的支持 方法二: 使用homebrew安装 # macOS brew install hugo 创建站点项目 # 新建站点 hugo new site /site/path 站点项目结构 文件 说明 config.",content:"说明 # - Github Pages 使用Github提供的免费服务部署静态博客 Hugo 本地构建静态网页 anubis 主题 安装Hugo # Github 官网 方法一: 使用go安装 # Windows 安装go 官网下载 环境变量 # go export PATH=/usr/local/go/bin:$PATH export GOROOT=/usr/local/go export GOPATH=/Users/USERNAME/go export GOBIN=/Users/USERNAME/go/bin # go安装的软件 export PATH=$GOBIN:$PATH 安装hugo 如若遇上网络不佳, 配置代理 go env -w GOPROXY=https://goproxy.cn,direct go env -w GOSUMDB=off 安装并验证 go install github.com/gohugoio/hugo@latest hugo env -v 部分主题需用hugo_extended提供的支持 方法二: 使用homebrew安装 # macOS brew install hugo 创建站点项目 # 新建站点 hugo new site /site/path 站点项目结构 文件 说明 config.toml 配置文件；yaml格式也可以 content 存放blog；支持md和org theme 存放主题 public 生成的静态页面；同步到Github项目 archetypes 文章模版 新建博客 所在目录为 ./content/post hugo new post/first-blog.org 使用主题anubis # anubis on hugo anubis on github 将主题作为项目子模块 git init git submodule add https://github.com/mitrichius/hugo-theme-anubis.git themes/anubis 使用anubis提供的模板 ./themes/anubis/exampleSite/ cp themes/anubis/exampleSite/config.toml . cp themes/anubis/exampleSite/content/. content 主题说明 提供标签(tags)和分类(categories)功能, 提供文章列表(archives) 文章存放到content/post目录下 文章模板 yaml \u0026mdash; author: \u0026ldquo;author\u0026rdquo; title: \u0026ldquo;article title\u0026rdquo; date: \u0026ldquo;2023-03-17\u0026rdquo; description: \u0026ldquo;article description\u0026rdquo; tags: [ \u0026ldquo;tag-1\u0026rdquo;, \u0026ldquo;tag-2\u0026rdquo;, ] categories: [ \u0026ldquo;category\u0026rdquo;, ] \u0026mdash; 简单介绍 \u0026lt;!\u0026ndash;more\u0026ndash;\u0026gt; 正文 构建静态网页 # 选项 说明 构建或测试 \u0026ndash;theme=anubis 设置主题 -t anubis both \u0026ndash;watch 修改文件后自动刷新浏览器 -w server \u0026ndash;buildDrafts 包括标记为draft的笔记 -D both \u0026ndash;buildFuture 包括新发布笔记；检查date选项 -F both \u0026ndash;baseUrl=\u0026quot;http://enjoy61.github.io/\u0026quot; 未配置编译，GithubPage部署会丢失样式 both \u0026ndash;cleanDestinationDir 将public文件夹中不再使用的文件删除 hugo 本地测试 # 查询server选项 参考 hugo help server 访问 http://localhost:1313/ hugo server --theme=anubis --watch # hugo server 构建静态页面 # 生成文件路径 ./public/ hugo --theme=anubis --baseUrl=\u0026quot;https://enjoy61.github.io/\u0026quot; # hugo 在Github创建项目 # 创建仓库 仓库名为enjoy61.github.io 使用Github Pages提供的免费服务需公开项目 测试服务: 为github设置主题 添加_config.yaml文件 remote_theme: pages-themes/midnight@v0.2.0 将public文件夹提交到仓库 "}),e.add({id:8,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%88%9D%E5%A7%8B%E5%8C%96shootthemup%E9%A1%B9%E7%9B%AE/",title:"初始化ShootThemUp项目",description:"说明 # 虚幻编辑器 将 ShooterGame 作为内容包，基于此开发 ShootThemUp 。好比室内设计师提供游戏资料，我们在此之上开发游戏。 创建ShootThemUp项目 # Blank Blueprint 配置ShootThemUp # 添加版权信息 # 项目设置 \u0026gt; Project \u0026gt; Description \u0026gt; Legal \u0026gt; Copyright Notice Shoot Them Up Game, All Rights Reserved. 关卡设置 # 添加关卡文件夹 Content/Levels 创建关卡 新建关卡 选择 Basic 保存到Content/Levels/，命名为DefaultMap 设置 EditorStartupMap 和 GameDefaultMap 使用 DefaultMap 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 从ShooterGame导入资产 # ShooterGame导出 # 打开ShooterGame项目 \u0026gt; 在内容浏览器选中Content/Animations/TTP_Animations，右键 \u0026gt; Migrate 取消Sounds勾选 默认勾选的文件夹里的内容都与 TTP_Animations 相关 保存到 ShootThemUp/Content 目录下 不能直接迁移到 5.",content:"说明 # 虚幻编辑器 将 ShooterGame 作为内容包，基于此开发 ShootThemUp 。好比室内设计师提供游戏资料，我们在此之上开发游戏。 创建ShootThemUp项目 # Blank Blueprint 配置ShootThemUp # 添加版权信息 # 项目设置 \u0026gt; Project \u0026gt; Description \u0026gt; Legal \u0026gt; Copyright Notice Shoot Them Up Game, All Rights Reserved. 关卡设置 # 添加关卡文件夹 Content/Levels 创建关卡 新建关卡 选择 Basic 保存到Content/Levels/，命名为DefaultMap 设置 EditorStartupMap 和 GameDefaultMap 使用 DefaultMap 项目设置 \u0026gt; Project \u0026gt; Maps \u0026amp; Modes 从ShooterGame导入资产 # ShooterGame导出 # 打开ShooterGame项目 \u0026gt; 在内容浏览器选中Content/Animations/TTP_Animations，右键 \u0026gt; Migrate 取消Sounds勾选 默认勾选的文件夹里的内容都与 TTP_Animations 相关 保存到 ShootThemUp/Content 目录下 不能直接迁移到 5.1.1/ShootThemUp/Content/ExternalContent ，虚幻引擎会检查目录，要求这些资产的上级目录是 Content ，即使根目录是 Content 也无法通过检查 ShootThemUp导入 # 添加外部资产文件夹和本章资产文件夹 Content/ExternalContent Content/ExternalContent/Animation 通过虚幻编辑器，将 Content 目录下的 Animations Characters Environment 移动到 ExternalContent/Animation 目录下 不能在外部直接将三个文件夹移动到目的文件夹中，会导致资产之间的相互引用路径出错 为 ExternalContent 设置文件夹颜色 选中Content/ExternalContent，右键 \u0026gt; Set Color 为 ExternalContent/Animation 设置文件夹颜色 效果图 基于蓝图创建C++项目 # 添加C++类即可 创建蓝图项目的时间开销明显小于创建C++项目的时间开销 创建GameModeBase类 # Tools \u0026gt; New C++ Class.. STUGameModeBase 不设置类类型 Content同级目录出现C++ Classes文件夹 设置关卡使用STUGameModeBase # 查看项目源码中的版权信息 # 不使用预编译头文件 # ShootThemUp: ShootThemUp.Build.cs // PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PCHUsage = PCHUsageMode.NoPCHs; 脚本 # 编译项目 # Build.sh #!/bin/bash Project=\u0026quot;Projects/5.1.1/ShootThemUp/ShootThemUp.uproject\u0026quot; BuildScript=\u0026quot;EpicGames/UE_5.1/Engine/Build/BatchFiles/Mac/Build.sh\u0026quot; Target=\u0026quot;ShootThemUpEditor\u0026quot; $BuildScript $Target Mac Development $Project -waitmutex -NoHotReload 打开虚幻编辑器 # Editor.sh #!/bin/bash Project=\u0026quot;Projects/5.1.1/ShootThemUp/ShootThemUp.uproject\u0026quot; UnrealEditor=\u0026quot;EpicGames/UE_5.1/Engine/Binaries/Mac/UnrealEditor.app\u0026quot; open -a $UnrealEditor $Project 生成项目文件 # ProjectFiles.sh #!/bin/bash Project=\u0026quot;Projects/5.1.1/ShootThemUp/ShootThemUp.uproject\u0026quot; GenerateProjectFilesScript=\u0026quot;EpicGames/UE_5.1/Engine/Build/BatchFiles/Mac/GenerateProjectFiles.sh\u0026quot; EngineCCDst=\u0026quot;EpicGames/UE_5.1/compile_commands.json\u0026quot; EngineCCSrc=\u0026quot;EpicGames/UE_5.1/.vscode/compileCommands_Default.json\u0026quot; ProjectCCDst=\u0026quot;Projects/5.1.1/ShootThemUp/compile_commands.json\u0026quot; ProjectCCSrc=\u0026quot;Projects/5.1.1/ShootThemUp/.vscode/compileCommands_ShootThemUp.json\u0026quot; GenerateXCode() { $GenerateProjectFilesScript -projectfiles -project=$Project -game -rocket -progress -XCodeProjectFiles } GenerateVSCode() { $GenerateProjectFilesScript -projectfiles -project=$Project -game -rocket -progress -VSCode cp $EngineCCSrc $EngineCCDst cp $ProjectCCSrc $ProjectCCDst } # GenerateXCode GenerateVSCode "}),e.add({id:9,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%AF%B9%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E9%80%A0%E6%88%90%E4%BC%A4%E5%AE%B3/",title:"对游戏角色造成伤害",description:"概览 # C++ 对游戏角色造成伤害 # 虚幻引擎提供一组函数，用来对Actor造成伤害 若有注册伤害处理服务, Actor受到伤害时触发处理函数 本节在Tick函数中持续对游戏角色造成伤害 伤害处理服务 # 我们在Actor提供的数据成员处注册伤害处理函数, 在处理函数中减少游戏角色生命值 持续对游戏角色造成伤害 # C++ 伤害来源是自己 ShootThemUp: Player/STUBaseCharacter.cpp // Tick TakeDamage(0.1f, FDamageEvent{}, GetController(), this); 伤害处理服务 # AActor定义了委托类型FTakeAnyDamageSignature，并有该类型数据成员AActor::OnTakeAnyDamage 我们通过数据成员注册伤害处理服务 处理函数签名 void handler(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 该委托类型支持蓝图 触发伤害处理函数时，会传入UDamageType 注册伤害机制的委托服务 # C++ 搭建框架 # 添加空函数 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) {} 注册伤害处理函数 ShootThemUp: Components/STUHealthComponent.",content:"概览 # C++ 对游戏角色造成伤害 # 虚幻引擎提供一组函数，用来对Actor造成伤害 若有注册伤害处理服务, Actor受到伤害时触发处理函数 本节在Tick函数中持续对游戏角色造成伤害 伤害处理服务 # 我们在Actor提供的数据成员处注册伤害处理函数, 在处理函数中减少游戏角色生命值 持续对游戏角色造成伤害 # C++ 伤害来源是自己 ShootThemUp: Player/STUBaseCharacter.cpp // Tick TakeDamage(0.1f, FDamageEvent{}, GetController(), this); 伤害处理服务 # AActor定义了委托类型FTakeAnyDamageSignature，并有该类型数据成员AActor::OnTakeAnyDamage 我们通过数据成员注册伤害处理服务 处理函数签名 void handler(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 该委托类型支持蓝图 触发伤害处理函数时，会传入UDamageType 注册伤害机制的委托服务 # C++ 搭建框架 # 添加空函数 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser) {} 注册伤害处理函数 ShootThemUp: Components/STUHealthComponent.cpp #include \u0026quot;GameFramework/Actor.h\u0026quot; // BeginPlay AActor *TheOwner = GetOwner(); if (TheOwner) { TheOwner-\u0026gt;OnTakeAnyDamage.AddDynamic(this, \u0026amp;USTUHealthComponent::OnTakeAnyDamage); } 添加函数声明 private ShootThemUp: Components/STUHealthComponent.h UFUNCTION() void OnTakeAnyDamage(AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser); 实现处理函数 # ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage Health -= Damage; 差不多一秒10帧，即1s调用十次处理函数；Health减为0之后，继续减少 "}),e.add({id:10,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/",title:"代码规范",description:"说明 # .clang-format .gitignore 虚幻引擎编码规范 - 大括号 放在新行 缩进 使用空格 缩进、制表符和空格 # 缩进 # indent 编写代码时，按下Tab键，会按制表符宽度留出空位，用以控制格式 使用制表符 Tab 和空格填充缩进 制表符的宽度可设置，不同平台制表符的宽度不一，视觉上，查看代码会有不习惯的感觉；可在本地设置使用空格，即用空格替换制表符 缩进使用空格 # 示例: 缩进使用空格, 制表符宽度 TabWidth 无效；缩进宽度 IndentWidth 生效, 一次缩进对应7个空格 IndentWidth: '7' UseTab: 'Never' TabWidth: '9' 缩进使用制表符和空格 # 若缩进宽度小于制表符宽度, 使用空格填充缩进; 若缩进宽度大于等于制表符宽度, 使用制表符和空格填充缩进 示例: 一次缩进对应7个空格，不会被替换为制表符；两个缩进对应14个空格，会被替换为1个制表符加5个空格 IndentWidth: '7' TabWidth: '9' UseTab: 'Always' 格式化代码规则 # .clang-format 官方文档 YAML标记文件 作为项目的一部分，描述管理代码文件的统一格式 每行遵循格式 key: value 设置受约束的开发语言 # Language: Cpp 如果项目中只一种开发语言，或者所有开发语言使用相同规范，可忽略该配置 通用样式 # Google: 一个制表符对应2个空格，大括号在行尾 BasedOnStyle: Google Microsoft: 一个制表符对应4个空格，大括号在新行 BasedOnStyle: Microsoft 制表符宽度 # 若缩进使用制表符，每6个空格替换一个制表符；当缩进宽度和制表符宽度不一致时，效果很糟糕 TabWidth: '6' 缩进宽度 # IndentWidth: '4' 缩进样式 # 空格 UseTab: Never 制表符: 源文件中既有空格又有制表符 UseTab: Always 设置大括号位置 # 行尾 BreakBeforeBraces: Attach 新行 BreakBeforeBraces: Allman 显示时, 每行最大字符个数 # 为0时，按输入的实际情况显示 ColumnLimit: '140' 向前缩进 # 控制访问说明符的缩进 AccessModifierOffset: '-4' 头文件排序 # SortIncludes: false 括号换行时，参数的对齐方式 # AlignAfterOpenBracket: Align 不对齐 DontAlign someLongFunction(argument1, argument2); 对齐 Align someLongFunction(argument1, argument2); 当语句较短时，是否允许写在单行 # AllowShortBlocksOnASingleLine: false 条件语句的执行部分为空，或只有一行语句时，可认为语句较短；为false则如下输出 while (true) { } while (true) { continue; } 当函数语句较短时，是否允许写在单行 # - Inline 若函数体为空，允许；若函数在类内定义，允许 InlineOnly 只允许一种情况：函数在类内定义 Empty 只允许一种情况：函数体为空 AllowShortFunctionsOnASingleLine: Inline 指针和引用的对齐方式 # PointerAlignment: Right Right int *a; Left int* a; Git仓库同步 # .",content:"说明 # .clang-format .gitignore 虚幻引擎编码规范 - 大括号 放在新行 缩进 使用空格 缩进、制表符和空格 # 缩进 # indent 编写代码时，按下Tab键，会按制表符宽度留出空位，用以控制格式 使用制表符 Tab 和空格填充缩进 制表符的宽度可设置，不同平台制表符的宽度不一，视觉上，查看代码会有不习惯的感觉；可在本地设置使用空格，即用空格替换制表符 缩进使用空格 # 示例: 缩进使用空格, 制表符宽度 TabWidth 无效；缩进宽度 IndentWidth 生效, 一次缩进对应7个空格 IndentWidth: '7' UseTab: 'Never' TabWidth: '9' 缩进使用制表符和空格 # 若缩进宽度小于制表符宽度, 使用空格填充缩进; 若缩进宽度大于等于制表符宽度, 使用制表符和空格填充缩进 示例: 一次缩进对应7个空格，不会被替换为制表符；两个缩进对应14个空格，会被替换为1个制表符加5个空格 IndentWidth: '7' TabWidth: '9' UseTab: 'Always' 格式化代码规则 # .clang-format 官方文档 YAML标记文件 作为项目的一部分，描述管理代码文件的统一格式 每行遵循格式 key: value 设置受约束的开发语言 # Language: Cpp 如果项目中只一种开发语言，或者所有开发语言使用相同规范，可忽略该配置 通用样式 # Google: 一个制表符对应2个空格，大括号在行尾 BasedOnStyle: Google Microsoft: 一个制表符对应4个空格，大括号在新行 BasedOnStyle: Microsoft 制表符宽度 # 若缩进使用制表符，每6个空格替换一个制表符；当缩进宽度和制表符宽度不一致时，效果很糟糕 TabWidth: '6' 缩进宽度 # IndentWidth: '4' 缩进样式 # 空格 UseTab: Never 制表符: 源文件中既有空格又有制表符 UseTab: Always 设置大括号位置 # 行尾 BreakBeforeBraces: Attach 新行 BreakBeforeBraces: Allman 显示时, 每行最大字符个数 # 为0时，按输入的实际情况显示 ColumnLimit: '140' 向前缩进 # 控制访问说明符的缩进 AccessModifierOffset: '-4' 头文件排序 # SortIncludes: false 括号换行时，参数的对齐方式 # AlignAfterOpenBracket: Align 不对齐 DontAlign someLongFunction(argument1, argument2); 对齐 Align someLongFunction(argument1, argument2); 当语句较短时，是否允许写在单行 # AllowShortBlocksOnASingleLine: false 条件语句的执行部分为空，或只有一行语句时，可认为语句较短；为false则如下输出 while (true) { } while (true) { continue; } 当函数语句较短时，是否允许写在单行 # - Inline 若函数体为空，允许；若函数在类内定义，允许 InlineOnly 只允许一种情况：函数在类内定义 Empty 只允许一种情况：函数体为空 AllowShortFunctionsOnASingleLine: Inline 指针和引用的对齐方式 # PointerAlignment: Right Right int *a; Left int* a; Git仓库同步 # .gitignore 虚幻引擎提供模板 告诉Git，同步时忽略的文件和文件夹 命名约定 # 虚幻编辑器 虚幻引擎命名规范参考 虚幻编辑器 材质 Material M_ 材质实例 Material Instance MI_ 基于C++的蓝图类 Blueprint BP_ 动画蓝图 Animation Blueprint ABP_ 混合空间(1D) Blend Space BS_ 动画剪辑 Animation Montage AM_ "}),e.add({id:11,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E6%8B%9F%E6%A6%B4%E5%BC%B9%E7%88%86%E7%82%B8/",title:"模拟榴弹爆炸",description:"建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 创建伤害源 # 创建Dev/STUDevDamageActor # 虚幻编辑器 Actor 公有类 设置头文件搜索路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot; }); 添加可视化组件，使得伤害源可变换 # 添加SceneComponent protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent; 初始化组件 ShootThemUp: Dev/STUDevDamageActor.cpp // 构造函数 SceneComponent = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(\u0026quot;SceneComponent\u0026quot;); SetRootComponent(SceneComponent); 绘制球体，使得爆炸范围可视化 # 添加球体参数 protected ShootThemUp: Dev/STUDevDamageActor.h - 颜色 SphereColor 半径 Radius UPROPERTY(EditAnywhere) float Radius = 300.0f; UPROPERTY(EditAnywhere) FColor SphereColor = FColor::Red; 每帧绘制球体 ShootThemUp: Dev/STUDevDamageActor.cpp #include \u0026quot;DrawDebugHelpers.h\u0026quot; // Tick DrawDebugSphere(GetWorld(), GetActorLocation(), Radius, 24, SphereColor); 使用了GetWorld，其声明和UWorld的定义在一处，而DrawDebugSphere的第一个参数类型为UWorld，不用包含Engine/World.",content:"建模 # 添加伤害源，派生自Actor，模拟榴弹爆炸瞬间 绘制球体，使得伤害范围可视化 对处在爆炸半径内的游戏角色持续造成伤害，伤害数值与游戏角色所在位置到球心的距离有关 创建伤害源 # 创建Dev/STUDevDamageActor # 虚幻编辑器 Actor 公有类 设置头文件搜索路径 # C++ ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot;, \u0026quot;ShootThemUp/Public/Dev\u0026quot; }); 添加可视化组件，使得伤害源可变换 # 添加SceneComponent protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USceneComponent *SceneComponent; 初始化组件 ShootThemUp: Dev/STUDevDamageActor.cpp // 构造函数 SceneComponent = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(\u0026quot;SceneComponent\u0026quot;); SetRootComponent(SceneComponent); 绘制球体，使得爆炸范围可视化 # 添加球体参数 protected ShootThemUp: Dev/STUDevDamageActor.h - 颜色 SphereColor 半径 Radius UPROPERTY(EditAnywhere) float Radius = 300.0f; UPROPERTY(EditAnywhere) FColor SphereColor = FColor::Red; 每帧绘制球体 ShootThemUp: Dev/STUDevDamageActor.cpp #include \u0026quot;DrawDebugHelpers.h\u0026quot; // Tick DrawDebugSphere(GetWorld(), GetActorLocation(), Radius, 24, SphereColor); 使用了GetWorld，其声明和UWorld的定义在一处，而DrawDebugSphere的第一个参数类型为UWorld，不用包含Engine/World.h 对伤害范围内Actor造成半径伤害 # 添加半径伤害参数 protected ShootThemUp: Dev/STUDevDamageActor.h - Damage 伤害数值特征 DoFullDamage 半径伤害计算选项：为true，受到的伤害与到球心的距离有关；为false，使用简化模型，受到伤害值恒定 UPROPERTY(EditAnywhere) float Damage = 10.0f; UPROPERTY(EditAnywhere) bool DoFullDamage = false; 对伤害范围内Actor造成半径伤害 ShootThemUp: Dev/STUDevDamageActor.cpp #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;Kismet/GameplayStatics.h\u0026quot; // Tick UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); ApplyRadialDamage 的第一个参数类型为 UObject ，此时传入 UWorld ，需包含 UWorld 头文件 验证半径伤害数值 # C++ 定义日志宏，输出伤害值 ShootThemUp: Components/STUHealthComponent.cpp DEFINE_LOG_CATEGORY_STATIC(LogHealthComponent, All, All); // OnTakeAnyDamage UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;Damage: %.0f\u0026quot;), Damage); 屏蔽STUBaseCharacter\u0026gt;Tick中调用TakeDamage # ShootThemUp: Player/STUBaseCharacter.cpp 在关卡中添加伤害源 # 虚幻编辑器 调整BP_STUBaseCharacter\u0026gt;CameraComponent位置 # 向上，向后 在关卡中添加STDevDamageActor # 第一个伤害源: 使用默认设置，根据游戏角色到球心的距离计算伤害 第二个伤害源: 设置半径和颜色，处在伤害范围内受到伤害数值恒定（开销小） 调整 STDevDamageActor 的位置，效果图 要求伤害源球心无阻隔 验证 DoFullDamage # 处于蓝色球内，伤害值一致 处于红色球内，离球心越近，伤害值越大 球心在空中，跳跃也会缩短到球心的距离 伤害球内的所有Actor都会受到伤害 # "}),e.add({id:12,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%B8%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%9E%8B/",title:"为游戏角色绑定模型",description:"概览 # - 玩家控制的游戏角色 Character 游戏角色控制器 PlayerController 关卡设置 GameModeBase: DefaultPawnClass, PlayerControllerClass 第三视角 CameraComponent 创建Character类和PlayController类 # 虚幻编辑器 创建 Player/STUBaseCharacter ACharacter 公有类 创建 Player/STUPlayerController APlayerController 公有类 设置头文件搜索路径 # 源文件路径已包含上级文件夹 ShootThemUp: Player/STUBaseCharacter.cpp 设置头文件搜索路径之后，可以不指明上级文件夹 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot; }); 设置STUGameModeBase使用STUBaseCharacter和STUPlayController # C++ - DefaultPawnClass 游戏角色类型 PlayerControllerClass 游戏角色控制器类型 添加默认构造函数声明 ShootThemUp: STUGameModeBase.h 设置默认游戏角色类型和游戏角色控制器类型 ShootThemUp: STUGameModeBase.cpp #include \u0026quot;Player/STUBaseCharacter.h\u0026quot; #include \u0026quot;Player/STUPlayerController.h\u0026quot; // 以下亦正确 // #include \u0026quot;STUBaseCharacter.h\u0026quot; // #include \u0026quot;STUPlayerController.h\u0026quot; ASTUGameModeBase::ASTUGameModeBase() { DefaultPawnClass = ASTUBaseCharacter::StaticClass(); PlayerControllerClass = ASTUPlayerController::StaticClass(); } 为游戏角色添加第三视角 # C++ 为STUBaseCharacter添加UCameraComponent类型成员 添加CameraComponent类型成员 ShootThemUp: Player/STUBaseCharacter.",content:"概览 # - 玩家控制的游戏角色 Character 游戏角色控制器 PlayerController 关卡设置 GameModeBase: DefaultPawnClass, PlayerControllerClass 第三视角 CameraComponent 创建Character类和PlayController类 # 虚幻编辑器 创建 Player/STUBaseCharacter ACharacter 公有类 创建 Player/STUPlayerController APlayerController 公有类 设置头文件搜索路径 # 源文件路径已包含上级文件夹 ShootThemUp: Player/STUBaseCharacter.cpp 设置头文件搜索路径之后，可以不指明上级文件夹 ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot; }); 设置STUGameModeBase使用STUBaseCharacter和STUPlayController # C++ - DefaultPawnClass 游戏角色类型 PlayerControllerClass 游戏角色控制器类型 添加默认构造函数声明 ShootThemUp: STUGameModeBase.h 设置默认游戏角色类型和游戏角色控制器类型 ShootThemUp: STUGameModeBase.cpp #include \u0026quot;Player/STUBaseCharacter.h\u0026quot; #include \u0026quot;Player/STUPlayerController.h\u0026quot; // 以下亦正确 // #include \u0026quot;STUBaseCharacter.h\u0026quot; // #include \u0026quot;STUPlayerController.h\u0026quot; ASTUGameModeBase::ASTUGameModeBase() { DefaultPawnClass = ASTUBaseCharacter::StaticClass(); PlayerControllerClass = ASTUPlayerController::StaticClass(); } 为游戏角色添加第三视角 # C++ 为STUBaseCharacter添加UCameraComponent类型成员 添加CameraComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h // 前向声明 class UCameraComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UCameraComponent *CameraComponent; 初始化组件 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Camera/CameraComponent.h\u0026quot; // 默认构造函数 CameraComponent = CreateDefaultSubobject\u0026lt;UCameraComponent\u0026gt;(\u0026quot;CameraComponent\u0026quot;); CameraComponent-\u0026gt;SetupAttachment(GetRootComponent()); 编译ShootThemUp 设置关卡使用蓝图类 # 虚幻编辑器 查看STUGameModeBase使用的类型 # 创建基于STUGameModeBase的蓝图类 # 选中C++ Classes/ShootThemUp/STUGameModeBase右键, 选择Create blueprint class based on STUGameModeBase 保存到Content/, 命名为BP_STUBaseGameBase 创建基于STUBaseCharacter和STUPlayerController的蓝图类 # 创建 Content/Player 文件夹 创建 BP_STUBaseCharacter 和 BP_STUPlayerController , 保存到 Content/Player/ 设置关卡使用BP_STUGameModeBase, 并设置BP_STUGameModeBase使用BP_STUBaseCharacter和BP_STUPlayerController # 为游戏角色绑定模型 # 虚幻编辑器 BP_STUBaseCharacter 查看组件信息 # 说明 Capsule Component 根组件，实现碰撞检测 Arrow Component 角色的前进方向 Camera Component 第三视角 Mesh 骨骼网格体(Skeletal Mesh) Character Movement 纯逻辑组件，负责游戏角色运动 设置蓝图类编译成功自动保存 # 为Mesh组件绑定骨骼网格体 # Mesh 绑定 HeroTPP 材质自动应用 HeroTPP 移动模型到合适位置，旋转模型与前进方向一致 实现第三视角 分离 Camera Component 和 Mesh 组件 效果图 "}),e.add({id:13,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E4%BC%A4%E5%AE%B3%E7%B1%BB%E5%9E%8B/",title:"使用伤害类型",description:"创建伤害类型 # 虚幻编辑器 创建Dev/STUFireDamageType # UDamageType 公有类 创建Dev/STUIceDamageType # UDamageType 公有类 为伤害来源添加伤害类型属性 # C++ 添加伤害类型参数 protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UDamageType\u0026gt; DamageType; 造成伤害时，传入伤害类型 ShootThemUp: Dev/STUDevDamageActor.cpp // Tick // UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); 在伤害处理函数中输出伤害来源信息 # C++ ShootThemUp: Components/STUHealthComponent.cpp #include \u0026quot;Dev/STUFireDamageType.h\u0026quot; #include \u0026quot;Dev/STUIceDamageType.h\u0026quot; // OnTakeAnyDamage if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTUFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTUIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !",content:"创建伤害类型 # 虚幻编辑器 创建Dev/STUFireDamageType # UDamageType 公有类 创建Dev/STUIceDamageType # UDamageType 公有类 为伤害来源添加伤害类型属性 # C++ 添加伤害类型参数 protected ShootThemUp: Dev/STUDevDamageActor.h UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UDamageType\u0026gt; DamageType; 造成伤害时，传入伤害类型 ShootThemUp: Dev/STUDevDamageActor.cpp // Tick // UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, nullptr, {}, this, nullptr, DoFullDamage); UGameplayStatics::ApplyRadialDamage(GetWorld(), Damage, GetActorLocation(), Radius, DamageType, {}, this, nullptr, DoFullDamage); 在伤害处理函数中输出伤害来源信息 # C++ ShootThemUp: Components/STUHealthComponent.cpp #include \u0026quot;Dev/STUFireDamageType.h\u0026quot; #include \u0026quot;Dev/STUIceDamageType.h\u0026quot; // OnTakeAnyDamage if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTUFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTUIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !!!\u0026quot;)); } } 查看 # 虚幻编辑器 为伤害来源设置DamageType属性 # DamageSphere-Red 选择 STUFireDamageType DamageSphere-Blue 选择 STUIceDamageType 查看日志 # 游戏角色进入到 DamageSphere-Red 游戏角色进入到 DamageSphere-Blue "}),e.add({id:14,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E5%89%8D%E5%90%8E%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8/",title:"实现游戏角色前后左右移动",description:"概览 # 举例 轴映射 连续 前后左右移动 动作映射 离散 跳跃，装弹，更换武器 绑定移动键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 Scale MoveRight Left/A -1 Right/D 1 MoveForward Up/W 1 Down/S -1 实现前后左右移动逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 方向 输入处理 MoveForward MoveForward GetActorForwardVector AddMovementInput MoveRight MoveRight GetActorRightVector AddMovementInput 实现回调函数 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/InputComponent.h\u0026quot; void ASTUBaseCharacter::MoveForward(float Amount) { AddMovementInput(GetActorForwardVector(), Amount); } void ASTUBaseCharacter::MoveRight(float Amount) { AddMovementInput(GetActorRightVector(), Amount); } 绑定到函数描述 ShootThemUp: Player/STUBaseCharacter.",content:"概览 # 举例 轴映射 连续 前后左右移动 动作映射 离散 跳跃，装弹，更换武器 绑定移动键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 Scale MoveRight Left/A -1 Right/D 1 MoveForward Up/W 1 Down/S -1 实现前后左右移动逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 方向 输入处理 MoveForward MoveForward GetActorForwardVector AddMovementInput MoveRight MoveRight GetActorRightVector AddMovementInput 实现回调函数 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/InputComponent.h\u0026quot; void ASTUBaseCharacter::MoveForward(float Amount) { AddMovementInput(GetActorForwardVector(), Amount); } void ASTUBaseCharacter::MoveRight(float Amount) { AddMovementInput(GetActorRightVector(), Amount); } 绑定到函数描述 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;MoveForward\u0026quot;, this, \u0026amp;ASTUBaseCharacter::MoveForward); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;MoveRight\u0026quot;, this, \u0026amp;ASTUBaseCharacter::MoveRight); 添加函数声明 ShootThemUp: Player/STUBaseCharacter.h private 编译ShootThemUp "}),e.add({id:15,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%AD%BB%E4%BA%A1%E9%80%BB%E8%BE%91/",title:"添加游戏角色死亡逻辑",description:"说明 # 生命值修改时, 同步到HealthTextComponent组件 # 生命值为0，销毁游戏角色 # 死亡时, 播放死亡动画 # 动画剪辑 # Animation Montage 可以将多个动画组合播放。把希望连续播放的动画添加到时间线 timeline ，在代码或蓝图中播放动画剪辑 命名：以AM_打头 Slot # 若此时播放动画剪辑，输出输入动画和动画剪辑的拼接；若无动画剪辑在播放，输出输入动画 添加委托：当生命值更改时，同步到HealthTextComponent文本 # C++ 屏蔽当前HealthTextComponent文本的设置 # ShootThemUp: Player/STUBaseCharacter.cpp 屏蔽Tick函数中的文本更新 初始化HealthTextComponent文本 # ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); HealthComponent提供委托服务: 生命值修改通知 # - 多播 仅C++ 在HealthComponent定义委托类型FChangeHealthSignature # ShootThemUp: Components/STUHealthComponent.h DECLARE_MULTICAST_DELEGATE(FChangeHealthSignature); 添加数据成员OnChangeHealth，提供委托服务 # public ShootThemUp: Components/STUHealthComponent.h FChangeHealthSignature OnChangeHealth; 封装修改Health逻辑，调用时通知客户端 # 只能通过SetHealth接口修改生命值 函数定义 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::SetHealth(float NewHealth) { Health = NewHealth; OnChangeHealth.Broadcast(); } 函数声明 private ShootThemUp: Components/STUHealthComponent.",content:"说明 # 生命值修改时, 同步到HealthTextComponent组件 # 生命值为0，销毁游戏角色 # 死亡时, 播放死亡动画 # 动画剪辑 # Animation Montage 可以将多个动画组合播放。把希望连续播放的动画添加到时间线 timeline ，在代码或蓝图中播放动画剪辑 命名：以AM_打头 Slot # 若此时播放动画剪辑，输出输入动画和动画剪辑的拼接；若无动画剪辑在播放，输出输入动画 添加委托：当生命值更改时，同步到HealthTextComponent文本 # C++ 屏蔽当前HealthTextComponent文本的设置 # ShootThemUp: Player/STUBaseCharacter.cpp 屏蔽Tick函数中的文本更新 初始化HealthTextComponent文本 # ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); HealthComponent提供委托服务: 生命值修改通知 # - 多播 仅C++ 在HealthComponent定义委托类型FChangeHealthSignature # ShootThemUp: Components/STUHealthComponent.h DECLARE_MULTICAST_DELEGATE(FChangeHealthSignature); 添加数据成员OnChangeHealth，提供委托服务 # public ShootThemUp: Components/STUHealthComponent.h FChangeHealthSignature OnChangeHealth; 封装修改Health逻辑，调用时通知客户端 # 只能通过SetHealth接口修改生命值 函数定义 ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::SetHealth(float NewHealth) { Health = NewHealth; OnChangeHealth.Broadcast(); } 函数声明 private ShootThemUp: Components/STUHealthComponent.h 修改OnTakeAnyDamage # ShootThemUp: Components/STUHealthComponent.cpp // Health -= Damage; SetHealth(Health - Damage); STUBaseCharacter注册委托服务: OnChangeHealth # - 仅C++ AddUObject 搭建框架: 注册生命值修改通知 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnChangeHealth() {} 注册委托服务 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthComponent-\u0026gt;OnChangeHealth.AddUObject(this, \u0026amp;ASTUBaseCharacter::OnChangeHealth); 函数声明 private ShootThemUp: Player/STUBaseCharacter.h 实现处理函数OnChangeHealth # 设置HealthTextComponent文本 ShootThemUp: Player/STUBaseCharacter.cpp // OnChangeHealth HealthTextComponent-\u0026gt;SetText(FText::FromString(FString::Printf(TEXT(\u0026quot;%.0f\u0026quot;), HealthComponent-\u0026gt;GetHealth()))); Character和其组件调用BeginPlay的先后顺序 # 先调用Component的BeginPlay，再调用Character的BeginPlay。 先由HealthComponent在BeginPlay初始化Health, 才轮到Character在BeginPlay中注册服务。 若我们没有在Character的BeginPlay中初始化HealthTextComponent文本，当Character在BeginPlay中注册服务完成，HealthTextComponent 文本显示为0。直到Health再次被更改，Character才会收到通知同步。 游戏角色死亡后，生命值不再减少 # C++ 提供接口，判断Character是否死亡 # public ShootThemUp: Components/STUHealthComponent.h UFUNCTION(BlueprintCallable) bool IsDead() const { return Health \u0026lt;= 0.0f; } Character死亡之后，生命值不再减少 # 若伤害的数量特征不大于0，或者当前生命值不大于0，无法继续对Character造成伤害 ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage if (Damage \u0026lt;= 0.0f || IsDead()) return; 限制Health范围 # ShootThemUp: Components/STUHealthComponent.cpp // Health = NewHealth; Health = FMath::Clamp(NewHealth, 0.0f, MaxHealth); 添加委托：游戏角色死亡，销毁Character # C++ 当生命值发生改变时修改HealthText文本，当生命值变为0时销毁Character，一码归一码 HealthComponent提供委托服务: 游戏角色死亡通知 # - 多播 仅C++ 在HealthComponent定义委托类型FDeathSignature # ShootThemUp: Components/STUHealthComponent.h DECLARE_MULTICAST_DELEGATE(FDeathSignature); 添加数据成员OnDeath，提供委托服务 # public ShootThemUp: Components/STUHealthComponent.h FDeathSignature OnDeath; Character死亡，通知客户端 # ShootThemUp: Components/STUHealthComponent.cpp // OnTakeAnyDamage if (IsDead()) { OnDeath.Broadcast(); } STUBaseCharacter注册委托服务: OnDeath # - 仅C++ AddUObject 搭建框架: 注册死亡通知 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnDeath() {} 注册委托服务 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay HealthComponent-\u0026gt;OnDeath.AddUObject(this, \u0026amp;ASTUBaseCharacter::OnDeath); 函数声明 private ShootThemUp: Player/STUBaseCharacter.h 实现处理函数OnDeath # 添加销毁延时 protected ShootThemUp: Player/STUBaseCharacter.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;0.0\u0026quot;, ClampMax = \u0026quot;10.0\u0026quot;)) float LifeSpanOnDeath = 5.0f; 检查CharacterMovement组件有效性 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay check(GetCharacterMovement()); 剥夺玩家对游戏角色的控制权，开启定时器销毁Character ShootThemUp: Player/STUBaseCharacter.cpp // OnDeath GetCharacterMovement()-\u0026gt;DisableMovement(); SetLifeSpan(LifeSpanOnDeath); 创建死亡动画剪辑 # 虚幻编辑器 之前的跳跃、跑步、转向动画，均对应状态机中的一个状态。如果游戏角色死亡拥有对应状态，每个状态都可能迁移到死亡状态，光是想想都觉得麻烦 使用动画剪辑 AnimMontage 资产，当游戏角色死亡时，播放死亡动画剪辑, 通过slot连接当前动画和死亡动画剪辑 创建AnimMontage资产 # - 死亡动画资产 ExternalContent/Animation/Animations/TTP_Animations/Death 选中死亡动画资产，右键 \u0026gt; Create \u0026gt; Create AnimMontage \u0026gt; 命名为AM_Death 移动到Content/Player/Animations路径下 在动画蓝图中添加Slot # ABP_BaseCharacter \u0026gt; AnimGraph 在Locomotion和OutputPose之间添加Slot # Slot和AM_Death的分组一致 # Slot - SlotName DefaultGroup.DefaultSlot AM_Death - Montage DefaultGroup.DefaultSlot 设置动画剪辑 # AM_Death 死亡动画结束后，不再播放其他动画 Asset Details \u0026gt; BlendOptions \u0026gt; EnableAutoBlendOut，取消勾选 游戏角色死亡时，播放动画剪辑 # C++ C++类型 动画剪辑 AnimMontage UAnimMontage 添加UAnimMontage类型数据成员 # protected ShootThemUp: Player/STUBaseCharacter.h UPROPERTY(EditDefaultsOnly) UAnimMontage *DeathAnimMontage; Character死亡时，播放动画剪辑 # ShootThemUp: Player/STUBaseCharacter.cpp // OnDeath PlayAnimMontage(DeathAnimMontage); 查看 # 虚幻编辑器 设置游戏角色死亡时播放的动画剪辑 BP_STUBaseCharacter 效果图 禁止移动Character之后，销毁Character之前，仍可以移动Camera；即，水平旋转视角时可以旋转Character "}),e.add({id:16,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%A7%86%E8%A7%92%E6%97%8B%E8%BD%AC/",title:"实现游戏角色视角旋转",description:"说明 # 视角旋转 垂直方向 抬头低头 Camera绕Y轴旋转 鼠标垂直方向位移决定旋转角度 水平方向 环顾左右 Camera绕Z轴旋转 鼠标水平方向位移决定旋转角度 绑定旋转键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 LookUp MouseY TurnAround MouseX 实现视角旋转逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 LookUp LookUp AddControllerPitchInput 绕Y轴旋转，增加Y轴旋转角度(Pitch) TurnAround TurnAround AddControllerYawInput 绕Z轴旋转，增加Z轴旋转角度(Yaw) 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::LookUp(float Amount) {} void ASTUBaseCharacter::TurnAround(float Amount) {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTUBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::TurnAround); 添加函数声明 ShootThemUp: Player/STUBaseCharacter.",content:"说明 # 视角旋转 垂直方向 抬头低头 Camera绕Y轴旋转 鼠标垂直方向位移决定旋转角度 水平方向 环顾左右 Camera绕Z轴旋转 鼠标水平方向位移决定旋转角度 绑定旋转键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 轴映射 函数描述 键位 LookUp MouseY TurnAround MouseX 实现视角旋转逻辑 # C++ - 回调函数签名 BindAxis void handler(float Amount) 函数描述 回调函数 LookUp LookUp AddControllerPitchInput 绕Y轴旋转，增加Y轴旋转角度(Pitch) TurnAround TurnAround AddControllerYawInput 绕Z轴旋转，增加Z轴旋转角度(Yaw) 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::LookUp(float Amount) {} void ASTUBaseCharacter::TurnAround(float Amount) {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTUBaseCharacter::LookUp); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::TurnAround); 添加函数声明 ShootThemUp: Player/STUBaseCharacter.h private 添加静态日志类型 # ShootThemUp: Player/STUBaseCharacter.cpp DEFINE_LOG_CATEGORY_STATIC(LogBaseCharacter, All, All); 实现回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::LookUp(float Amount) { AddControllerPitchInput(Amount); UE_LOG(LogBaseCharacter, Log, TEXT(\u0026quot;LookUp Amount: %f\u0026quot;), Amount); } void ASTUBaseCharacter::TurnAround(float Amount) { AddControllerYawInput(Amount); } 编译ShootThemUp并运行 # 视角可以在水平方向旋转, 身体跟随旋转 无法在垂直方向旋转 查看日志，鼠标向上移动时，Amount为正数 使视角可以在垂直方向旋转 # 虚幻编辑器 CameraComponent的UsePawnControlRotation选项 # 设置CamerComponent是否跟随Pawn旋转 勾选 BP_STUBaseCharacter \u0026gt; CameraComponent \u0026gt; UsePawnControlRotation 选中Camera Component \u0026gt; 细节面板 \u0026gt; CameraOptions \u0026gt; 勾选UsePawnControlRotation 编译并运行 向下移动鼠标，Camera向上旋转; 向上移动鼠标，Camera向下旋转 旋转中心点为CameraComponent PlayerController的InputPitchScale选项 # 游戏角色旋转的逻辑是通过旋转PlayerController完成的 游戏角色视角垂直方向旋转反向InputPitchScale有关，该参数默认为负数, 已退化 参考 InputPitchScale, InputYawScale, InputRollScale的绝对值对应旋转速度 引擎版本 5.1 之前，可以在 PlayerController蓝图类 的细节面板查看 InputPitchScale 打印InputPitchScale # 解决方法一: 将InputPitchScale设为正数 # 解决方法二: 将LookUp的Scale改为-1 # 善后 # 采用解决方法二 去除 BP_STUPlayerController 中的打印和InputPitchScale设置 去除 C++ LookUp 中的日志打印 游戏角色视角绕Z轴旋转时，使中心点为游戏角色 # 为STUBaseCharacter添加USpringArmComponent类型成员 # C++ 添加SpringArmComponent类型成员 ShootThemUp: Player/STUBaseCharacter.h // 前向声明 class USpringArmComponent; // protected UPROPERTY(VisibleAnywhere, BlueprintReadWrite) USpringArmComponent *SpringArmComponent; 初始化组件, 设置SpringArmComponent默认跟随Pawn旋转 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;GameFrameWork/SpringArmComponent.h\u0026quot; // 默认构造函数 SpringArmComponent = CreateDefaultSubobject\u0026lt;USpringArmComponent\u0026gt;(\u0026quot;SpringArmComponent\u0026quot;); SpringArmComponent-\u0026gt;SetupAttachment(GetRootComponent()); SpringArmComponent-\u0026gt;bUsePawnControlRotation = true; 修改CameraComponent的上级组件为SpringArmComponent ShootThemUp: Player/STUBaseCharacter.cpp // 默认构造函数 // CameraComponent-\u0026gt;SetupAttachment(GetRootComponent()); CameraComponent-\u0026gt;SetupAttachment(SpringArmComponent); 编译ShootThemUp 配置SpringArmComponent # 虚幻编辑器 BP_STUBaseCharacter 查看SpringArmComponent和CameraComponent # 关于bUsePawnControlRotation设置 # UCameraComponent 和 USpringArmComponent 均有该数据成员 在代码中设置 bUsePawnControlRotation ，设置的是类数据成员初始值。在蓝图编辑器中，对基于C++类的蓝图类数据成员恢复默认值，得到类数据成员初始值 为参数添加默认值，不会改变参数已有值 清除CameraComponent的相对变换，置UsePawnControlRotation为false # 设置SpringArmComponent和CameraComponent的相对变换 # 查看 SpringArmComponent 臂长参数 设置CameraComponent相对SpringArmComponent的偏移 CameraComponent和SpringArmComponent的bUsePawnControlRotation生效问题 # - 二者均为 true SpringArmComponent的生效，Camera以游戏角色为中心绕Y轴旋转 二者均为 false Camera不可绕Y轴旋转 仅 CameraComponent 的为true 以Camera为中心绕Y轴旋转 仅 SpringArmComponent 的为true Camera以游戏角色为中心绕Y轴旋转 为Character绑定动画 # 虚幻编辑器 BP_STUBaseCharacter 绑定动画 选中Mesh组件 \u0026gt; Details \u0026gt; Animation - Animation Mode Use Animation Asset Anim To Play Run_Fwd 可能存在动画下拉框无可选项的情况, 需要重新为动画绑定骨骼网格体 编译并运行 优化视角旋转逻辑 # C++ STUBaseCharacter LookUp, TurnAround, AddControllerPitchInput和AddControllerYawInput的函数签名一致 void LookUp(float Amount); void TurnAround(float Amount); void AddControllerPitchInput(float Val); void AddControllerYawInput(float Val) 屏蔽 LookUp 和 TurnAround ShootThemUp: Player/STUBaseCharacter.cpp ShootThemUp: Player/STUBaseCharacter.h 函数描述直接绑定 AddControllerPitchInput 和 AddControllerYawInput ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent // PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;LookUp\u0026quot;, this, \u0026amp;ASTUBaseCharacter::LookUp); // PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::TurnAround); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;Lookup\u0026quot;, this, \u0026amp;ASTUBaseCharacter::AddControllerPitchInput); PlayerInputComponent-\u0026gt;BindAxis(\u0026quot;TurnAround\u0026quot;, this, \u0026amp;ASTUBaseCharacter::AddControllerYawInput) 编译并运行 "}),e.add({id:17,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0%E8%A7%82%E5%AF%9F%E8%A7%86%E8%A7%92/",title:"添加观察视角",description:"说明 # 当游戏角色生命值为0，我们尝试剥夺玩家对游戏角色的控制，此时仍能旋转Camera; 左右旋转视角时, Character身体也会旋转 我们可以在游戏角色死亡时，切换玩家控制的Pawn：一方面，彻底剥夺玩家对游戏角色的控制，另一方面，允许玩家做合理的操作 观察视角 # 对应一个APawn派生类，ASpectatorPawn 关卡的默认类型里，观察者类使用ASpectatorPawn 玩家死亡后，使其操控SpectatorPawn，仍能继续观看游戏 场景中的SpectatorPawn # 漂浮的Camera，除了可以前后左右移动，还可以上下移动，亦支持旋转，由鼠标控制 本小节使用默认的观察者类 # 游戏角色死亡后，切换到观察视角 # C++ 先前我们已设置STUGameModeBase使用STUPlayerController类。 APawn::Controller和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STUPlayerController的。 游戏角色死亡时，切换到观察视角 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;GameFramework/Controller.h\u0026quot; // OnDeath if (Controller) { Controller-\u0026gt;ChangeState(NAME_Spectating); } 查看 # 虚幻编辑器 查看SpectatorPawn # WorldSetting中，GameMode默认选择SpectatorPawn作为Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 # Character死亡后，世界大纲新增SpectatorPawn1 ",content:"说明 # 当游戏角色生命值为0，我们尝试剥夺玩家对游戏角色的控制，此时仍能旋转Camera; 左右旋转视角时, Character身体也会旋转 我们可以在游戏角色死亡时，切换玩家控制的Pawn：一方面，彻底剥夺玩家对游戏角色的控制，另一方面，允许玩家做合理的操作 观察视角 # 对应一个APawn派生类，ASpectatorPawn 关卡的默认类型里，观察者类使用ASpectatorPawn 玩家死亡后，使其操控SpectatorPawn，仍能继续观看游戏 场景中的SpectatorPawn # 漂浮的Camera，除了可以前后左右移动，还可以上下移动，亦支持旋转，由鼠标控制 本小节使用默认的观察者类 # 游戏角色死亡后，切换到观察视角 # C++ 先前我们已设置STUGameModeBase使用STUPlayerController类。 APawn::Controller和具体的Controller对象动态绑定。由于其声明里使用AController，所以我们包含AController的头文件而非STUPlayerController的。 游戏角色死亡时，切换到观察视角 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;GameFramework/Controller.h\u0026quot; // OnDeath if (Controller) { Controller-\u0026gt;ChangeState(NAME_Spectating); } 查看 # 虚幻编辑器 查看SpectatorPawn # WorldSetting中，GameMode默认选择SpectatorPawn作为Spectator Class Pawn也可选择SpectatorPawn 验证观察视角 # Character死亡后，世界大纲新增SpectatorPawn1 "}),e.add({id:18,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E4%B8%BA%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%B7%BB%E5%8A%A0%E5%90%91%E5%89%8D%E8%B5%B0%E8%B7%AF%E5%8A%A8%E7%94%BB/",title:"为游戏角色添加向前走路动画",description:"概览 # 虚幻编辑器 动画随着游戏角色的运动速度而变化 brush # 最简单的可编辑几何体，我们可以修改其顶点位置，调整其他参数，然后将其转换成静态网格体 CharacterMovementComponent # 负责 Character 运动，其各种属性均和 Character 运动有关 动画蓝图 # Animation Blueprint 动画蓝图需绑定 Skeleton Mesh 命名：ABP_ 打头 动画混合 # Animation Blend 流畅地从一个动画切入到另一个动画 混合空间 # Blend Space 能在两个骨骼动画之间创建过渡动画 使用插值来得到动画姿势的中间值 需绑定 Skeleton Mesh 命名： 混合空间 和 混合空间1D 均以 BS_ 打头 一维混合空间 # Blend Space 1D 横轴 混合空间 # Blend Space 横轴和纵轴 重新设置平台 # 从场景中移除Floor 添加 Geometry/Box 恢复 Box Brush 默认位置，设置长宽高 Character运动速度上限 # BP_STUBaseCharacter CharacterMovementComponent 选择CharacterMovementComponent \u0026gt; 细节面板 \u0026gt; Character Movement: Walking \u0026gt; MaxWalkSpeed MaxWalkSpeed 即 Character 的最大运动速度，单位 cm/s 虚幻引擎里的步长使用 cm 修改 MaxWalkSpeed ，当速度改为 1600 时，可以看到单位时间内移动的距离增加，而跑步动画缺少对应的加速过程 获取实时速度并打印 # BP_STUBaseCharacter 在 EventGraph 实现 - GetVelocity函数 获取Character速度 获得Actor各个方向上的速度，保存在FVector中 FVector::VectorLength 获得速度标量 PrintString 在屏幕上输出实时速度 PrintString 使用 AddOnScreenDebugMessage 可以看到加速过程 移除打印 创建动画蓝图ABP_BaseCharacter # Animation Blueprint 创建文件夹Content/Players/Animations # 方法一: 基于Skeleton Mesh创建动画蓝图 # 选中ExternalContent/Animation/Characters/HeroTPP/HeroTPP \u0026gt; 右键 \u0026gt; Create \u0026gt; AnimBlueprint 方法二: 在指定位置创建动画蓝图 # 去到 Content/Player/Animations，右键 \u0026gt; Animation \u0026gt; 选择Animation Blueprint 选择 HeroTPP_Skeleton 命名为 ABP_BaseCharacter 在蓝图编辑器中查看动画蓝图 # ABP_BaseCharacter - EventGraph 事件图表 处理各种动画事件；像使用 Tick 一样使用 EventBlueprintUpdateAnimation AnimGraph 动画图表 处理所有动画；可以将动画资产作为 OutputPose 的输入 AssetBrowser 动画资产窗口 可以从 Window \u0026gt; AssetBrowser 打开，罗列了 SkeletonMesh 所有相关动画 为游戏角色设置动画时使用动画蓝图 # 为ABP_BaseCharacter设置输入 # 动画图表 将 Run_Fwd 作为 OutputPose 的输入 设置 Run_Fwd 重复播放 选中Run_Fwd \u0026gt; Details \u0026gt; Settings \u0026gt; 使能 LoopAnimation 让Character使用动画蓝图 # BP_STBaseCharacter - Animation Mode Use Animation Blueprint Anim Class ABP_BaseCharacter 查看动画资产 # 去到Content/ExternalContent/Animation/Animations/TTP_Animations，双击 Run_Fwd 可在 AssetBrowser 中选择其他动画 混合空间资产 # Blend Space 速度从 0 - 600 ，动画从 Idle 过渡到 Run_Fwd 创建BS_Locomotion_Walk_1D # 去到Content/Player/Animations，右键 选择 HeroTPP_Skeleton 命名为 BS_Locomotion_Walk_1D 配置BS_Locomotion_Walk_1D # 双击打开 BS_Locomotion_Walk_1D 配置横轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis 说明 Name 名称 Velocity Minimum Axis Value 轴最小值 0 Maximum Axis Value 轴最大值 600 游戏角色运动速度上限 Grid Divisions 过渡区间 4 使用默认值；和可以添加的动画个数有关 配置动画 动画资产 Velocity 起点 Idle 0 终点 Run_Fwd 600 查看插值 系统 键位 Windows Control MacOS Command 按下键位，水平移动鼠标，绿色X随之在起点和终点间移动，视口展示过渡动画 将BS_Locomotion_Walk_1D作为动画蓝图输入 # ABP_BaseCharacter 添加变量Velocity # 在 MyBlueprint 添加变量 Velocity ，在Details设置名称和类型 设置变量Velocity # EventGraph 将变量Velocity拖动到EventGraph, 选择设置变量值 在 EventBlueprintUpdateAnimation 之后，执行 SetVelocity GetPawnOwner 返回 Pawn 实例的引用, 变量 Velocity 的输入是 Actor 实时速度 设置动画蓝图输入 # AnimGraph 将BS_Locomotion_Walk_1D作为OutputPose的输入 将变量Velocity拖动到AnimGraph, 选择获取变量值 将变量Velocity作为BS_Locomotion_Walk_1D的输入 ",content:"概览 # 虚幻编辑器 动画随着游戏角色的运动速度而变化 brush # 最简单的可编辑几何体，我们可以修改其顶点位置，调整其他参数，然后将其转换成静态网格体 CharacterMovementComponent # 负责 Character 运动，其各种属性均和 Character 运动有关 动画蓝图 # Animation Blueprint 动画蓝图需绑定 Skeleton Mesh 命名：ABP_ 打头 动画混合 # Animation Blend 流畅地从一个动画切入到另一个动画 混合空间 # Blend Space 能在两个骨骼动画之间创建过渡动画 使用插值来得到动画姿势的中间值 需绑定 Skeleton Mesh 命名： 混合空间 和 混合空间1D 均以 BS_ 打头 一维混合空间 # Blend Space 1D 横轴 混合空间 # Blend Space 横轴和纵轴 重新设置平台 # 从场景中移除Floor 添加 Geometry/Box 恢复 Box Brush 默认位置，设置长宽高 Character运动速度上限 # BP_STUBaseCharacter CharacterMovementComponent 选择CharacterMovementComponent \u0026gt; 细节面板 \u0026gt; Character Movement: Walking \u0026gt; MaxWalkSpeed MaxWalkSpeed 即 Character 的最大运动速度，单位 cm/s 虚幻引擎里的步长使用 cm 修改 MaxWalkSpeed ，当速度改为 1600 时，可以看到单位时间内移动的距离增加，而跑步动画缺少对应的加速过程 获取实时速度并打印 # BP_STUBaseCharacter 在 EventGraph 实现 - GetVelocity函数 获取Character速度 获得Actor各个方向上的速度，保存在FVector中 FVector::VectorLength 获得速度标量 PrintString 在屏幕上输出实时速度 PrintString 使用 AddOnScreenDebugMessage 可以看到加速过程 移除打印 创建动画蓝图ABP_BaseCharacter # Animation Blueprint 创建文件夹Content/Players/Animations # 方法一: 基于Skeleton Mesh创建动画蓝图 # 选中ExternalContent/Animation/Characters/HeroTPP/HeroTPP \u0026gt; 右键 \u0026gt; Create \u0026gt; AnimBlueprint 方法二: 在指定位置创建动画蓝图 # 去到 Content/Player/Animations，右键 \u0026gt; Animation \u0026gt; 选择Animation Blueprint 选择 HeroTPP_Skeleton 命名为 ABP_BaseCharacter 在蓝图编辑器中查看动画蓝图 # ABP_BaseCharacter - EventGraph 事件图表 处理各种动画事件；像使用 Tick 一样使用 EventBlueprintUpdateAnimation AnimGraph 动画图表 处理所有动画；可以将动画资产作为 OutputPose 的输入 AssetBrowser 动画资产窗口 可以从 Window \u0026gt; AssetBrowser 打开，罗列了 SkeletonMesh 所有相关动画 为游戏角色设置动画时使用动画蓝图 # 为ABP_BaseCharacter设置输入 # 动画图表 将 Run_Fwd 作为 OutputPose 的输入 设置 Run_Fwd 重复播放 选中Run_Fwd \u0026gt; Details \u0026gt; Settings \u0026gt; 使能 LoopAnimation 让Character使用动画蓝图 # BP_STBaseCharacter - Animation Mode Use Animation Blueprint Anim Class ABP_BaseCharacter 查看动画资产 # 去到Content/ExternalContent/Animation/Animations/TTP_Animations，双击 Run_Fwd 可在 AssetBrowser 中选择其他动画 混合空间资产 # Blend Space 速度从 0 - 600 ，动画从 Idle 过渡到 Run_Fwd 创建BS_Locomotion_Walk_1D # 去到Content/Player/Animations，右键 选择 HeroTPP_Skeleton 命名为 BS_Locomotion_Walk_1D 配置BS_Locomotion_Walk_1D # 双击打开 BS_Locomotion_Walk_1D 配置横轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis 说明 Name 名称 Velocity Minimum Axis Value 轴最小值 0 Maximum Axis Value 轴最大值 600 游戏角色运动速度上限 Grid Divisions 过渡区间 4 使用默认值；和可以添加的动画个数有关 配置动画 动画资产 Velocity 起点 Idle 0 终点 Run_Fwd 600 查看插值 系统 键位 Windows Control MacOS Command 按下键位，水平移动鼠标，绿色X随之在起点和终点间移动，视口展示过渡动画 将BS_Locomotion_Walk_1D作为动画蓝图输入 # ABP_BaseCharacter 添加变量Velocity # 在 MyBlueprint 添加变量 Velocity ，在Details设置名称和类型 设置变量Velocity # EventGraph 将变量Velocity拖动到EventGraph, 选择设置变量值 在 EventBlueprintUpdateAnimation 之后，执行 SetVelocity GetPawnOwner 返回 Pawn 实例的引用, 变量 Velocity 的输入是 Actor 实时速度 设置动画蓝图输入 # AnimGraph 将BS_Locomotion_Walk_1D作为OutputPose的输入 将变量Velocity拖动到AnimGraph, 选择获取变量值 将变量Velocity作为BS_Locomotion_Walk_1D的输入 "}),e.add({id:19,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%8A%A8%E6%B2%BB%E7%96%97/",title:"自动治疗",description:"说明 # C++ 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现 获取定时器管理对象 UActorComponent::GetOwner \u0026gt; AActor::GetWorldTimerManager UActorComponent::GetWorld \u0026gt; UWorld::GetTimerManager 实现自动治疗 # 添加治疗参数 # protected 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealDelay = 3.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealModifier = 5.0f; 添加定时器 # 添加数据成员 # private ShootThemUp: Components/STUHealthComponent.",content:`说明 # C++ 治疗机制 受到伤害则延缓治疗；不再受到伤害才会自动治疗 使用定时器实现 获取定时器管理对象 UActorComponent::GetOwner \u0026gt; AActor::GetWorldTimerManager UActorComponent::GetWorld \u0026gt; UWorld::GetTimerManager 实现自动治疗 # 添加治疗参数 # protected 参数 名称 使能自动治疗 AutoHeal 首次治疗延后时长 HealDelay 恢复生命值周期 HealRate 单次恢复量 HealModifier ShootThemUp: Components/STUHealthComponent.h UPROPERTY(EditDefaultsOnly) bool AutoHeal = true; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealRate = 1.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealDelay = 3.0f; UPROPERTY(EditDefaultsOnly, meta = (EditCondition = \u0026quot;AutoHeal\u0026quot;)) float HealModifier = 5.0f; 添加定时器 # 添加数据成员 # private ShootThemUp: Components/STUHealthComponent.h FTimerHandle HealTimer; 搭建框架 # 添加空的回调函数
ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnHeal() {} 定时器接口
ShootThemUp: Components/STUHealthComponent.cpp 头文件 #include \u0026quot;Engine/World.h\u0026quot; #include \u0026quot;TimerManager.h\u0026quot; 开启定时器 void USTUHealthComponent::StartHealTimer() { if (AutoHeal \u0026amp;\u0026amp; GetWorld()) { GetWorld()-\u0026gt;GetTimerManager().SetTimer(HealTimer, this, \u0026amp;USTUHealthComponent::OnHeal, HealRate, true, HealDelay); } } 关闭定时器 void USTUHealthComponent::StopHealTimer() { if (AutoHeal \u0026amp;\u0026amp; GetWorld()) { GetWorld()-\u0026gt;GetTimerManager().ClearTimer(HealTimer); } } 接口声明 private ShootThemUp: Components/STUHealthComponent.h 回调函数声明
private ShootThemUp: Components/STUHealthComponent.h 回调函数实现 # ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnHeal() { SetHealth(Health + HealModifier); if (FMath::IsNearlyEqual(Health, MaxHealth)) { StopHealTimer(); } } 游戏角色受到伤害延缓治疗 # ShootThemUp: Components/STUHealthComponent.cpp void USTUHealthComponent::OnTakeAnyDamage(AActor *DamagedActor, float Damage, const UDamageType *DamageType, AController *InstigatedBy, AActor *DamageCauser) { if (Damage \u0026lt;= 0.0f || IsDead()) return; if (!FMath::IsNearlyEqual(Health, MaxHealth)) StopHealTimer(); // Health -= Damage; SetHealth(Health - Damage); UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;Damage: %.0f\u0026quot;), Damage); if (DamageType) { if (DamageType-\u0026gt;IsA\u0026lt;USTUFireDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Hooooooot !!!\u0026quot;)); } else if (DamageType-\u0026gt;IsA\u0026lt;USTUIceDamageType\u0026gt;()) { UE_LOG(LogHealthComponent, Display, TEXT(\u0026quot;So Cooooooooold !!!\u0026quot;)); } } if (IsDead()) { OnDeath.Broadcast(); } else { StartHealTimer(); } } 重写IsDead # ShootThemUp: Components/STUHealthComponent.h bool IsDead() const { return FMath::IsNearlyZero(Health); } `}),e.add({id:20,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%B7%B3%E8%B7%83/",title:"实现游戏角色跳跃",description:"概览 # 状态机 # State Machine 定义多个状态，每个状态对应一个动画 在一个动画蓝图中管理多个状态，并定义状态之间的迁移条件 ACharacter::IsFalling # 当Character在空中时返回true，Character落地时返回false 绑定跳跃键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Jump SpaceBar 实现跳跃逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Jump Jump 回调函数由虚幻引擎提供，按下时触发 绑定函数描述和回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Jump\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::Jump); 使用状态机实现跳跃动画 # 虚幻编辑器 实现跳跃动画 # ABP_BaseCharacter 添加状态机, 将其作为OutPose的输入 # AnimGraph 添加 状态机 ，命名为 Locomotion 将 Locomotion 作为 OutputPose 的输入 状态机说明 # 跳跃动画资产 - JumpStart 跳起 JumpLoop 在空中 JumpEnd 落地 状态 - Walk JumpStart JumpLoop JumpEnd 状态迁移 - Walk \u0026gt; JumpStart 游戏角色在空中 JumpStart \u0026gt; JumpLoop JumpStart 动画播放结束 JumpLoop \u0026gt; JumpEnd 游戏角色落地 JumpEnd \u0026gt; Walk JumpEnd 动画播放结束 实现状态机 # 双击Locomotion，进入状态机",content:`概览 # 状态机 # State Machine 定义多个状态，每个状态对应一个动画 在一个动画蓝图中管理多个状态，并定义状态之间的迁移条件 ACharacter::IsFalling # 当Character在空中时返回true，Character落地时返回false 绑定跳跃键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Jump SpaceBar 实现跳跃逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Jump Jump 回调函数由虚幻引擎提供，按下时触发 绑定函数描述和回调函数 # ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Jump\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::Jump); 使用状态机实现跳跃动画 # 虚幻编辑器 实现跳跃动画 # ABP_BaseCharacter 添加状态机, 将其作为OutPose的输入 # AnimGraph 添加 状态机 ，命名为 Locomotion 将 Locomotion 作为 OutputPose 的输入 状态机说明 # 跳跃动画资产 - JumpStart 跳起 JumpLoop 在空中 JumpEnd 落地 状态 - Walk JumpStart JumpLoop JumpEnd 状态迁移 - Walk \u0026gt; JumpStart 游戏角色在空中 JumpStart \u0026gt; JumpLoop JumpStart 动画播放结束 JumpLoop \u0026gt; JumpEnd 游戏角色落地 JumpEnd \u0026gt; Walk JumpEnd 动画播放结束 实现状态机 # 双击Locomotion，进入状态机
仅一个入口 Entry 移植Walk状态
为 Locomotion 添加 State ，命名为 Walk ，使 Entry 指向 双击 Walk 将OutputPose之前的输入， Velocity + BS_Locomotion_Walk_1D 封装到 Walk 状态（剪切）， 作为其 OutputAnimationPose 的输入 至此， Character 的运动动画和上一小节一致 实现跳跃状态
添加布尔型变量IsFalling
上一小节中，变量 Velocity 横跨 ABP_BaseCharacter 的 EventGraph 和 AnimGraph ，这里，布尔类型变量 IsFalling 也一样 在 EventGraph 设置变量值，在 AnimGraph 中使用变量 使用ACharacter::IsFalling设置变量IsFalling
EventGraph 将Pawn转换为Character
接着设置Velocity, 将Pawn转换为Character 不能同时从 EventBlueprintUpdateAnimation 出发， SetVelocity 之后，执行转换 双击 TryGetPawnOwner 和 CastToCharacter 连线上的一点，创建Bezier曲线，排线更易整理 对ACharacter::CharacterMovement调用ACharacter::IsFalling
接着CastToCharacter, 设置IsFalling 从 CaseToCharacter \u0026gt; AsCharacter 到 IsFalling \u0026gt; Target ，自动添加提取数据成员; IsFalling 函数的返回类型是布尔，作为 SetIsFalling 的输入 完整EventGraph
实现状态机
回到 Locomotion 从 AssetBrowser 把 Jump 的三个动画拖入 Locomotion 动画自动被封装为 State ，和之前 AddState ，再将动画作为状态输入达到的效果一样 添加状态迁移路径 添加状态迁移条件 状态迁移 触发条件 Walk \u0026gt; JumpStart 游戏角色在空中 ACharacter::IsFalling 返回true JumpStart \u0026gt; JumpLoop JumpStart 动画播放结束 TimeRemaining \u0026lt; 0.1 JumpLoop \u0026gt; JumpEnd 游戏角色落地 ACharacter::IsFalling 返回true JumpEnd \u0026gt; Walk JumpEnd 动画播放结束 TimeRemaining \u0026lt; 0.1 双击转换图标，即可为状态迁移添加迁移条件 拿 Walk \u0026gt; JumpStart 举例 Walk \u0026gt; JumpStart 迁移条件：变量 IsFalling 为 true JumpStart \u0026gt; JumpLoop 迁移条件： JumpStart 动画将近结束 JumpLoop \u0026gt; JumpEnd 迁移条件：变量 IsFalling 为 false JumpEnd \u0026gt; Walk 迁移条件： JumpEnd 将近结束 设置 State 输入动画是否循环播放 - BS_Locomotion_Walk_1D 循环播放 JumpStart 播放一次 JumpLoop 循环播放 JumpEnd 播放一次 拿 JumpStart 状态举例: 选中JumpStart动画 \u0026gt; Details \u0026gt; Settings \u0026gt; LoopAnimation 为true 如此设置还可修复Character跳跃时的卡顿 添加楼梯，查看Jump三阶段是否正常显示 # 添加楼梯 PlaceActors \u0026gt; Geometry \u0026gt; LinearStair 设置阶数 选中LinearStairBrush \u0026gt; Details \u0026gt; BrushSettings \u0026gt; NumSteps 将楼梯移动到合适位置 游戏角色从楼梯跳到平面时，循环 JumpLoop 跑步时跳跃，落地后会平滑一段距离 跳跃时Z方向速度 # BP_STUBaseCharacter JumpZVelocity不宜过大, 不然 JumpStart 动画播放结束，速度却未减为0，此时Character还在上升，却在播放 JumpLoop - Vz \u0026gt; 0 JumpStart 该过程应 近似 JumpStart 播放时长 Vz \u0026lt;= 0 JumpLoop 从临界点落下 Vz = 0 JumpEnd `}),e.add({id:21,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E5%9D%A0%E8%90%BD%E4%BC%A4%E5%AE%B3/",title:"坠落伤害",description:"说明 # C++ 落地速度Z方向的分量和坠落高度有关；速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落机制 # Character定义了坠落委托类型FLandedSignature，并有该类型成员ACharacter::LandedDelegate 委托类型的处理函数签名 void handler(const FHitResult\u0026amp; Hit); 该委托类型支持蓝图 Character在ACharacter::Landed通知客户端 思路 # 我们可以注册LandedDelegate的委托服务，也可以覆写ACharacter::Landed，添加相应处理 选择注册委托服务 坠落伤害计算 # 参数 - 坠落伤害范围 LandedDamageRange [c, d] 落地速度范围 LandedDamageVelocityRange [a, b] 落地速度和对应的伤害 速度 伤害 \u0026lt; a 无伤 [a, b] [c, d] c + (Velocity - a) (d - c) / (b - a) \u0026gt; b d 获取Character速度 APawn::GetVelocity ACharacter:: GetCharacterMovement \u0026gt; UCharacterMovementComponent::Velocity 添加坠落伤害参数 # protected ShootThemUp: Player/STUBaseCharacter.",content:"说明 # C++ 落地速度Z方向的分量和坠落高度有关；速度越大，坠落高度越大 t = sqrt(2*h/g) = v/g 跳跃时落地，也符合坠落定义；在一定范围内，坠落无伤害 坠落机制 # Character定义了坠落委托类型FLandedSignature，并有该类型成员ACharacter::LandedDelegate 委托类型的处理函数签名 void handler(const FHitResult\u0026amp; Hit); 该委托类型支持蓝图 Character在ACharacter::Landed通知客户端 思路 # 我们可以注册LandedDelegate的委托服务，也可以覆写ACharacter::Landed，添加相应处理 选择注册委托服务 坠落伤害计算 # 参数 - 坠落伤害范围 LandedDamageRange [c, d] 落地速度范围 LandedDamageVelocityRange [a, b] 落地速度和对应的伤害 速度 伤害 \u0026lt; a 无伤 [a, b] [c, d] c + (Velocity - a) (d - c) / (b - a) \u0026gt; b d 获取Character速度 APawn::GetVelocity ACharacter:: GetCharacterMovement \u0026gt; UCharacterMovementComponent::Velocity 添加坠落伤害参数 # protected ShootThemUp: Player/STUBaseCharacter.h UPROPERTY(EditDefaultsOnly) FVector2D LandedDamageVelocityRange = {900.0f, 1200.0f}; UPROPERTY(EditDefaultsOnly)	FVector2D LandedDamageRange = {10.0f, 100.0f}; 注册坠落伤害的委托服务 # 搭建框架 # 添加空函数 OnLanded函数名已被使用 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnGroundLanded(const FHitResult \u0026amp;Hit) {} 注册服务 ShootThemUp: Player/STUBaseCharacter.cpp // BeginPlay LandedDelegate.AddDynamic(this, \u0026amp;ASTUBaseCharacter::OnGroundLanded); 函数声明 private ShootThemUp: Player/STUBaseCharacter.h UFUNCTION() void OnGroundLanded(const FHitResult\u0026amp; Hit); 实现处理函数 # 坠落伤害属于环境伤害，无伤害源(Actor)和阵营(Controller) ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::OnGroundLanded(const FHitResult \u0026amp;Hit) { float Velocity = -GetVelocity().Z; if (Velocity \u0026lt; LandedDamageVelocityRange.X) return; float LandedDamage = FMath::GetMappedRangeValueClamped(LandedDamageVelocityRange, LandedDamageRange, Velocity); TakeDamage(LandedDamage, FDamageEvent{}, nullptr, nullptr); } "}),e.add({id:22,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E8%B7%91%E6%AD%A5/",title:"实现游戏角色跑步",description:"概览 # 跑步条件 # 按下Shift键 运动方向为向前 判断方法1：同时按下 W 或 Up 判断方法2：速度矢量和朝向的夹角为0 速度不为0 前方有障碍物时，游戏角色无法跑步 跑步时，播放跑步动画 # 跑步时，游戏角色运动速度提高 # 绑定跑步键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Run LeftShift 实现跑步逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Run RunEnable 按下时触发 RunDisable 松开时触发 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::RunEnable() {} void ASTUBaseCharacter::RunDisable() {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::RunEnable); PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Released, this, \u0026amp;ASTUBaseCharacter::RunDisable); 添加函数声明 private ShootThemUp: Player/STUBaseCharacter.",content:`概览 # 跑步条件 # 按下Shift键 运动方向为向前 判断方法1：同时按下 W 或 Up 判断方法2：速度矢量和朝向的夹角为0 速度不为0 前方有障碍物时，游戏角色无法跑步 跑步时，播放跑步动画 # 跑步时，游戏角色运动速度提高 # 绑定跑步键位 # 虚幻编辑器 项目设置 \u0026gt; Engine \u0026gt; Input 动作映射 函数描述 键位 Run LeftShift 实现跑步逻辑 # C++ - 回调函数签名 BindAction void handler() 函数描述 回调函数 Run RunEnable 按下时触发 RunDisable 松开时触发 搭建框架 # 添加空函数 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::RunEnable() {} void ASTUBaseCharacter::RunDisable() {} 绑定函数描述和回调函数 ShootThemUp: Player/STUBaseCharacter.cpp // SetupPlayerInputComponent PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Pressed, this, \u0026amp;ASTUBaseCharacter::RunEnable); PlayerInputComponent-\u0026gt;BindAction(\u0026quot;Run\u0026quot;, IE_Released, this, \u0026amp;ASTUBaseCharacter::RunDisable); 添加函数声明 private ShootThemUp: Player/STUBaseCharacter.h 实现回调函数 # 键位生效时，设置标识位 # 定义标志位 private ShootThemUp: Player/STUBaseCharacter.h bool AbleRun = false; 键位事件发生时, 更新标志位 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::RunEnable() { AbleRun = true; } void ASTUBaseCharacter::RunDisable() { AbleRun = false; } 运动方向向前时，设置标志位 # 定义标志位 private ShootThemUp: Player/STUBaseCharacter.h bool IsForward = false; MoveForward被调用时, 更新标志位 ShootThemUp: Player/STUBaseCharacter.cpp // MoveForward IsForward = Amount \u0026gt; 0.0f; 添加接口, 返回跑步条件满足情况 # 添加函数声明 public 可在蓝图中调用，也可供其他类使用 ShootThemUp: Player/STUBaseCharacter.h UFUNCTION(BlueprintCallable) bool IsRunning() const; 实现 ShootThemUp: Player/STUBaseCharacter.cpp bool ASTUBaseCharacter::IsRunning() const { return AbleRun \u0026amp;\u0026amp; IsForward \u0026amp;\u0026amp; !GetVelocity().IsZero(); } 添加跑步动画 # 虚幻编辑器 创建混合空间资产作为跑步动画 # Blend Space 1D 创建 Content/Player/Animations/BS_Locomotion_Run，绑定骨骼网格体 HeroTPP_Skeleton 设置轴 Asset Details \u0026gt; Axis Settings \u0026gt; Horizontal Axis - Name Velocity Maximum Axis Value 600 设置动画 - 起点 Idle 终点 RoadieRun_Fwd 在动画蓝图中引入跑步动画 # ABP_BaseCharacter 状态机说明 # 新增状态: Run 状态迁移 - Walk \u0026gt; Run 满足跑步条件 Run \u0026gt; Walk 不再满足跑步条件 Run \u0026gt; JumpStart 游戏角色在空中 使状态机管理跑步状态 # 添加布尔型变量IsRunning 设置变量IsRunning
EventGraph 使用 STUBaseCharacter::IsRunning ，需要 Pawn 到 STUBaseCharacter 的转换 设置IsFalling后, 执行Pawn到STUBaseCharacter的转换 转换完成后, 设置变量 IsRunning 完整 EventGraph 可以合并 Pawn 到 Character 和 STUBaseCharacter 的转换 状态机中添加跑步状态
AnimGraph 将BS_Locomotion_Run拖入到状态机, 命令为 Run 双击 Run ，设置BS_Locomotion_Run输入 添加状态迁移条件
- 触发条件 Walk \u0026gt; Run 满足跑步条件 STUBaseCharacter::IsRunning 返回true Run \u0026gt; Walk 不再满足跑步条件 STUBaseCharacter::IsRunning 返回false Run \u0026gt; JumpStart 游戏角色在空中 复用 Walk \u0026gt; JumpStart 迁移条件 Walk \u0026lt;\u0026gt; Run
状态迁移路径 Walk \u0026gt; Run 迁移条件 Run \u0026gt; Walk 迁移条件 Run \u0026gt; Jump
状态迁移路径
初稿 优解 如果 IsRunning 为 true, 发生 JumpEnd \u0026gt; Walk 时, 会立即从 Walk 切换到 Run 省略 JumpEnd \u0026gt; =Run ，可以降低状态机复杂度 复用迁移条件
Run \u0026gt; JumpStart 复用 Walk \u0026gt; JumpStart 迁移条件 选中 Walk \u0026gt; JumpStart 迁移条件, Details \u0026gt; Transiton \u0026gt; Transition Rule Sharing \u0026gt; Promote To Share 命名为 IsFalling ，共享条件显示为红色 选中 Run \u0026gt; JumpStart 迁移条件, Details \u0026gt; Transition \u0026gt; Transition Rule Sharing \u0026gt; Use Shared \u0026gt; 选择IsFalling 完整状态机 效果 # 运行游戏，走路到跑步动画正常切换 实现跑步加速 # 创建Components/CharacterMovementComponent的派生类 # 虚幻编辑器 CharacterMovementComponent 公有类 设置头文件搜索路径 # ShootThemUp: ShootThemUp.Build.cs PublicIncludePaths.AddRange(new string[] { \u0026quot;ShootThemUp/Public/Player\u0026quot;, \u0026quot;ShootThemUp/Public/Components\u0026quot; }); 满足跑步条件时, 增加游戏角色运动速度上限 # C++ 添加加速系数 # protected ShootThemUp: Components/STUCharacterMovementComponent.h UPROPERTY(EditDefaultsOnly, meta = (ClampMin = \u0026quot;1.5\u0026quot;, ClampMax = \u0026quot;10.0\u0026quot;)) float SpeedAcceleration = 2.0f; 覆写UCharacterMovementComponent::GetMaxSpeed # 并不直接修改 MaxWalkSpeed 某个地方会调用 GetMaxSpeed 来确定 Character 运动速度的上限，当获取的 MaxWalkSpeed 增加，速度增加的幅度也变大，用以实现加速 添加函数声明
public ShootThemUp: Components/STUCharacterMovementComponent.h virtual float GetMaxSpeed() const override; 实现
ShootThemUp: Components/STUCharacterMovementComponent.cpp #include \u0026quot;Player/STUBaseCharacter.h\u0026quot; float USTUCharacterMovementComponent::GetMaxSpeed() const { const float MaxSpeed = Super::GetMaxSpeed(); ASTUBaseCharacter *Player = Cast\u0026lt;ASTUBaseCharacter\u0026gt;(GetPawnOwner()); return Player \u0026amp;\u0026amp; Player-\u0026gt;IsRunning() ? SpeedAcceleration * MaxSpeed : MaxSpeed; } 游戏角色使用STUCharacterMovementComponent # 屏蔽默认构造函数声明，声明构造函数 ShootThemUp: Player/STUBaseCharacter.h // ASTUBaseCharacter(); ASTUBaseCharacter(const FObjectInitializer \u0026amp;ObjInit); 修改构造函数初始化列表 ShootThemUp: Player/STUBaseCharacter.cpp #include \u0026quot;Components/STUCharacterMovementComponent.h\u0026quot; ASTUBaseCharacter::ASTUBaseCharacter(const FObjectInitializer \u0026amp;ObjInit) : Super(ObjInit.SetDefaultSubobjectClass\u0026lt;USTUCharacterMovementComponent\u0026gt;(ACharacter::CharacterMovementComponentName)) { // ... } `}),e.add({id:23,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/",title:"阶段性总结",description:"项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D AM_Death BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent STUHealthComponent Player STUBaseCharacter STUPlayerController Dev STUDevDamageActor STUFireDamageType STUIceDamageType STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D Player/Animations/AM_Death STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 轴映射 左右移动 APawn::AddMovementInput；AActor::GetActorRightVector MoveForward 轴映射 前后移动 APawn::AddMovementInput；AActor::GetActorForwardVector 轴映射 左右旋转 ACharacter::AddControllerYawInput 轴映射 上下旋转 ACharacter::AddControllerPitchInput 动作映射 跳跃 ACharacter::Jump RunEnable，RunDisable 动作映射 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 委托 处理函数 作用 委托成员 操作 OnChangeHealth 修改显示生命值 HealthComponent::OnChangeHealth 修改HealthTextComponent文本 OnDeath 游戏角色死亡处理 HealthComponent::OnDeath 播放死亡动画剪辑；禁止操作Character；定时销毁；切换到观察视角 OnGroundLanded 计算落地伤害 ACharacter::LandedDelegate 计算落地伤害；对Character调用TakeDamage 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 HealthComponent 生命值系统 HealthTextComponent 显示生命值 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 游戏角色死亡逻辑 说明 DeathAnimMontage 死亡动画剪辑 LifeSpanOnDeath 销毁角色定时间隔 落地伤害逻辑 说明 LandedDamageRange 伤害范围 LandedDamageVelocityRange 造成伤害的速度范围 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true HealthComponent # HealthTextComponent # 说明 Horizontal Alignment Center Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机",content:`项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D AM_Death BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent STUHealthComponent Player STUBaseCharacter STUPlayerController Dev STUDevDamageActor STUFireDamageType STUIceDamageType STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D Player/Animations/AM_Death STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 轴映射 左右移动 APawn::AddMovementInput；AActor::GetActorRightVector MoveForward 轴映射 前后移动 APawn::AddMovementInput；AActor::GetActorForwardVector 轴映射 左右旋转 ACharacter::AddControllerYawInput 轴映射 上下旋转 ACharacter::AddControllerPitchInput 动作映射 跳跃 ACharacter::Jump RunEnable，RunDisable 动作映射 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 委托 处理函数 作用 委托成员 操作 OnChangeHealth 修改显示生命值 HealthComponent::OnChangeHealth 修改HealthTextComponent文本 OnDeath 游戏角色死亡处理 HealthComponent::OnDeath 播放死亡动画剪辑；禁止操作Character；定时销毁；切换到观察视角 OnGroundLanded 计算落地伤害 ACharacter::LandedDelegate 计算落地伤害；对Character调用TakeDamage 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 HealthComponent 生命值系统 HealthTextComponent 显示生命值 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 游戏角色死亡逻辑 说明 DeathAnimMontage 死亡动画剪辑 LifeSpanOnDeath 销毁角色定时间隔 落地伤害逻辑 说明 LandedDamageRange 伤害范围 LandedDamageVelocityRange 造成伤害的速度范围 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true HealthComponent # HealthTextComponent # 说明 Horizontal Alignment Center Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机
Locomotion \u0026gt; Slot \u0026gt; OutputPose 状态 状态 说明 走路 Walk BS_Locomotion_Walk；混合空间 跑步 Run BS_Locomotion_Run；混合空间1D 跳跃 JumpStart JumpLoop JumpEnd 死亡 AM_Death；动画剪辑 变量 动画输入 名称 速度 Velocity 速度和前进方向的夹角 Directon 转换条件 说明 IsRunning C++ 满足3个条件：按下Shift；速度和前进方向夹角为0（或按下W/Up）；速度不为0 IsFalling CharacterMovementComponent::IsFalling 返回true，意味着游戏角色跳起；接着返回false，意味着游戏角色回到地面 EventGraph # 设置变量 - Velocity Directon IsRunning IsFalling 组件 # C++ STUCharacterMovementComponent # 满足跑步条件时，提高运动速度上限 参数 说明 SpeedAcceleration 加速系数 STUHealthComponent # 函数成员 # 基本函数 操作 构造函数 每帧调用Tick标志位置为false BeginPlay 初始化生命值；注册AActor::OnTakeAnyDamage TickComponent 屏蔽 接口 接口函数 操作 GetHealth 获取当前生命值；STBaseCharacter调用 IsDead 判断角色是否死亡 内部逻辑 说明 SetHealth 修改生命值；受到伤害或治疗时调用，随之广播 治疗 说明 OnHeal 定时器回调函数；治疗；满生命值停止定时器 StartHealTimer 受到伤害则开启定时器 StopHealTimer 受到伤害会关闭之前开启的定时器；满生命值时停止定时器 受伤处理函数 - OnTakeAnyDamage 进入条件：伤害为正数，当前角色存活；受伤后，停止已开启的治疗定时器；更新生命值；若角色死亡，广播，否则，开启治疗定时器 数据成员 # 说明 Health 生命值 MaxHealth 最大生命值 委托成员 说明 OnChangeHealth 修改生命值(SetHealth)时广播 OnDeath 受到伤害时，若死亡，广播 治疗 说明 HealTimer 定时器 AutoHeal 使能治疗 HealModifier 治疗量 HealRate 治疗频率 HealDelay 治疗延时 伤害 # C++ STUDevDamageActor # 函数成员 # 基本函数 操作 构造函数 初始化组件 BeginPlay Tick 绘制球体模拟爆炸范围；对球体内以及相交Actor造成伤害 数据成员 # 说明 SceneComponent 变换属性 Radius 球体半径 SphereColor 球体颜色 Damage 伤害的数值特征 DoFullDamage 计算伤害机制标志位 STUFireDamageType和STUIceDamageType # `}),e.add({id:24,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E6%B7%BB%E5%8A%A0%E8%B5%B0%E8%B7%AF%E6%97%B6%E8%BD%AC%E5%90%91%E5%8A%A8%E7%94%BB/",title:"添加走路转向动画",description:"概览 # 已实现动作 # Walk: 从静止到跑起来支持加速，使用 BS_Locomotion_Walk_1D Run: BS_Locomotion_Run Jump: JumpStart , JumpEnd , JumpLoop 本节内容 # 重新实现走路动画，根据游戏角色前进方向和速度方向的夹角，增加转向和后退动画 之后还有 装弹 Reloading , 死亡 Death 和瞄准 Aiming 动画 2D混合空间 # Blend Space 拥有两个轴， Vertial Axis 和 Horizontal Axis 建模 # 游戏角色朝向 # - 前进和后退 ForwardVector 左右 RightVector 游戏角色前后左右移动有使用到这两个方向向量 我们水平移动鼠标时， ForwardVector 和 RightVector 随之发生改变 在视觉上， ForwardVector 一直向前， RightVector 一直向右，二者在水平面垂直 数学基础 # 点乘 # 计算向量夹角 其中一个向量为 0向量 时，点乘结果为 0 ，而反余弦计算得到其夹角为 PI/2 叉乘 # 将向量夹角从[0, PI]扩充到[-PI, PI] theta 为 0 PI 和 -PI 时，叉乘结果为 0 ，此时无法通过向量确定平面，也就无法得到平面法向量 向量c的z坐标 c.",content:"概览 # 已实现动作 # Walk: 从静止到跑起来支持加速，使用 BS_Locomotion_Walk_1D Run: BS_Locomotion_Run Jump: JumpStart , JumpEnd , JumpLoop 本节内容 # 重新实现走路动画，根据游戏角色前进方向和速度方向的夹角，增加转向和后退动画 之后还有 装弹 Reloading , 死亡 Death 和瞄准 Aiming 动画 2D混合空间 # Blend Space 拥有两个轴， Vertial Axis 和 Horizontal Axis 建模 # 游戏角色朝向 # - 前进和后退 ForwardVector 左右 RightVector 游戏角色前后左右移动有使用到这两个方向向量 我们水平移动鼠标时， ForwardVector 和 RightVector 随之发生改变 在视觉上， ForwardVector 一直向前， RightVector 一直向右，二者在水平面垂直 数学基础 # 点乘 # 计算向量夹角 其中一个向量为 0向量 时，点乘结果为 0 ，而反余弦计算得到其夹角为 PI/2 叉乘 # 将向量夹角从[0, PI]扩充到[-PI, PI] theta 为 0 PI 和 -PI 时，叉乘结果为 0 ，此时无法通过向量确定平面，也就无法得到平面法向量 向量c的z坐标 c.z 的符号说明向量的方向 速度方向 # VelocityVector Actor 的速度是一个矢量，其表现是单位时间内的位移方向 当速度不为 0 ， VelocityVector 和 ForwardVector 的夹角与此时 Actor 应该展现的动画有关 计算游戏角色前进方向和速度方向的夹角 # VelocityVector 和 ForwardVector 的夹角通过向量点乘反余弦结果和向量叉乘结果z分量符号 sign(c.z) 的乘积得到 夹角 反余弦结果 sign(c.z) 目的动画 使用乘积效果 0 0 0 Fwd o ( 0, PI/2 ) ( 0, PI/2 ) 1 Fwd \u0026gt; Right o PI/2 PI/2 1 Right o ( PI/2, PI ) ( PI/2, PI ) 1 Right \u0026gt; Bwd o PI PI 0 Bwd x -PI PI 0 Bwd x ( -PI, -PI/2 ) ( PI/2, PI ) -1 Left \u0026gt; Bwd o -PI/2 PI/2 -1 Left o ( -PI/2, 0 ) ( 0, PI/2 ) -1 Fwd \u0026gt; Left o 分析特殊情形 # 坐标 ( Velocity , Angle ) 速度为0，夹角应该为0 # Velocity 为 0 ，( 0, 任意 ) 对应 Idle ，可以显示正确动画 速度不为0，夹角为0或PI时 # 叉乘结果为 0 ，即sign(c.z)为 0 ，即计算夹角得到 0 ，对应动画 RunFwd 夹角为 0 使用 RunFwd 正确，夹角为 PI 应该使用 RunBwd 夹角为 PI 时，不使用乘积，使用反余弦结果 可以在蓝图中实现夹角的计算，也可以在C++中实现 # 绘制ForwardVector，RightVector和VelocityVector # 虚幻编辑器 使用 DrawDebugArrow : Duration 为 0 ，每帧都进行绘画 - 起点 Actor 当前位置 终点 起点 + 偏移 绘制 ForwardVector # - 偏移 放大的前进方向向量 绘制 RightVector # - 偏移 放大的向右方向向量 绘制 VelocityVector # - 偏移 放大的速度方向单位向量 效果图 # 一直显示 ForwardVector 和 RightVector ，有速度才会显示 VelocityVector 优化显示 # 项目设置 \u0026gt; Engine \u0026gt; Rendering \u0026gt; Default Settings \u0026gt; Auto Exposure，取消勾选 旨在模拟人眼适应不同亮度 看不出区别, 取消设置 添加走路转向动画 # 虚幻编辑器 创建2D混合空间资产作为走路转向动画 # Blend Space 创建2D混合空间资产, 命名为BS_Locomotion_Walk 设置轴 横轴: 速度 - Name Velocity 范围 [ 0, 600 ] 纵轴: ForwardVector 和 VelocityVector 的夹角 - Name Direction 范围 [ -180, 180 ] 设置动画 ( Velocity , Direction ) 动画资产 说明 ( 0, 0 ) Idle 初始状态 ( 600, 0 ) Run_Fwd 满速前进 ( 600, -180 ) 和 ( 600, 180 ) Run_Bwd 满速后退 ( 600, 90 ) Run_Rt 满速向右 ( 600, -90 ) Run_Lt 满速向左 将BS_Locomotion_Walk用作走路动画 # ABP_BaseCharacter 将BS_Locomotion_Walk设置为Walk状态的输入 变量Velocity作为横轴Velocity的输入 添加变量 Direction - 类型 float 默认值 0 变量Direction作为纵轴Direction的输入 在蓝图中计算夹角 # 虚幻编辑器 在蓝图中计算夹角并设置变量 # 计算点乘时， ForwardVector 和 VelocityVector 都是单位向量 计算夹角 # 当前并未在夹角为PI时做处理，后退动画偶有闪动但看似正常 接着设置IsRunning, 设置Direction # 输出 # 输出点乘的反余弦结果，静止时输出90 输出叉乘结果，静止、前进或后退时，坐标为 0 但是有正负 输出 Sign 结果，静止时为 0 ，前进或后退时，其结果或为 1 或为 -1 ，飘忽不定，但不为 0 ，所以后退动画看似正常 可以做出合理推测：显示为 0 但不意味着为 0 ，数值很小 叉乘时传入未单位化的 Velocity 无改善 同时按下后退和向左，或者后退和向右，正负 3PI/4 的动画较为刻意 ( PI/2, PI ) 和 ( -PI, -PI/2 ) 时可以只显示 Run_Bwd 绘制 ForwardVectr 和 VelocityVector 的叉乘结果 # - 偏移 放大的叉乘结果 运动时才有向量显示 向前和向后运动时，偶有不明显的显示 取消变量的设置 # 接下来在代码计算夹角 在代码中计算夹角 # 添加接口, 返回Direction # C++ 添加函数声明 public 可在蓝图中调用，也可供其他类使用 ShootThemUp: Player/STUBaseCharacter.h UFUNCTION(BlueprintCallable) float GetDirection() const; 实现 速度为0时, 夹角为0 速度不为0, 叉乘结果为0时, 夹角为PI或-PI, 返回反余弦结果 ShootThemUp: Player/STUBaseCharacter.cpp float ASTUBaseCharacter::GetDirection() const { if (GetVelocity().IsZero()) return 0.0f; const FVector ForwardVector = GetActorForwardVector(); const FVector VelocityNormalizedVector = GetVelocity().GetSafeNormal(); const float DotProductResult = FVector::DotProduct(ForwardVector, VelocityNormalizedVector); const float Theta = FMath::RadiansToDegrees(FMath::Acos(DotProductResult)); const FVector CrossProductResult = FVector::CrossProduct(ForwardVector, VelocityNormalizedVector); return (CrossProductResult.IsZero() ? Theta : FMath::Sign(CrossProductResult.Z) * Theta); } 代码优化: 前后左右移动的回调函数MoveForward和MoveRight # C++ 若 Amount 为0，直接返回 ShootThemUp: Player/STUBaseCharacter.cpp void ASTUBaseCharacter::MoveForward(float Amount) { IsForward = Amount \u0026gt; 0.0f; if (Amount == 0.0f) return; AddMovementInput(GetActorForwardVector(), Amount); } void ASTUBaseCharacter::MoveRight(float Amount) { if (Amount == 0.0f) return; AddMovementInput(GetActorRightVector(), Amount); } 在蓝图中使用C++函数设置变量Direction # 虚幻编辑器 ABP_BaseCharacter \u0026gt; EventGraph 阻断动画蓝图无效状态 # 当我们打开动画蓝图时，其以standalone方式运行。即使未在虚幻编辑器中运行游戏，在蓝图编辑器打开ABP_BaseCharacter，其处于运行状态。可以看到动画蓝图视口的 Actor 是有动画的。 从EventBlueprintUpdateAnimation出发，TryGetPawnOwner得到空指针，停在CastToCharacter # 添加打印名，验证动画蓝图运行 # 未在虚幻编辑器运行游戏，保持动画蓝图在前台，日志窗口一直有输出 未运行游戏时，阻断动画蓝图 # 从 EventBlueprintUpdateAnimation 出发，添加 IsValid 宏，检查 Pawn 有效性 "}),e.add({id:25,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E6%89%93%E5%8C%85%E6%B8%B8%E6%88%8F/",title:"打包游戏",description:"说明 # 打包游戏，从二进制文件运行 定期打包游戏，确保所做改动能正常运行 设置玩家出发点 # 参考 LevelEditor \u0026gt; PlaceActors \u0026gt; Basic \u0026gt; PlayerStart，添加到关卡中 设置编译选项 # 项目设置 \u0026gt; Project \u0026gt; Packaging \u0026gt; Project \u0026gt; Build Configuration，选择 发行(Shipping) 编译游戏 # 参考 创建文件夹 ShootThemUp/Build 设置二进制文件保存路径 工具栏 \u0026gt; Platforms \u0026gt; Mac \u0026gt; Package Project，选择 Build 文件夹 可在日志窗口查看过程 打包成功 生成 ShootThemUp/Build/Mac/ShootThemUp-Shipping.app 尝试 Development 和 DebugGame 选项，均可 纯蓝图项目没有 DebugGame 选项 metal-ar报错 # 当前项目路径不包含空格，但包含汉字 打包项目 菜单栏 \u0026gt; File \u0026gt; Zip Project 移动到不含空格的英文路径 ",content:"说明 # 打包游戏，从二进制文件运行 定期打包游戏，确保所做改动能正常运行 设置玩家出发点 # 参考 LevelEditor \u0026gt; PlaceActors \u0026gt; Basic \u0026gt; PlayerStart，添加到关卡中 设置编译选项 # 项目设置 \u0026gt; Project \u0026gt; Packaging \u0026gt; Project \u0026gt; Build Configuration，选择 发行(Shipping) 编译游戏 # 参考 创建文件夹 ShootThemUp/Build 设置二进制文件保存路径 工具栏 \u0026gt; Platforms \u0026gt; Mac \u0026gt; Package Project，选择 Build 文件夹 可在日志窗口查看过程 打包成功 生成 ShootThemUp/Build/Mac/ShootThemUp-Shipping.app 尝试 Development 和 DebugGame 选项，均可 纯蓝图项目没有 DebugGame 选项 metal-ar报错 # 当前项目路径不包含空格，但包含汉字 打包项目 菜单栏 \u0026gt; File \u0026gt; Zip Project 移动到不含空格的英文路径 "}),e.add({id:26,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/",title:"阶段性总结",description:"项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent Player STUBaseCharacter STUPlayerController STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 左右移动 AddMovementInput；GetActorRightVector MoveForward 前后移动 AddMovementInput；GetActorForwardVector 左右旋转 ACharacter::AddControllerYawInput 上下旋转 ACharacter::AddControllerPitchInput 跳跃 ACharacter::Jump RunEnable，RunDisable 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机",content:`项目结构 # 资产 # - Content ExternalContent Animation Levels DefaultMap Player Animations ABP_BaseCharacter BS_Locomotion_Run BS_Locomotion_Walk BS_Locomotion_Walk_1D BP_STUBaseCharacter BP_STUPlayerController BP_STUGameModeBase 代码 # - ShootThemUp Public Components STUCharacterMovementComponent Player STUBaseCharacter STUPlayerController STUGameModeBase 项目基础设置 # - 载入 ExternalContent/Animation 创建 DefaultMap 并设置 设置地板 配置头文件搜索路径 添加 PlayerStart 设置 编译成功自动保存 游戏角色 # - C++ Player/STUBaseCharacter Blueprint Player/BP_STUBaseCharacter Player/Animations/ABP_BaseCharacter Player/Animations/BS_Locomotion_Run Player/Animations/BS_Locomotion_Walk Player/Animations/BS_Locomotion_Walk_1D STUBaseCharacter # C++ 函数成员 # 基本函数 操作 构造函数 设置组件类型(初始化列表)；初始化组件 BeginPlay 检查组件是否成功创建(check)；组件设置；注册委托 SetupPlayerInputComponent 检查组件；绑定平移旋转跳跃跑步键位 键位绑定 回调函数 键位 相关函数 MoveRight 左右移动 AddMovementInput；GetActorRightVector MoveForward 前后移动 AddMovementInput；GetActorForwardVector 左右旋转 ACharacter::AddControllerYawInput 上下旋转 ACharacter::AddControllerPitchInput 跳跃 ACharacter::Jump RunEnable，RunDisable 跑步 接口 接口函数 操作 GetDirection 计算前进方向和速度方向的夹角；供ABP_STBaseCharacter使用 IsRunning 判断角色是否满足跑步条件；供STUCharacterMovementComponent使用；供ABP_STBaseCharacter使用 数据成员 # 组件 用途 SpringArmComponent 以游戏角色为中心左右旋转 CameraComponent 第三视角 CharacterMovementComponent 运动组件 标志位 说明 AbleRun 跑步键位是否按下 IsForward 向前方向键是否按下 Player/BP_STUBaseCharacter # Blueprint CapsuleComponent # MeshComponent # 说明 Mesh \u0026gt; Skeletal Mesh Asset HeroTPP Materials \u0026gt; Element 0 HeroTPP Animation Mode UseAnimationBlueprint AnimClass ABP_BaseCharacter SpringArmComponent # 说明 UsePawnControlRotation true Player/Animations/ABP_BaseCharacter # Blueprint AnimGraph # 状态机
Locomotion作为OutputPose的输入 状态 状态 说明 走路 Walk BS_Locomotion_Walk；混合空间 跑步 Run BS_Locomotion_Run；混合空间1D 跳跃 JumpStart JumpLoop JumpEnd 变量 动画输入 名称 速度 Velocity 速度和前进方向的夹角 Directon 转换条件 说明 IsRunning C++ 满足3个条件：按下Shift；速度和前进方向夹角为0（按下W或Up）；速度不为0 IsFalling CharacterMovementComponent::IsFalling 返回true，意味着游戏角色跳起；接着返回false，意味着游戏角色回到地面 EventGraph # 设置变量 - Velocity Directon IsRunning IsFalling 组件 # C++ STUCharacterMovementComponent # 满足跑步条件时，提高运动速度上限 参数 说明 SpeedAcceleration 加速系数 `}),e.add({id:27,href:"/docs/",title:"笔记",description:"",content:""}),e.add({id:28,href:"/docs/%E5%88%86%E4%BA%AB/emacs/",title:"Emacs",description:"",content:""}),e.add({id:29,href:"/docs/brick/",title:"🧱",description:"",content:""}),e.add({id:30,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/",title:"开发工具",description:"",content:""}),e.add({id:31,href:"/docs/%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/",title:"开发语言",description:"",content:""}),e.add({id:32,href:"/docs/%E5%88%86%E4%BA%AB/hugo/",title:"Hugo",description:"",content:""}),e.add({id:33,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/",title:"虚幻引擎",description:"",content:""}),e.add({id:34,href:"/docs/%E5%88%86%E4%BA%AB/",title:"分享",description:"",content:""}),e.add({id:35,href:"/docs/%E5%88%86%E4%BA%AB/macos%E5%BA%94%E7%94%A8/",title:"macOS应用",description:"",content:""}),e.add({id:36,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E8%A7%92%E8%89%B2%E5%92%8C%E5%8A%A8%E7%94%BB/",title:"角色和动画",description:"",content:""}),e.add({id:37,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/%E5%81%A5%E5%BA%B7%E7%B3%BB%E7%BB%9F/",title:"健康系统",description:"",content:""}),e.add({id:38,href:"/docs/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B/",title:"进阶课程",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()